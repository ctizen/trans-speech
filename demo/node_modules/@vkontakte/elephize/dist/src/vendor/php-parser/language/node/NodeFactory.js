/**
 * Copyright 2017 Matt Acosta
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeFactory = void 0;
var NodeList_1 = require("./NodeList");
var TokenNode_1 = require("./TokenNode");
var ObjectCache_1 = require("./ObjectCache");
var TriviaNode_1 = require("./TriviaNode");
var TokenKind_1 = require("../TokenKind");
/**
 * Provides a factory service for creating tokens, trivia, and node lists.
 */
var NodeFactory = /** @class */ (function () {
    // #endregion
    /**
     * Creates a `NodeFactory` object.
     */
    function NodeFactory() {
        if (NodeFactory.TokensWithNoTrivia[TokenKind_1.TokenKind.Abstract] === void 0) {
            // Create reusable "well known" tokens.
            for (var kind = TokenKind_1.TokenKind.Abstract; kind < TokenKind_1.TokenKind.EOF; kind++) {
                var width = TokenKind_1.TokenKindInfo.getText(kind).length;
                var token = new TokenNode_1.TokenNode(kind, width);
                var tokenWithTrivia = new TokenNode_1.TokenWithTriviaNode(kind, width, NodeFactory.SingleLeadingSpace);
                NodeFactory.TokensWithNoTrivia[kind] = token;
                NodeFactory.TokensWithSingleLeadingSpace[kind] = tokenWithTrivia;
            }
        }
    }
    /**
     * Determines if the token is one of the reusable token kinds.
     */
    NodeFactory.isWellKnownKind = function (kind) {
        return kind >= TokenKind_1.TokenKind.Abstract && kind < TokenKind_1.TokenKind.EOF;
    };
    /**
     * Creates a `NodeList` and caches it, if possible.
     */
    NodeFactory.prototype.createList = function (nodes, diagnostics) {
        if (nodes.length === 1) {
            if (diagnostics === void 0) {
                if (nodes[0] === NodeFactory.SingleWhitespace) {
                    return NodeFactory.SingleLeadingSpace;
                }
                if (nodes[0] === NodeFactory.DoubleWhitespace) {
                    return NodeFactory.TwoLeadingSpaces;
                }
                if (nodes[0] === NodeFactory.QuadrupleWhitespace) {
                    return NodeFactory.FourLeadingSpaces;
                }
            }
            var list = new NodeList_1.SingleChildListNode(nodes[0], diagnostics);
            return this.getCachedList(list, list.hashCode());
        }
        else if (nodes.length === 2) {
            var list = new NodeList_1.TwoChildListNode(nodes[0], nodes[1], diagnostics);
            return this.getCachedList(list, list.hashCode());
        }
        else if (nodes.length <= NodeFactory.ShortListLimit) {
            var list = new NodeList_1.ShortChildListNode(nodes, diagnostics);
            return nodes.length <= NodeFactory.ChildLimit
                ? this.getCachedList(list, list.hashCode()) : list;
        }
        else {
            // No point in trying to cache lists this long.
            return new NodeList_1.LongChildListNode(nodes, diagnostics);
        }
    };
    /**
     * Creates a missing token node.
     */
    NodeFactory.prototype.createMissingToken = function (kind, leadingTrivia, diagnostics) {
        return new TokenNode_1.MissingTokenWithTriviaNode(kind, leadingTrivia, diagnostics);
    };
    /**
     * Creates a skipped token node (which is actually a trivia node).
     */
    NodeFactory.prototype.createSkippedTokenTrivia = function (kind, fullWidth, diagnostics) {
        return new TriviaNode_1.SkippedTokenNode(kind, fullWidth, diagnostics);
    };
    /**
     * Creates a token node that does not contain any leading trivia.
     */
    NodeFactory.prototype.createToken = function (kind, fullWidth, diagnostics) {
        if (diagnostics !== void 0 && diagnostics.length > 0) {
            return new TokenNode_1.TokenNode(kind, fullWidth, diagnostics);
        }
        if (NodeFactory.isWellKnownKind(kind)) {
            return NodeFactory.TokensWithNoTrivia[kind];
        }
        var token = new TokenNode_1.TokenNode(kind, fullWidth);
        return this.getCachedNode(token, token.hashCode());
    };
    /**
     * Creates a token node that also contains leading trivia.
     *
     * @param {TokenKind} kind
     *   The type of token.
     * @param {number} tokenWidth
     *   The full width of the token node (which at this point does not include
     *   leading trivia).
     * @param {NodeList} leadingTrivia
     *   A list of trivia nodes that were parsed ahead of the token.
     * @param {SyntaxDiagnostic[]=} diagnostics
     *   An optional list of diagnostics that should be added to the token node.
     */
    NodeFactory.prototype.createTokenWithTrivia = function (kind, tokenWidth, leadingTrivia, diagnostics) {
        if (diagnostics !== void 0 && diagnostics.length > 0) {
            return new TokenNode_1.TokenWithTriviaNode(kind, tokenWidth, leadingTrivia, diagnostics);
        }
        if (NodeFactory.isWellKnownKind(kind) && leadingTrivia === NodeFactory.SingleLeadingSpace) {
            return NodeFactory.TokensWithSingleLeadingSpace[kind];
        }
        var token = new TokenNode_1.TokenWithTriviaNode(kind, tokenWidth, leadingTrivia);
        return this.getCachedNode(token, token.hashCode());
    };
    /**
     * Creates a trivia node.
     */
    NodeFactory.prototype.createTrivia = function (kind, fullWidth, diagnostics) {
        if (diagnostics !== void 0 && diagnostics.length > 0) {
            return new TriviaNode_1.TriviaNode(kind, fullWidth, diagnostics);
        }
        // Whitespace is very common, bypass the cache if possible.
        if (kind === TokenKind_1.TokenKind.LineBreak) {
            if (fullWidth === 1) {
                return NodeFactory.LF;
            }
            if (fullWidth === 2) {
                return NodeFactory.CRLF;
            }
        }
        else if (kind === TokenKind_1.TokenKind.Whitespace) {
            if (fullWidth === 1) {
                return NodeFactory.SingleWhitespace;
            }
            if (fullWidth === 2) {
                return NodeFactory.DoubleWhitespace;
            }
            if (fullWidth === 4) {
                return NodeFactory.QuadrupleWhitespace;
            }
        }
        var trivia = new TriviaNode_1.TriviaNode(kind, fullWidth);
        return this.getCachedNode(trivia, trivia.hashCode());
    };
    /**
     * @todo Document getCachedList<T>().
     * @todo Test performance when merged with `getCachedNode()`.
     */
    NodeFactory.prototype.getCachedList = function (node, hash) {
        var cached = NodeFactory.ListCache.tryGetObject(node, hash);
        if (cached !== null) {
            return cached;
        }
        else if (this.isCacheableList(node)) {
            NodeFactory.ListCache.set(node, hash);
        }
        return node;
    };
    /**
     * @todo Document getCachedNode<T>().
     */
    NodeFactory.prototype.getCachedNode = function (node, hash) {
        var cached = NodeFactory.NodeCache.tryGetObject(node, hash);
        if (cached !== null) {
            return cached;
        }
        else if (this.isCacheableNode(node)) {
            NodeFactory.NodeCache.set(node, hash);
        }
        return node;
    };
    /**
     * Determines if a node containing a list of children is cacheable.
     */
    NodeFactory.prototype.isCacheableList = function (node) {
        if (node.containsDiagnostics || node.containsSkippedText) {
            return false;
        }
        var count = node.count;
        if (count > NodeFactory.ChildLimit) {
            return false;
        }
        for (var i = 0; i < count; i++) {
            var child = node.childAt(i);
            if (child !== null) {
                if (!NodeFactory.NodeCache.has(child, child.hashCode())) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * Determines if a node is cachebale.
     */
    NodeFactory.prototype.isCacheableNode = function (node) {
        if (node.containsDiagnostics || node.containsSkippedText || node.isMissing) {
            return false;
        }
        var count = node.count;
        if (count > NodeFactory.ChildLimit) {
            return false;
        }
        for (var i = 0; i < count; i++) {
            var child = node.childAt(i);
            if (child !== null) {
                if (child.isList) {
                    if (!NodeFactory.ListCache.has(child, child.hashCode())) {
                        return false;
                    }
                }
                else if (!NodeFactory.NodeCache.has(child, child.hashCode())) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * A trivia node representing a CRLF token.
     */
    NodeFactory.CRLF = new TriviaNode_1.TriviaNode(TokenKind_1.TokenKind.LineBreak, 2);
    /**
     * A trivia node representing a LF token.
     */
    NodeFactory.LF = new TriviaNode_1.TriviaNode(TokenKind_1.TokenKind.LineBreak, 1);
    // #region Whitespace
    /**
     * A trivia node representing a single whitespace character.
     */
    NodeFactory.SingleWhitespace = new TriviaNode_1.TriviaNode(TokenKind_1.TokenKind.Whitespace, 1);
    /**
     * A trivia node representing two whitespace characters.
     */
    NodeFactory.DoubleWhitespace = new TriviaNode_1.TriviaNode(TokenKind_1.TokenKind.Whitespace, 2);
    /**
     * A trivia node representing four whitespace characters.
     */
    NodeFactory.QuadrupleWhitespace = new TriviaNode_1.TriviaNode(TokenKind_1.TokenKind.Whitespace, 4);
    /**
     * A list node containing a single whitespace character, used for leading trivia.
     */
    NodeFactory.SingleLeadingSpace = new NodeList_1.SingleChildListNode(NodeFactory.SingleWhitespace);
    /**
     * A list node containing two whitespace characters, used for leading trivia.
     */
    NodeFactory.TwoLeadingSpaces = new NodeList_1.SingleChildListNode(NodeFactory.DoubleWhitespace);
    /**
     * A list node containing four whitespace characters, used for leading trivia.
     */
    NodeFactory.FourLeadingSpaces = new NodeList_1.SingleChildListNode(NodeFactory.QuadrupleWhitespace);
    // #endregion
    // #region Caching
    /**
     * A cache for lists of tokens or trivia.
     *
     * @todo Merge back into `NodeCache`?
     */
    NodeFactory.ListCache = new ObjectCache_1.ObjectCache(15);
    /**
     * A cache for tokens and trivia.
     *
     * @todo Determine the ideal size: 15=32768, 16=65536.
     */
    NodeFactory.NodeCache = new ObjectCache_1.ObjectCache(15);
    /**
     * A list of reusable tokens without leading trivia.
     */
    NodeFactory.TokensWithNoTrivia = new Array(TokenKind_1.TokenKind.EOF);
    /**
     * A list of reusable tokens with a single leading space.
     */
    NodeFactory.TokensWithSingleLeadingSpace = new Array(TokenKind_1.TokenKind.EOF);
    /**
     * The maximum number of children a node may have before being uncachable.
     */
    NodeFactory.ChildLimit = 3;
    /**
     * The maximum list size before lists are created with pre-calculated offsets.
     * A high value, will increase the compute time to find an offset, while a low
     * value will increase the memory usage of list nodes.
     *
     * @todo Determine the ideal limit.
     */
    NodeFactory.ShortListLimit = 8;
    return NodeFactory;
}());
exports.NodeFactory = NodeFactory;
