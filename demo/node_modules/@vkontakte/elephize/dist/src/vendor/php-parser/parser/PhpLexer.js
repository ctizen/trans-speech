/**
 * Copyright 2017 Matt Acosta
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhpLexer = exports.HeredocLabelInfo = void 0;
var php_common_1 = require("../../php-common");
var Character_1 = require("./Character");
var Encoding_1 = require("../text/Encoding");
var ErrorCode_Generated_1 = require("../diagnostics/ErrorCode.Generated");
var Lexer_1 = require("./Lexer");
var PhpLexerState_1 = require("./PhpLexerState");
var PhpVersion_1 = require("./PhpVersion");
var TemplateSpan_1 = require("./TemplateSpan");
var Token_1 = require("./Token");
var TokenKind_1 = require("../language/TokenKind");
/**
 * @internal
 */
var HeredocLabelInfo = /** @class */ (function () {
    function HeredocLabelInfo(label, fullLength, isNowdoc) {
        this.label = label;
        this.fullLength = fullLength;
        this.isNowdoc = isNowdoc;
    }
    return HeredocLabelInfo;
}());
exports.HeredocLabelInfo = HeredocLabelInfo;
/**
 * Tokenizes PHP source text.
 *
 * IMPORTANT: This class is performance critical and must make every effort to
 * allow native optimization by the V8 engine.
 */
var PhpLexer = /** @class */ (function (_super) {
    __extends(PhpLexer, _super);
    /**
     * Constructs a `PhpLexer` object.
     *
     * @param {ISourceText} text
     *   The source text to tokenize.
     * @param {PhpVersion=} phpVersion
     *   The version of PHP to parse tokens as. Defaults to `PhpVersion.Latest`.
     * @param {boolean=} is64Bit
     *   Determines if the lexer should scan numbers as if PHP were compiled with
     *   64-bit support. Defaults to `true`.
     * @param {boolean=} allowUtf16
     *   Determines if the lexer should scan text as if PHP were aware of UTF-16
     *   encoded characters. Defaults to `false`.
     *
     * @todo Add `start` and `length` parameters?
     */
    function PhpLexer(text, phpVersion, is64Bit, allowUtf16) {
        if (phpVersion === void 0) { phpVersion = PhpVersion_1.PhpVersion.Latest; }
        if (is64Bit === void 0) { is64Bit = true; }
        if (allowUtf16 === void 0) { allowUtf16 = false; }
        var _this = _super.call(this, text, PhpLexerState_1.PhpLexerState.InHostLanguage) || this;
        /**
         * Determines if short open tags "<?" are permitted. Defaults to `false`.
         */
        _this.allowShortOpen = false;
        /**
         * Determines if the lexer should scan text as if PHP were aware of UTF-16
         * encoded characters. Defaults to `false`.
         */
        _this.allowUtf16 = false;
        /**
         * The default scanning mode when starting to scan text, or when not in a
         * pre-defined region.
         *
         * @see PhpLexer.templateStack
         */
        _this.defaultState = PhpLexerState_1.PhpLexerState.InHostLanguage;
        /**
         * The indentation to remove from lines in a flexdoc template.
         */
        _this.flexibleIndent = '';
        /**
         * Temporary storage for spans within a string template.
         */
        _this.interpolations = [];
        /**
         * A pre-defined list containing state transitions for a region of text.
         */
        _this.templateStack = [];
        /**
         * The kind of token that was scanned.
         */
        _this.tokenKind = TokenKind_1.TokenKind.Unknown;
        /**
         * The starting offset of the token that was scanned.
         */
        _this.tokenStart = 0;
        /**
         * The size of a `long` used by PHP.
         */
        _this.ptrSize = 8;
        _this.allowUtf16 = allowUtf16;
        _this.phpVersion = phpVersion;
        _this.ptrSize = is64Bit ? 8 : 4;
        return _this;
    }
    Object.defineProperty(PhpLexer.prototype, "currentState", {
        /**
         * The current lexing state.
         */
        get: function () {
            return this.state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PhpLexer.prototype, "sourceText", {
        /**
         * The text currently being scanned.
         */
        get: function () {
            return this.text;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PhpLexer.prototype, "templateSpans", {
        /**
         * A list of regions within a string template that may be rescanned for
         * additional tokens. This list is empty for all other tokens.
         */
        get: function () {
            return this.interpolations; // @todo Clone?
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Scans the source text until a token is found.
     */
    PhpLexer.prototype.lex = function (state) {
        this.diagnostics = [];
        this.state = state;
        this.tokenStart = this.offset;
        if (this.offset >= this.end) {
            this.tokenKind = TokenKind_1.TokenKind.EOF;
            return new Token_1.Token(this.tokenKind, this.tokenStart, 0, this.diagnostics);
        }
        switch (this.state) {
            // Standard lexing states.
            case PhpLexerState_1.PhpLexerState.InHostLanguage:
                this.state = this.lexInlineText();
                break;
            case PhpLexerState_1.PhpLexerState.InScript:
                this.state = this.lexScript();
                break;
            // Rescanning states.
            case PhpLexerState_1.PhpLexerState.InDoubleQuote:
            case PhpLexerState_1.PhpLexerState.InFlexibleHeredoc:
            case PhpLexerState_1.PhpLexerState.InHeredoc:
            case PhpLexerState_1.PhpLexerState.InShellCommand:
                this.state = this.lexString();
                break;
            case PhpLexerState_1.PhpLexerState.InFlexibleNowdoc:
            case PhpLexerState_1.PhpLexerState.InNowdoc:
                this.state = this.lexNowdoc();
                break;
            case PhpLexerState_1.PhpLexerState.InVariableOffset:
                this.state = this.lexVariableOffset();
                break;
            case PhpLexerState_1.PhpLexerState.LookingForHeredocIndent:
                this.state = this.lexString();
                break;
            case PhpLexerState_1.PhpLexerState.LookingForHeredocLabel:
                this.state = this.lexHeredocLabel();
                break;
            // case PhpLexerState.LookingForProperty:
            //   this.state = this.lexProperty();
            //   break;
            case PhpLexerState_1.PhpLexerState.LookingForVariableName:
                this.state = this.lexVariableName();
                break;
            default:
                throw new php_common_1.Exception('Invalid lexer state');
        }
        // If the lexer is currently rescanning a string template, then the state
        // may have already been determined.
        if (this.templateStack.length > 0) {
            // End of current span.
            if (this.offset === this.templateStack[0].start + this.templateStack[0].length) {
                this.state = this.defaultState;
                this.templateStack.shift();
            }
            // If there is another span, then it may start immediately.
            if (this.templateStack.length > 0 && this.offset === this.templateStack[0].start) {
                this.state = this.templateStack[0].state;
                // If a heredoc string had an end label, extend the scan range back
                // to its normal length.
                if (this.state === PhpLexerState_1.PhpLexerState.LookingForHeredocLabel && this.offset === this.end) {
                    this.end = this.end + this.templateStack[0].length;
                }
            }
        }
        return new Token_1.Token(this.tokenKind, this.tokenStart, this.offset - this.tokenStart, this.diagnostics);
    };
    /**
     * Initializes the lexer with predetermined lexing regions found after
     * scanning a `FlexdocTemplate` token.
     */
    PhpLexer.prototype.rescanInterpolatedFlexdoc = function (spans) {
        if (spans.length < 1) {
            throw new php_common_1.ArgumentException('Flexdoc template must contain at least one span');
        }
        if (spans[spans.length - 1].state !== PhpLexerState_1.PhpLexerState.LookingForHeredocLabel) {
            throw new php_common_1.ArgumentException('Flexdoc template must end with a label span');
        }
        this.defaultState = PhpLexerState_1.PhpLexerState.InFlexibleHeredoc;
        this.state = PhpLexerState_1.PhpLexerState.LookingForHeredocLabel;
        this.templateStack = spans;
        var endSpan = spans[spans.length - 1];
        // Get the indent.
        var endLabel = this.text.substring(endSpan.start, endSpan.length);
        for (var i = 0; i < endLabel.length; i++) {
            if (!Character_1.CharacterInfo.isWhitespace(endLabel.charCodeAt(i))) {
                this.flexibleIndent = endLabel.substr(0, i);
                break;
            }
        }
        // Force the lexer to stop just before an end label instead of always
        // trying to scan for it. After reaching the last span, this region will
        // be "appended" and scanned normally.
        this.end = this.end - endSpan.length;
    };
    /**
     * Initializes the lexer with predetermined lexing regions found after
     * scanning a `HeredocTemplate` token.
     */
    PhpLexer.prototype.rescanInterpolatedHeredoc = function (spans) {
        this.defaultState = PhpLexerState_1.PhpLexerState.InHeredoc;
        this.state = PhpLexerState_1.PhpLexerState.LookingForHeredocLabel;
        this.templateStack = spans;
        // Force the lexer to stop just before an end label instead of always
        // trying to scan for it. After reaching the last span, this region will
        // be "appended" and scanned normally.
        if (spans.length > 0 && spans[spans.length - 1].state === PhpLexerState_1.PhpLexerState.LookingForHeredocLabel) {
            this.end = this.end - spans[spans.length - 1].length;
        }
    };
    /**
     * Initializes the lexer with predetermined lexing regions found after
     * scanning a `ShellCommandTemplate` token.
     */
    PhpLexer.prototype.rescanInterpolatedShellCommand = function (spans) {
        this.state = this.defaultState = PhpLexerState_1.PhpLexerState.InShellCommand;
        this.templateStack = spans;
        if (spans.length > 0 && this.offset === spans[0].start) {
            this.state = spans[0].state;
        }
    };
    /**
     * Initializes the lexer with predetermined lexing regions found after
     * scanning a `StringTemplate` token.
     *
     * This method should only be used on a new, temporary `PhpLexer` object,
     * that was created with the text of the `StringTemplate` token.
     *
     * @see PhpLexer.templateSpans
     */
    PhpLexer.prototype.rescanInterpolatedString = function (spans) {
        if (spans.length === 0) {
            throw new php_common_1.ArgumentException('String template must contain at least 1 span');
        }
        this.state = this.defaultState = PhpLexerState_1.PhpLexerState.InDoubleQuote;
        this.templateStack = spans;
        if (this.offset === spans[0].start) {
            this.state = spans[0].state;
        }
    };
    /**
     * Sets the source text to tokenize.
     *
     * @param {ISourceText} text
     *   The source text to tokenize.
     * @param {number=} start
     *   The offset within the text to start tokenizing. Defaults to 0.
     * @param {number=} length
     *   The maximum number of characters to tokenize. Defaults to the length
     *   of the text.
     */
    PhpLexer.prototype.setText = function (text, start, length) {
        this.text = text;
        start = start === void 0 ? 0 : start;
        length = length === void 0 ? text.length : length;
        this.setBounds(start, start + length);
        this.setPosition(start);
    };
    /**
     * Determines if the given heredoc (or nowdoc) label is present at the
     * lexer's current position.
     *
     * @param {string} label
     *   The label used to delimit the string.
     */
    PhpLexer.prototype.isHeredocEnd = function (label) {
        // Don't move the actual lexer position.
        var offset = this.offset;
        // PHP 7.3 allows leading whitespace.
        if (this.phpVersion >= PhpVersion_1.PhpVersion.PHP7_3) {
            while (offset < this.end && Character_1.CharacterInfo.isWhitespace(this.text.charCodeAt(offset))) {
                offset++;
            }
        }
        // End label.
        if (offset + label.length > this.end) {
            return false;
        }
        var labelStart = offset;
        if (Character_1.CharacterInfo.isIdentifierStart(this.text.charCodeAt(offset))) {
            offset++;
            // No partial matches, so get the full identifier.
            while (offset < this.end) {
                var ch_1 = this.text.charCodeAt(offset);
                if (!Character_1.CharacterInfo.isIdentifierPart(ch_1, this.phpVersion)) {
                    break;
                }
                offset++;
            }
            // Compare to the label.
            if (this.text.substring(labelStart, offset - labelStart) !== label) {
                return false;
            }
        }
        else {
            return false;
        }
        // PHP 7.3 also removes requirements for trailing characters.
        if (this.phpVersion >= PhpVersion_1.PhpVersion.PHP7_3) {
            return true;
        }
        // Optional semicolon.
        if (this.peek(offset) === 59 /* Semicolon */) {
            offset++;
        }
        // Required line break.
        var ch = this.peek(offset);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            return true;
        }
        return false;
    };
    /**
     * Tokenizes a starting or ending heredoc label.
     */
    PhpLexer.prototype.lexHeredocLabel = function () {
        var ch = this.text.charCodeAt(this.offset);
        if (ch === 60 /* LessThan */) {
            var info = this.tryScanHeredocStartLabel();
            if (this.flexibleIndent) {
                this.state = PhpLexerState_1.PhpLexerState.LookingForHeredocIndent;
            }
            else {
                this.state = (info && info.isNowdoc) ? PhpLexerState_1.PhpLexerState.InNowdoc : PhpLexerState_1.PhpLexerState.InHeredoc;
            }
            this.tokenKind = TokenKind_1.TokenKind.HeredocStart;
        }
        else if (Character_1.CharacterInfo.isWhitespace(ch)) {
            // NOTE: Do not move past the first whitespace character yet.
            this.scanHeredocEndLabelIndent();
            this.tokenKind = TokenKind_1.TokenKind.StringIndent;
        }
        else {
            this.offset++;
            this.scanIdentifierPart();
            this.tokenKind = TokenKind_1.TokenKind.HeredocEnd;
        }
        return this.state;
    };
    /**
     * Tokenizes inline text until a PHP open tag is encountered.
     */
    PhpLexer.prototype.lexInlineText = function () {
        if (this.text.encoding === Encoding_1.Encoding.Utf16le && !this.allowUtf16) {
            // All code points are encoded using at least two bytes, which prevents
            // PHP from finding an open tag (null bytes are between each character).
            this.offset = this.end;
            this.tokenKind = TokenKind_1.TokenKind.InlineText;
            return this.state;
        }
        // Only return an opening tag if there is no inline text in the way.
        var length = this.tryScanOpenTag();
        if (length) {
            this.tokenKind = length === 5
                ? TokenKind_1.TokenKind.OpenTag
                : length === 3 ? TokenKind_1.TokenKind.OpenTagWithEcho : TokenKind_1.TokenKind.ShortOpenTag;
            return PhpLexerState_1.PhpLexerState.InScript;
        }
        this.offset++;
        while (this.offset < this.end) {
            length = this.tryScanOpenTag();
            if (length > 0) {
                // Do not return the opening tag as part of the inline text.
                this.offset = this.offset - length;
                break;
            }
            this.offset++;
        }
        this.tokenKind = TokenKind_1.TokenKind.InlineText;
        return this.state;
    };
    /**
     * Tokenizes the text of a nowdoc string.
     */
    PhpLexer.prototype.lexNowdoc = function () {
        // In a regular nowdoc, the end label has been temporarily removed, so
        // there's nothing to do but instantaneously tokenize the string.
        if (this.state === PhpLexerState_1.PhpLexerState.InNowdoc) {
            this.offset = this.end;
            this.tokenKind = TokenKind_1.TokenKind.StringTemplateLiteral;
            return this.state;
        }
        // A flexible nowdoc actually has some tokens though.
        var ch = this.text.charCodeAt(this.offset);
        switch (ch) {
            case 32 /* Space */:
            case 9 /* Tab */:
                if (this.state === PhpLexerState_1.PhpLexerState.LookingForHeredocIndent) {
                    this.scanFlexdocIndent();
                    this.tokenKind = TokenKind_1.TokenKind.StringIndent;
                    this.state = PhpLexerState_1.PhpLexerState.InFlexibleNowdoc;
                    break;
                }
                this.scanNowdocString();
                this.tokenKind = TokenKind_1.TokenKind.StringTemplateLiteral;
                break;
            case 13 /* CarriageReturn */:
            case 10 /* LineFeed */:
                this.offset++;
                while (Character_1.CharacterInfo.isLineBreak(this.text.charCodeAt(this.offset))) {
                    this.offset++;
                }
                this.tokenKind = TokenKind_1.TokenKind.StringLineBreak;
                this.state = PhpLexerState_1.PhpLexerState.LookingForHeredocIndent;
                break;
            default:
                this.scanNowdocString();
                this.tokenKind = TokenKind_1.TokenKind.StringTemplateLiteral;
                break;
        }
        return this.state;
    };
    /**
     * Tokenizes object operators and property names.
     *
     * @todo Unused.
     */
    PhpLexer.prototype.lexProperty = function () {
        var ch = this.text.charCodeAt(this.offset);
        switch (ch) {
            // Line breaks
            case 13 /* CarriageReturn */:
            case 10 /* LineFeed */:
                if (ch === 13 /* CarriageReturn */ && this.peek(this.offset + 1) === 10 /* LineFeed */) {
                    this.offset = this.offset + 2;
                }
                else {
                    this.offset++;
                }
                this.tokenKind = TokenKind_1.TokenKind.LineBreak;
                return this.state;
            // Whitespace
            case 32 /* Space */:
            case 9 /* Tab */:
                this.offset++;
                this.scanWhitespace();
                this.tokenKind = TokenKind_1.TokenKind.Whitespace;
                return this.state;
            case 45 /* Minus */:
                if (this.peek(this.offset + 1) === 62 /* GreaterThan */) {
                    this.offset = this.offset + 2; // "->"
                    this.tokenKind = TokenKind_1.TokenKind.ObjectOperator;
                    return this.state;
                }
            // Fall through to {ANY_CHAR} rule.
            default:
                if (Character_1.CharacterInfo.isIdentifierStart(ch, this.phpVersion)) {
                    this.offset++;
                    this.scanIdentifierPart();
                    this.tokenKind = TokenKind_1.TokenKind.Identifier;
                    return this.state = PhpLexerState_1.PhpLexerState.InScript;
                }
                // No match. Need to fallback and try again.
                this.state = PhpLexerState_1.PhpLexerState.InScript;
                return this.lexScript();
        }
    };
    /**
     * Tokenizes the region of source text that contains PHP script.
     */
    PhpLexer.prototype.lexScript = function () {
        var ch = this.text.charCodeAt(this.offset);
        switch (ch) {
            // Line breaks
            case 13 /* CarriageReturn */:
            case 10 /* LineFeed */:
                if (ch === 13 /* CarriageReturn */ && this.peek(this.offset + 1) === 10 /* LineFeed */) {
                    this.offset = this.offset + 2;
                }
                else {
                    this.offset++;
                }
                this.tokenKind = TokenKind_1.TokenKind.LineBreak;
                return this.state;
            // Whitespace
            case 32 /* Space */:
            case 9 /* Tab */:
                this.offset++;
                this.scanWhitespace();
                this.tokenKind = TokenKind_1.TokenKind.Whitespace;
                return this.state;
        }
        // Express checkout for keywords and common identifiers.
        if ((ch >= 97 /* a */ && ch <= 122 /* z */) || (ch >= 65 /* A */ && ch <= 90 /* Z */)) {
            this.scanIdentifierOrKeyword();
            return this.state;
        }
        var next = this.peek(this.offset + 1);
        switch (ch) {
            // Variables
            case 36 /* Dollar */:
                if (Character_1.CharacterInfo.isIdentifierStart(next, this.phpVersion)) {
                    this.offset = this.offset + 2;
                    this.scanIdentifierPart();
                    this.tokenKind = TokenKind_1.TokenKind.Variable;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Dollar;
                }
                return this.state;
            // Strings
            case 96 /* BackQuote */:
                this.offset++;
                this.interpolations = [];
                this.scanInterpolatedString(96 /* BackQuote */, this.interpolations);
                if (this.peek(this.offset) === 96 /* BackQuote */) {
                    this.offset++;
                }
                else {
                    this.addError(0, this.offset - this.tokenStart, ErrorCode_Generated_1.ErrorCode.ERR_UnterminatedString);
                }
                this.tokenKind = TokenKind_1.TokenKind.ShellCommandTemplate;
                return this.state;
            case 34 /* DoubleQuote */:
                this.offset++;
                this.interpolations = [];
                this.scanInterpolatedString(34 /* DoubleQuote */, this.interpolations);
                if (this.peek(this.offset) === 34 /* DoubleQuote */) {
                    this.offset++;
                }
                else {
                    this.addError(0, this.offset - this.tokenStart, ErrorCode_Generated_1.ErrorCode.ERR_UnterminatedString);
                }
                this.tokenKind = this.interpolations.length ? TokenKind_1.TokenKind.StringTemplate : TokenKind_1.TokenKind.StringLiteral;
                return this.state;
            case 39 /* SingleQuote */:
                this.offset++;
                this.scanSingleQuoteString();
                if (this.peek(this.offset) === 39 /* SingleQuote */) {
                    this.offset++;
                }
                else {
                    this.addError(0, this.offset - this.tokenStart, ErrorCode_Generated_1.ErrorCode.ERR_UnterminatedStringConstant);
                }
                // PHP would normally return a `StringTemplate` here, if the string
                // was unterminated, which would in turn force the script to exit with
                // a syntax error. This lexer can generate the correct token however,
                // since it can add diagnostics instead.
                this.tokenKind = TokenKind_1.TokenKind.StringLiteral;
                return this.state;
            // Comments
            case 35 /* Hash */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.SingleLineComment;
                this.scanLineComment();
                return this.state;
            case 47 /* Slash */:
                if (next === 47 /* Slash */) {
                    this.offset = this.offset + 2; // "//"
                    // if (this.peek(this.offset) === Character.OpenBrace) {
                    //   this.offset++;
                    //   this.tokenKind = TokenKind.RegionStart;
                    // }
                    // else if (this.peek(this.offset) === Character.CloseBrace) {
                    //   this.offset++;
                    //   this.tokenKind = TokenKind.RegionEnd;
                    // }
                    // else {
                    //   this.tokenKind = TokenKind.SingleLineComment;
                    // }
                    this.tokenKind = TokenKind_1.TokenKind.SingleLineComment;
                    this.scanLineComment();
                    return this.state;
                }
                else if (next === 42 /* Asterisk */) {
                    this.offset = this.offset + 2; // "/*"
                    if (this.peek(this.offset) === 42 /* Asterisk */ && Character_1.CharacterInfo.isWhitespaceLike(this.peek(this.offset + 1))) {
                        this.offset = this.offset + 2;
                        this.tokenKind = TokenKind_1.TokenKind.DocumentationComment;
                    }
                    else {
                        this.tokenKind = TokenKind_1.TokenKind.MultipleLineComment;
                    }
                    this.scanMultipleLineComment();
                    if (this.peek(this.offset) === 42 /* Asterisk */ && this.peek(this.offset + 1) === 47 /* Slash */) {
                        this.offset = this.offset + 2; // "*/"
                    }
                    else {
                        this.addError(0, this.offset - this.tokenStart, ErrorCode_Generated_1.ErrorCode.WRN_UnterminatedComment);
                    }
                    return this.state;
                }
                else if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // "/="
                    this.tokenKind = TokenKind_1.TokenKind.DivideEqual;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Slash;
                }
                return this.state;
            // Punctuation
            case 64 /* At */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.At;
                return this.state;
            case 92 /* Backslash */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.Backslash;
                return this.state;
            case 125 /* CloseBrace */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.CloseBrace;
                return this.state;
            case 93 /* CloseBracket */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.CloseBracket;
                return this.state;
            case 41 /* CloseParen */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.CloseParen;
                return this.state;
            case 44 /* Comma */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.Comma;
                return this.state;
            case 123 /* OpenBrace */:
                // NOTE: A "{$" token can only occur in an interpolated string.
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.OpenBrace;
                return this.state;
            case 91 /* OpenBracket */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.OpenBracket;
                return this.state;
            case 59 /* Semicolon */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.Semicolon;
                return this.state;
            case 126 /* Tilde */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.Tilde;
                return this.state;
            // Compound punctuation
            case 38 /* Ampersand */:
                if (next === 38 /* Ampersand */) {
                    this.offset = this.offset + 2; // "&&"
                    this.tokenKind = TokenKind_1.TokenKind.BooleanAnd;
                }
                else if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // "&="
                    this.tokenKind = TokenKind_1.TokenKind.AndEqual;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Ampersand;
                }
                return this.state;
            case 42 /* Asterisk */:
                if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // "*="
                    this.tokenKind = TokenKind_1.TokenKind.MultiplyEqual;
                }
                else if (next === 42 /* Asterisk */) {
                    if (this.peek(this.offset + 2) === 61 /* Equal */) {
                        this.offset = this.offset + 3; // "**="
                        this.tokenKind = TokenKind_1.TokenKind.PowEqual;
                    }
                    else {
                        this.offset = this.offset + 2; // "**"
                        this.tokenKind = TokenKind_1.TokenKind.Pow;
                    }
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Asterisk;
                }
                return this.state;
            case 94 /* Caret */:
                if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // "^="
                    this.tokenKind = TokenKind_1.TokenKind.XorEqual;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Caret;
                }
                return this.state;
            case 58 /* Colon */:
                if (next === 58 /* Colon */) {
                    this.offset = this.offset + 2; // "::"
                    this.tokenKind = TokenKind_1.TokenKind.DoubleColon;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Colon;
                }
                return this.state;
            case 61 /* Equal */:
                if (next === 61 /* Equal */) {
                    if (this.peek(this.offset + 2) === 61 /* Equal */) {
                        this.offset = this.offset + 3; // "==="
                        this.tokenKind = TokenKind_1.TokenKind.IsIdentical;
                    }
                    else {
                        this.offset = this.offset + 2; // "=="
                        this.tokenKind = TokenKind_1.TokenKind.IsEqual;
                    }
                }
                else if (next === 62 /* GreaterThan */) {
                    this.offset = this.offset + 2; // "=>"
                    this.tokenKind = TokenKind_1.TokenKind.DoubleArrow;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Equal;
                }
                return this.state;
            case 33 /* Exclamation */:
                if (next === 61 /* Equal */) {
                    if (this.peek(this.offset + 2) === 61 /* Equal */) {
                        this.offset = this.offset + 3; // "!=="
                        this.tokenKind = TokenKind_1.TokenKind.IsNotIdentical;
                    }
                    else {
                        this.offset = this.offset + 2; // "!="
                        this.tokenKind = TokenKind_1.TokenKind.IsNotEqual;
                    }
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Exclamation;
                }
                return this.state;
            case 62 /* GreaterThan */:
                if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // ">="
                    this.tokenKind = TokenKind_1.TokenKind.IsGreaterThanOrEqual;
                }
                else if (next === 62 /* GreaterThan */) {
                    if (this.peek(this.offset + 2) === 61 /* Equal */) {
                        this.offset = this.offset + 3; // ">>="
                        this.tokenKind = TokenKind_1.TokenKind.ShiftRightEqual;
                    }
                    else {
                        this.offset = this.offset + 2; // ">>"
                        this.tokenKind = TokenKind_1.TokenKind.ShiftRight;
                    }
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.GreaterThan;
                }
                return this.state;
            case 60 /* LessThan */:
                if (next === 61 /* Equal */) {
                    if (this.peek(this.offset + 2) === 62 /* GreaterThan */) {
                        this.offset = this.offset + 3; // "<=>"
                        this.tokenKind = TokenKind_1.TokenKind.Spaceship;
                    }
                    else {
                        this.offset = this.offset + 2; // "<="
                        this.tokenKind = TokenKind_1.TokenKind.IsLessThanOrEqual;
                    }
                }
                else if (next === 62 /* GreaterThan */) {
                    this.offset = this.offset + 2; // "<>"
                    this.tokenKind = TokenKind_1.TokenKind.Inequality;
                }
                else if (next === 60 /* LessThan */) {
                    if (this.peek(this.offset + 2) === 60 /* LessThan */) {
                        this.tryScanHeredoc(this.interpolations);
                    }
                    else if (this.peek(this.offset + 2) === 61 /* Equal */) {
                        this.offset = this.offset + 3; // "<<="
                        this.tokenKind = TokenKind_1.TokenKind.ShiftLeftEqual;
                    }
                    else {
                        this.offset = this.offset + 2; // "<<"
                        this.tokenKind = TokenKind_1.TokenKind.ShiftLeft;
                    }
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.LessThan;
                }
                return this.state;
            case 45 /* Minus */:
                if (next === 62 /* GreaterThan */) {
                    this.offset = this.offset + 2; // "->"
                    this.tokenKind = TokenKind_1.TokenKind.ObjectOperator;
                }
                else if (next === 45 /* Minus */) {
                    this.offset = this.offset + 2; // "--"
                    this.tokenKind = TokenKind_1.TokenKind.Decrement;
                }
                else if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // "-="
                    this.tokenKind = TokenKind_1.TokenKind.MinusEqual;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Minus;
                }
                return this.state;
            case 40 /* OpenParen */:
                this.tryScanTypeCast();
                return this.state;
            case 37 /* Percent */:
                if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // "%="
                    this.tokenKind = TokenKind_1.TokenKind.ModEqual;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Percent;
                }
                return this.state;
            case 46 /* Period */:
                if (Character_1.CharacterInfo.isDigit(next)) {
                    this.scanNumber();
                    return this.state;
                }
                else if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // ".="
                    this.tokenKind = TokenKind_1.TokenKind.ConcatEqual;
                }
                else if (next === 46 /* Period */ && this.peek(this.offset + 2) === 46 /* Period */) {
                    this.offset = this.offset + 3; // "..."
                    this.tokenKind = TokenKind_1.TokenKind.Ellipsis;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Period;
                }
                return this.state;
            case 43 /* Plus */:
                if (next === 43 /* Plus */) {
                    this.offset = this.offset + 2; // "++"
                    this.tokenKind = TokenKind_1.TokenKind.Increment;
                }
                else if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // "+="
                    this.tokenKind = TokenKind_1.TokenKind.PlusEqual;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Plus;
                }
                return this.state;
            case 63 /* Question */:
                if (next === 62 /* GreaterThan */) {
                    this.offset = this.offset + 2; // "?>"
                    this.tokenKind = TokenKind_1.TokenKind.CloseTag;
                    return this.state = PhpLexerState_1.PhpLexerState.InHostLanguage;
                }
                else if (next === 63 /* Question */) {
                    if (this.peek(this.offset + 2) === 61 /* Equal */ && this.phpVersion >= PhpVersion_1.PhpVersion.PHP7_4) {
                        this.offset = this.offset + 3; // "??="
                        this.tokenKind = TokenKind_1.TokenKind.CoalesceEqual;
                    }
                    else {
                        this.offset = this.offset + 2; // "??"
                        this.tokenKind = TokenKind_1.TokenKind.Coalesce;
                    }
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.Question;
                }
                return this.state;
            case 124 /* VerticalBar */:
                if (next === 124 /* VerticalBar */) {
                    this.offset = this.offset + 2; // "||"
                    this.tokenKind = TokenKind_1.TokenKind.BooleanOr;
                }
                else if (next === 61 /* Equal */) {
                    this.offset = this.offset + 2; // "|="
                    this.tokenKind = TokenKind_1.TokenKind.OrEqual;
                }
                else {
                    this.offset++;
                    this.tokenKind = TokenKind_1.TokenKind.VerticalBar;
                }
                return this.state;
            // Numbers
            case 48 /* _0 */:
                this.scanNumberWithPrefix();
                return this.state;
            case 49 /* _1 */:
            case 50 /* _2 */:
            case 51 /* _3 */:
            case 52 /* _4 */:
            case 53 /* _5 */:
            case 54 /* _6 */:
            case 55 /* _7 */:
            case 56 /* _8 */:
            case 57 /* _9 */:
                this.scanNumber();
                return this.state;
            // Identifiers starting with extended characters.
            default:
                if (Character_1.CharacterInfo.isIdentifierStart(ch, this.phpVersion)) {
                    this.scanIdentifierOrKeyword();
                    return this.state;
                }
                this.addError(0, 1, ErrorCode_Generated_1.ErrorCode.ERR_UnexpectedCharacter, '0x' + ch.toString(16).toUpperCase(), this.text.substring(this.offset, 1));
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.Error;
                return this.state;
        }
    };
    /**
     * Tokenizes the regions within a string template that are not part of an
     * interpolation.
     */
    PhpLexer.prototype.lexString = function () {
        var ch = this.text.charCodeAt(this.offset);
        var next = this.peek(this.offset + 1);
        if (this.state === PhpLexerState_1.PhpLexerState.InDoubleQuote && ch === 34 /* DoubleQuote */) {
            this.offset++;
            this.tokenKind = TokenKind_1.TokenKind.DoubleQuote;
            return this.state;
        }
        else if (this.state === PhpLexerState_1.PhpLexerState.InShellCommand && ch === 96 /* BackQuote */) {
            this.offset++;
            this.tokenKind = TokenKind_1.TokenKind.BackQuote;
            return this.state;
        }
        switch (ch) {
            case 36 /* Dollar */:
                // NOTE: Variables embedded within the quote should be part of
                // `InScript` spans and are not valid tokens in this state.
                if (next === 123 /* OpenBrace */) {
                    this.offset = this.offset + 2; // "${"
                    this.tokenKind = TokenKind_1.TokenKind.DollarOpenBrace;
                }
                else {
                    this.offset++;
                    this.scanStringTemplateLiteral();
                    this.tokenKind = TokenKind_1.TokenKind.StringTemplateLiteral;
                }
                break;
            case 123 /* OpenBrace */:
                this.offset++;
                if (next === 36 /* Dollar */) {
                    this.tokenKind = TokenKind_1.TokenKind.OpenBrace;
                }
                else {
                    this.scanStringTemplateLiteral();
                    this.tokenKind = TokenKind_1.TokenKind.StringTemplateLiteral;
                }
                break;
            case 32 /* Space */:
            case 9 /* Tab */:
                if (this.state === PhpLexerState_1.PhpLexerState.LookingForHeredocIndent) {
                    this.state = PhpLexerState_1.PhpLexerState.InFlexibleHeredoc;
                    var length_1 = this.scanFlexdocIndent();
                    if (length_1 > 0) {
                        this.tokenKind = TokenKind_1.TokenKind.StringIndent;
                        break;
                    }
                }
                this.scanStringTemplateLiteral();
                this.tokenKind = TokenKind_1.TokenKind.StringTemplateLiteral;
                break;
            case 13 /* CarriageReturn */:
            case 10 /* LineFeed */:
                if (this.state === PhpLexerState_1.PhpLexerState.InFlexibleHeredoc || this.state === PhpLexerState_1.PhpLexerState.LookingForHeredocIndent) {
                    this.offset++;
                    while (Character_1.CharacterInfo.isLineBreak(this.text.charCodeAt(this.offset))) {
                        this.offset++;
                    }
                    this.tokenKind = TokenKind_1.TokenKind.StringLineBreak;
                    this.state = PhpLexerState_1.PhpLexerState.LookingForHeredocIndent;
                }
                else {
                    this.scanStringTemplateLiteral();
                    this.tokenKind = TokenKind_1.TokenKind.StringTemplateLiteral;
                }
                break;
            default:
                // @todo Assert that this length is greater than 0.
                this.scanStringTemplateLiteral();
                this.tokenKind = TokenKind_1.TokenKind.StringTemplateLiteral;
                break;
        }
        return this.state;
    };
    /**
     * Tokenizes an identifier found in a string template.
     *
     * This is slightly different than scanning outside of a string, because
     * keyword tokens are not permitted.
     */
    PhpLexer.prototype.lexVariableName = function () {
        // This state only returns a single token, and can only be reached after a
        // string template has already been found to have an identifier, so there
        // isn't anything to actually check.
        this.offset++;
        this.scanIdentifierPart();
        this.tokenKind = TokenKind_1.TokenKind.StringIdentifier;
        return this.state = PhpLexerState_1.PhpLexerState.InScript;
    };
    /**
     * Tokenizes an element access offset found in a string template.
     */
    PhpLexer.prototype.lexVariableOffset = function () {
        var ch = this.text.charCodeAt(this.offset);
        var next = this.peek(this.offset + 1);
        switch (ch) {
            // Numbers.
            case 48 /* _0 */:
                if (next === 120 /* x */ && Character_1.CharacterInfo.isHexDigit(this.peek(this.offset + 2))) {
                    this.offset = this.offset + 2;
                    this.scanHexDigits();
                    this.tokenKind = TokenKind_1.TokenKind.StringNumber;
                    break;
                }
                if (next === 98 /* b */ && Character_1.CharacterInfo.isBinDigit(this.peek(this.offset + 2))) {
                    this.offset = this.offset + 2;
                    this.scanBinDigits();
                    this.tokenKind = TokenKind_1.TokenKind.StringNumber;
                    break;
                }
            // Fall through.
            case 49 /* _1 */:
            case 50 /* _2 */:
            case 51 /* _3 */:
            case 52 /* _4 */:
            case 53 /* _5 */:
            case 54 /* _6 */:
            case 55 /* _7 */:
            case 56 /* _8 */:
            case 57 /* _9 */:
                this.scanNumberPart(Character_1.CharacterInfo.isDigit);
                this.tokenKind = TokenKind_1.TokenKind.StringNumber;
                break;
            // Punctuation.
            case 93 /* CloseBracket */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.CloseBracket;
                break;
            case 36 /* Dollar */:
                // In this state, only a variable is valid.
                this.offset = this.offset + 2;
                this.scanIdentifierPart();
                this.tokenKind = TokenKind_1.TokenKind.Variable;
                break;
            case 45 /* Minus */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.Minus;
                break;
            case 91 /* OpenBracket */:
                this.offset++;
                this.tokenKind = TokenKind_1.TokenKind.OpenBracket;
                break;
            // Identifiers.
            default:
                // Debug.assert(CharacterInfo.isIdentifierStart(ch, this.phpVersion));
                this.offset++;
                this.scanIdentifierPart();
                this.tokenKind = TokenKind_1.TokenKind.Identifier;
                break;
        }
        return this.state;
    };
    /**
     * Scans the digits of a binary integer.
     */
    PhpLexer.prototype.scanBinDigits = function () {
        var start = this.offset;
        // Skip leading zeroes.
        this.scanNumberPart(function (ch) { return ch === 48 /* _0 */; });
        // Allow a numeric separator between the zeros and trailing digits.
        if (this.offset - start > 0 && this.phpVersion >= PhpVersion_1.PhpVersion.PHP7_4) {
            if (this.peek(this.offset) === 95 /* Underscore */ && Character_1.CharacterInfo.isBinDigit(this.peek(this.offset + 1))) {
                this.offset++;
            }
        }
        // Significant digits.
        var part = this.scanNumberPart(Character_1.CharacterInfo.isBinDigit);
        this.tokenKind = part[0] - part[1] < this.ptrSize * 8 ? TokenKind_1.TokenKind.LNumber : TokenKind_1.TokenKind.DNumber;
        return this.offset - start;
    };
    /**
     * Scans for the indent in a flexible heredoc.
     */
    PhpLexer.prototype.scanFlexdocIndent = function () {
        var start = this.offset;
        var hasMismatchedIndentation = false;
        for (var i = 0; i < this.flexibleIndent.length; i++) {
            if (this.offset >= this.end) {
                throw new php_common_1.Exception('Missing end label'); // Unreachable.
            }
            var ch = this.text.charCodeAt(this.offset);
            if (ch !== this.flexibleIndent.charCodeAt(i)) {
                if (Character_1.CharacterInfo.isLineBreak(ch)) {
                    // Found an empty line.
                    break;
                }
                else {
                    // Either this is a space instead of a tab, a tab instead of a space,
                    // or some other non-whitespace character. In the first two cases,
                    // continue scanning the indent in order to prevent "indent expected"
                    // errors when there is clearly whitespace present.
                    hasMismatchedIndentation = true;
                    // Found a line without enough indentation.
                    if (!Character_1.CharacterInfo.isWhitespace(ch)) {
                        break;
                    }
                }
            }
            this.offset++;
        }
        if (hasMismatchedIndentation && this.offset - start > 0) {
            this.addError(0, this.offset - start, ErrorCode_Generated_1.ErrorCode.ERR_HeredocIndentMismatch);
        }
        return this.offset - start;
    };
    /**
     * Scans the indentation of the end label in a flexdoc template.
     */
    PhpLexer.prototype.scanHeredocEndLabelIndent = function () {
        var start = this.offset;
        var hasSpaces = false;
        var hasTabs = false;
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            if (ch === 32 /* Space */) {
                hasSpaces = true;
            }
            else if (ch === 9 /* Tab */) {
                hasTabs = true;
            }
            else {
                break;
            }
            this.offset++;
        }
        if (hasSpaces && hasTabs) {
            this.addError(0, this.offset - start, ErrorCode_Generated_1.ErrorCode.ERR_HeredocIndentHasSpacesAndTabs);
        }
        return this.offset - start;
    };
    /**
     * Scans the digits of a hexadecimal integer.
     */
    PhpLexer.prototype.scanHexDigits = function () {
        var start = this.offset;
        // Skip leading zeroes.
        this.scanNumberPart(function (ch) { return ch === 48 /* _0 */; });
        // Allow a numeric separator between the zeros and trailing digits.
        if (this.offset - start > 0 && this.phpVersion >= PhpVersion_1.PhpVersion.PHP7_4) {
            if (this.peek(this.offset) === 95 /* Underscore */ && Character_1.CharacterInfo.isHexDigit(this.peek(this.offset + 1))) {
                this.offset++;
            }
        }
        // Significant digits.
        var digitStart = this.offset;
        var part = this.scanNumberPart(Character_1.CharacterInfo.isHexDigit);
        var digitLength = part[0] - part[1];
        if (digitLength < this.ptrSize * 2 || (digitLength === this.ptrSize * 2 && this.peek(digitStart) <= 55 /* _7 */)) {
            this.tokenKind = TokenKind_1.TokenKind.LNumber;
        }
        else {
            this.tokenKind = TokenKind_1.TokenKind.DNumber;
        }
        return this.offset - start;
    };
    /**
     * Scans an identifier and determines if it is a keyword.
     */
    PhpLexer.prototype.scanIdentifierOrKeyword = function () {
        var start = this.offset;
        var hasUnderscore = this.text.charCodeAt(this.offset) === 95 /* Underscore */;
        this.offset++;
        // Equivalent to scanIdentifierPart() but keeps track of underscores.
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            if (!Character_1.CharacterInfo.isIdentifierPart(ch, this.phpVersion)) {
                break;
            }
            if (ch === 95 /* Underscore */) {
                hasUnderscore = true;
            }
            this.offset++;
        }
        // If the identifier is too long, then it's not a keyword.
        if ((!hasUnderscore && this.offset - start > 10) || (hasUnderscore && this.offset - start > 15)) {
            this.tokenKind = TokenKind_1.TokenKind.Identifier;
        }
        else {
            this.tokenKind = this.textToIdentifierToken();
        }
        // Ideally "yield from" would only be valid with a single space, but
        // someone decided to make it a special snowflake...
        if (this.tokenKind === TokenKind_1.TokenKind.Yield && Character_1.CharacterInfo.isWhitespaceLike(this.peek(this.offset))) {
            var yieldEnd = this.offset;
            while (this.offset < this.end) {
                var ch = this.text.charCodeAt(this.offset);
                if (!Character_1.CharacterInfo.isWhitespaceLike(ch)) {
                    break;
                }
                this.offset++;
            }
            if (this.startsWith('from') && !Character_1.CharacterInfo.isIdentifierPart(this.peek(this.offset + 4), this.phpVersion)) {
                this.offset = this.offset + 4;
                this.tokenKind = TokenKind_1.TokenKind.YieldFrom;
            }
            else {
                this.offset = yieldEnd;
            }
        }
        return this.offset - start;
    };
    /**
     * Scans for additional characters that may be part of an identifer name.
     */
    PhpLexer.prototype.scanIdentifierPart = function () {
        var start = this.offset;
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            if (!Character_1.CharacterInfo.isIdentifierPart(ch, this.phpVersion)) {
                break;
            }
            this.offset++;
        }
        return this.offset - start;
    };
    /**
     * Scans inline text within an interpolated string.
     */
    PhpLexer.prototype.scanInterpolatedInlineText = function () {
        var start = this.offset;
        while (this.offset < this.end) {
            if (this.tryScanOpenTag()) {
                break;
            }
            this.offset++;
        }
        return this.offset - start;
    };
    /**
     * Scans any PHP script within an interpolated string.
     */
    PhpLexer.prototype.scanInterpolatedScript = function (delimiter) {
        var start = this.offset;
        // In order to find the closing terminator of an interpolated string, the
        // embedded script must end. That is done by close braces and close tags,
        // but it is not as simple as scanning for those tokens because while in a
        // script the following conditions apply:
        // 1. Open braces and interpolated strings may create additional embedded
        //    lexing states which must end before returning to the original string.
        //    This is handled by recursively calling the relevant scanning methods.
        // 2. User-defined tokens may contain the characters being searched for. The
        //    possible tokens, constant strings and comments, are handled by simply
        //    scanning them normally when they are found.
        // 3. Close tags always start the host language state, which may in turn
        //    restart the script state, resulting in a loop.
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            switch (ch) {
                // Delimiters.
                case 125 /* CloseBrace */:
                case 93 /* CloseBracket */:
                case 41 /* CloseParen */:
                    this.offset++;
                    if (ch === delimiter) {
                        return this.offset - start;
                    }
                    break;
                case 123 /* OpenBrace */:
                    this.offset++; // "{"
                    this.scanInterpolatedScript(125 /* CloseBrace */);
                    break;
                case 91 /* OpenBracket */:
                    this.offset++; // "["
                    // @todo Experimental.
                    // this.scanInterpolatedScript(Character.CloseBracket);
                    break;
                case 40 /* OpenParen */:
                    this.offset++; // "("
                    // @todo Experimental.
                    // this.scanInterpolatedScript(Character.CloseParen);
                    break;
                // Strings.
                case 96 /* BackQuote */:
                    this.offset++;
                    this.scanInterpolatedString(96 /* BackQuote */);
                    if (this.peek(this.offset) === 96 /* BackQuote */) {
                        this.offset++;
                    }
                    break;
                case 34 /* DoubleQuote */:
                    this.offset++;
                    this.scanInterpolatedString(34 /* DoubleQuote */);
                    if (this.peek(this.offset) === 34 /* DoubleQuote */) {
                        this.offset++;
                    }
                    break;
                case 60 /* LessThan */:
                    if (this.peek(this.offset + 1) === 60 /* LessThan */ && this.peek(this.offset + 2) === 60 /* LessThan */) {
                        var info = this.tryScanHeredocStartLabel();
                        if (info) {
                            this.scanInterpolatedString(info.label);
                            if (this.isHeredocEnd(info.label)) {
                                this.scanWhitespace();
                                this.offset = this.offset + info.label.length;
                            }
                            break;
                        }
                    }
                    this.offset++;
                    break;
                case 39 /* SingleQuote */:
                    this.offset++;
                    this.scanSingleQuoteString();
                    if (this.peek(this.offset) === 39 /* SingleQuote */) {
                        this.offset++;
                    }
                    break;
                // Comments.
                case 35 /* Hash */:
                    this.offset++;
                    this.scanLineComment();
                    break;
                case 47 /* Slash */:
                    if (this.peek(this.offset + 1) === 47 /* Slash */) {
                        this.offset = this.offset + 2; // "//"
                        this.scanLineComment();
                    }
                    else if (this.peek(this.offset + 1) === 42 /* Asterisk */) {
                        this.offset = this.offset + 2; // "/*"
                        this.scanMultipleLineComment();
                        if (this.peek(this.offset) === 42 /* Asterisk */ && this.peek(this.offset + 1) === 47 /* Slash */) {
                            this.offset = this.offset + 2; // "*/"
                        }
                    }
                    else {
                        this.offset++;
                    }
                    break;
                // Close tag.
                case 63 /* Question */:
                    if (this.peek(this.offset + 1) === 62 /* GreaterThan */) {
                        this.offset = this.offset + 2; // "?>"
                        // Inline text only terminates at the end of the file or at an open
                        // tag. In the first case, this loop will terminate as well, and in
                        // the second case, just resume scanning the script normally.
                        this.scanInterpolatedInlineText();
                    }
                    else {
                        this.offset++; // "?"
                    }
                    break;
                // Embedded code.
                default:
                    this.offset++;
                    break;
            }
        }
        return this.offset - start;
    };
    /**
     * Scans the contents of a possible interpolated string.
     *
     * @param {Character|string} delimiter
     *   A closing quote or label used to delimit a heredoc or nowdoc string.
     * @param {TemplateSpan[]=} spans
     *   An array to store any scanned interpolations within the string.
     * @param {number=} startLength
     *   The length of the string's starting token. For heredoc and nowdoc
     *   strings this length includes the '<<<' operator, whitespace, and
     *   optional quotation marks. For other strings, this is simply the length
     *   of the quote character.
     *
     * @return {number}
     *   The length of the interpolated string (not including the string
     *   terminator).
     *
     * State transitions for interpolated strings:
     *
     * InDoubleQuote
     * Input        Token              Transition
     * "$LABEL"     T_VARIABLE         Continue
     * "$LABEL["    T_VARIABLE         Start InVariableOffset
     * "$LABEL->*"  T_VARIABLE         Start LookingForProperty
     * "${"         T_DOLLAR_OPEN_...  Start LookingForVariableName
     * "{$"         "{"                Start InScript
     * "\""         "\""               End current state
     * "ANY"        T_ENCAPSED_AND...  Continue
     *
     * LookingForVariableName
     * Input        Token              Transition
     * "LABEL["     T_STRING_VARNAME   End current state, Start InScript
     * "LABEL}"     T_STRING_VARNAME   End current state, Start InScript
     * "ANY"        ---                End current state, Start Inscript
     *
     * LookingForProperty
     * Input        Token              Transition
     * "\s"         T_WHITESPACE       Continue
     * "->"         T_OBJECT_OPERATOR  Continue
     * "LABEL"      T_STRING           End current state
     * "ANY"        ---                End current state
     *
     * InVariableOffset
     * Input        Token              Transition         Remarks
     * "\d"         T_NUM_STRING       Continue           Also includes 0x and 0b numbers.
     * "LABEL"      T_STRING           Continue
     * "$LABEL"     T_VARIABLE         Continue
     * "TOKEN"      "TOKEN"            Continue           Also includes '{', '}', '"', '`'.
     * "]"          "]"                End current state
     * "\s"         T_ENCAPSED_AND...  End current state  Also includes '\\', '\'', and '#'.
     * "ANY"        ---                Throw
     */
    PhpLexer.prototype.scanInterpolatedString = function (delimiter, spans, startLength) {
        if (spans === void 0) { spans = []; }
        var start = this.offset;
        var tokenOffset = start - (startLength ? startLength : 1);
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            var next = this.peek(this.offset + 1);
            var spanOffset = void 0;
            switch (ch) {
                case 96 /* BackQuote */:
                    if (delimiter === 96 /* BackQuote */) {
                        return this.offset - start;
                    }
                    this.offset++;
                    break;
                case 92 /* Backslash */:
                    // Escape sequence.
                    this.offset++;
                    if (Character_1.CharacterInfo.isDoubleQuoteEscape(next)) {
                        this.offset++;
                    }
                    else if (next === 117 /* u */) {
                        this.offset++;
                        this.scanUnicodeEscape();
                    }
                    else {
                        this.scanOctalEscape();
                    }
                    break;
                case 36 /* Dollar */:
                    if (next === 123 /* OpenBrace */) {
                        this.offset = this.offset + 2; // "${"
                        spanOffset = this.offset;
                        if (this.tryScanInterpolatedVariableName()) {
                            spans.push(new TemplateSpan_1.TemplateSpan(PhpLexerState_1.PhpLexerState.LookingForVariableName, spanOffset - tokenOffset, this.offset - spanOffset));
                            spanOffset = this.offset;
                        }
                        this.scanInterpolatedScript(125 /* CloseBrace */);
                        spans.push(new TemplateSpan_1.TemplateSpan(PhpLexerState_1.PhpLexerState.InScript, spanOffset - tokenOffset, this.offset - spanOffset));
                    }
                    else if (Character_1.CharacterInfo.isIdentifierStart(next, this.phpVersion)) {
                        spanOffset = this.offset;
                        this.offset = this.offset + 2; // "$a"
                        this.scanIdentifierPart();
                        if (this.startsWithObjectProperty()) {
                            this.offset = this.offset + 3;
                            this.scanIdentifierPart();
                            spans.push(new TemplateSpan_1.TemplateSpan(PhpLexerState_1.PhpLexerState.InScript, spanOffset - tokenOffset, this.offset - spanOffset));
                        }
                        else if (this.peek(this.offset) === 91 /* OpenBracket */) {
                            // Since simple variables need a span anyways, adding one here as
                            // well means that no additional logic is required to rescan
                            // variables in a template.
                            spans.push(new TemplateSpan_1.TemplateSpan(PhpLexerState_1.PhpLexerState.InScript, spanOffset - tokenOffset, this.offset - spanOffset));
                            spanOffset = this.offset;
                            this.scanInterpolatedVariableOffset(); // "$a["
                            spans.push(new TemplateSpan_1.TemplateSpan(PhpLexerState_1.PhpLexerState.InVariableOffset, spanOffset - tokenOffset, this.offset - spanOffset));
                        }
                        else {
                            // Normally, variables would be tokenized without leaving the
                            // `InDoubleQuote` state, however while tokenizing a script, a span
                            // needs to be added in order to let the caller know that this is
                            // not a constant string (i.e. a `StringLiteral`).
                            spans.push(new TemplateSpan_1.TemplateSpan(PhpLexerState_1.PhpLexerState.InScript, spanOffset - tokenOffset, this.offset - spanOffset));
                        }
                    }
                    else {
                        this.offset++; // "$"
                    }
                    break;
                case 34 /* DoubleQuote */:
                    if (delimiter === 34 /* DoubleQuote */) {
                        return this.offset - start;
                    }
                    this.offset++;
                    break;
                case 123 /* OpenBrace */:
                    this.offset++; // "{"
                    if (next === 36 /* Dollar */) {
                        spanOffset = this.offset;
                        this.scanInterpolatedScript(125 /* CloseBrace */);
                        spans.push(new TemplateSpan_1.TemplateSpan(PhpLexerState_1.PhpLexerState.InScript, spanOffset - tokenOffset, this.offset - spanOffset));
                    }
                    break;
                case 13 /* CarriageReturn */:
                    if (next === 10 /* LineFeed */) {
                        this.offset++;
                    }
                // Fall through.
                case 10 /* LineFeed */:
                    this.offset++;
                    if (typeof delimiter === 'string' && this.isHeredocEnd(delimiter)) {
                        return this.offset - start;
                    }
                    break;
                default:
                    this.offset++;
                    break;
            }
        }
        return this.offset - start;
    };
    /**
     * Scans the offset of an interpolated variable.
     *
     * Unlike PHP's implementation which also attempts to lex a variety of
     * invalid tokens, this method only scans for a sequence of characters that
     * result in a valid production. This has several benefits:
     *
     * - The lexer doesn't have to try and tokenize a bunch of garbage.
     * - Invalid characters don't become uncacheable skipped tokens, which
     *   results in a faster parse and fewer objects being created.
     * - The lexer can immediately go back to scanning the string, which makes it
     *   much more likely to produce the desired tokens (PHP doesn't even try to
     *   recover gracefully).
     */
    PhpLexer.prototype.scanInterpolatedVariableOffset = function () {
        var start = this.offset;
        this.offset++; // "["
        var ch = this.peek(this.offset);
        var next = this.peek(this.offset + 1);
        if (ch === 45 /* Minus */ || Character_1.CharacterInfo.isDigit(ch)) {
            if (ch === 45 /* Minus */) {
                this.offset++; // "-"
            }
            switch (this.peek(this.offset)) {
                case 48 /* _0 */:
                    if (this.peek(this.offset + 1) === 120 /* x */ && Character_1.CharacterInfo.isHexDigit(this.peek(this.offset + 2))) {
                        this.offset = this.offset + 2;
                        this.scanHexDigits();
                        break;
                    }
                    else if (this.peek(this.offset + 1) === 98 /* b */ && Character_1.CharacterInfo.isBinDigit(this.peek(this.offset + 2))) {
                        this.offset = this.offset + 2;
                        this.scanBinDigits();
                        break;
                    }
                // Fall through.
                case 49 /* _1 */:
                case 50 /* _2 */:
                case 51 /* _3 */:
                case 52 /* _4 */:
                case 53 /* _5 */:
                case 54 /* _6 */:
                case 55 /* _7 */:
                case 56 /* _8 */:
                case 57 /* _9 */:
                    // Only integers are allowed, so only do the first part of scanNumber().
                    this.scanNumberPart(Character_1.CharacterInfo.isDigit);
                    break;
            }
        }
        else if (ch === 36 /* Dollar */) {
            if (Character_1.CharacterInfo.isIdentifierStart(next)) {
                this.offset = this.offset + 2;
                this.scanIdentifierPart();
            }
        }
        else if (Character_1.CharacterInfo.isIdentifierStart(ch)) {
            this.offset++;
            this.scanIdentifierPart();
        }
        if (this.peek(this.offset) === 93 /* CloseBracket */) {
            this.offset++;
        }
        return this.offset - start;
    };
    /**
     * Scans the remaining portion of a line comment until a line break or close
     * tag is found.
     */
    PhpLexer.prototype.scanLineComment = function ( /* ignoreCloseTag = false */) {
        var commentStart = this.offset;
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
                break;
            }
            if (ch === 63 /* Question */ && this.peek(this.offset + 1) === 62 /* GreaterThan */) {
                break;
            }
            this.offset++;
        }
        return this.offset - commentStart;
    };
    /**
     * Scans the remaining portion of a multiple-line comment.
     */
    PhpLexer.prototype.scanMultipleLineComment = function () {
        var commentStart = this.offset;
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            if (ch === 42 /* Asterisk */ && this.peek(this.offset + 1) === 47 /* Slash */) {
                break;
            }
            this.offset++;
        }
        return this.offset - commentStart;
    };
    /**
     * Scans the remaining portion of a nowdoc until the end label is found.
     */
    PhpLexer.prototype.scanNowdoc = function (label) {
        var start = this.offset;
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            switch (ch) {
                case 13 /* CarriageReturn */:
                    if (this.peek(this.offset + 1) === 10 /* LineFeed */) {
                        this.offset++;
                    }
                // Fall through.
                case 10 /* LineFeed */:
                    this.offset++;
                    if (this.isHeredocEnd(label)) {
                        return this.offset - start;
                    }
                    break;
                default:
                    this.offset++;
                    break;
            }
        }
        return this.offset - start;
    };
    /**
     * Scans for constant text within a nowdoc string.
     */
    PhpLexer.prototype.scanNowdocString = function () {
        var start = this.offset;
        while (this.offset < this.end) {
            if (Character_1.CharacterInfo.isLineBreak(this.text.charCodeAt(this.offset))) {
                break;
            }
            this.offset++;
        }
        return this.offset - start;
    };
    /**
     * Scans a decimal integer or floating-point number.
     *
     * A long consists of:
     * - One or more digits.
     *
     * A double consists of:
     * - Zero or more digits followed by a decimal point and one or more digits.
     * - One or more digits followed by a decimal point and zero or more digits.
     *
     * A double with exponent consists of:
     * - A long or double followed by 'e' or 'E', then an optional '+' or '-', and
     *   finally a long.
     */
    PhpLexer.prototype.scanNumber = function () {
        var start = this.offset;
        // Integer part.
        this.scanNumberPart(Character_1.CharacterInfo.isDigit);
        // Fractional part.
        var isDouble = false;
        if (this.peek(this.offset) === 46 /* Period */) {
            isDouble = true;
            this.offset++;
            this.scanNumberPart(Character_1.CharacterInfo.isDigit);
        }
        var exponentStart = this.offset;
        var ch = this.peek(this.offset);
        if (ch === 101 /* e */ || ch === 69 /* E */) {
            this.offset++;
            ch = this.peek(this.offset);
            if (ch === 45 /* Minus */ || ch === 43 /* Plus */) {
                this.offset++;
            }
            ch = this.peek(this.offset);
            if (Character_1.CharacterInfo.isDigit(ch)) {
                isDouble = true;
                this.scanNumberPart(Character_1.CharacterInfo.isDigit);
            }
            else {
                // Found 'e' but no number.
                this.offset = exponentStart;
            }
        }
        this.tokenKind = isDouble ? TokenKind_1.TokenKind.DNumber : TokenKind_1.TokenKind.LNumber;
        return this.offset - start;
    };
    /**
     * Scans for the digits of a number.
     *
     * @param {(ch: number) => boolean} predicate
     *   A callback used to determine what characters are valid digits in the
     *   number.
     *
     * @returns A tuple containing the total length of the scanned digits, and
     *   how many separators were present.
     */
    PhpLexer.prototype.scanNumberPart = function (predicate) {
        var start = this.offset;
        while (this.offset < this.end && predicate(this.text.charCodeAt(this.offset))) {
            this.offset++;
        }
        var separatorCount = 0;
        if (this.offset - start > 0 && this.phpVersion >= PhpVersion_1.PhpVersion.PHP7_4) {
            while (this.peek(this.offset) === 95 /* Underscore */ && predicate(this.peek(this.offset + 1))) {
                this.offset++; // "_"
                separatorCount++;
                while (this.offset < this.end && predicate(this.text.charCodeAt(this.offset))) {
                    this.offset++;
                }
            }
        }
        return [this.offset - start, separatorCount];
    };
    /**
     * Scans a hexadecimal or binary number. If not found, a decimal
     * or octal number is scanned instead.
     */
    PhpLexer.prototype.scanNumberWithPrefix = function () {
        var start = this.offset;
        var length = 0;
        if (this.peek(this.offset + 1) === 120 /* x */) {
            this.offset = this.offset + 2; // "0x"
            length = this.scanHexDigits();
        }
        else if (this.peek(this.offset + 1) === 98 /* b */) {
            this.offset = this.offset + 2; // "0b"
            length = this.scanBinDigits();
        }
        else {
            return this.scanNumber();
        }
        if (length === 0) {
            // There are no productions where a number can be followed by an identifier.
            //
            // It is also much more likely that the user intends on adding digits after
            // a valid prefix, instead of deleting the letter or going back and adding
            // some other token inbetween the two characters:
            //
            //   if ($x == 0x) {
            //             ~~     // Error: Invalid numeric literal.
            //
            // Normally, the above example would generate two tokens, but leaving it as
            // a single token results in the same error and less work for the parser.
            this.addError(0, 2, ErrorCode_Generated_1.ErrorCode.ERR_InvalidNumber);
            this.tokenKind = TokenKind_1.TokenKind.LNumber;
        }
        return this.offset - start;
    };
    /**
     * Scans for an octal escape sequence.
     */
    PhpLexer.prototype.scanOctalEscape = function () {
        var start = this.offset;
        var firstDigit = this.peek(this.offset);
        if (!Character_1.CharacterInfo.isOctDigit(firstDigit)) {
            return 0;
        }
        this.offset++;
        var i = 0;
        while (this.offset < this.end && i < 2) {
            var ch = this.text.charCodeAt(this.offset);
            if (!Character_1.CharacterInfo.isOctDigit(ch)) {
                return this.offset - start;
            }
            // Max: 255 = 0xFF = \377
            if (i === 1 && firstDigit > 51 /* _3 */) {
                this.addError(start - this.tokenStart - 1, i + 3, ErrorCode_Generated_1.ErrorCode.WRN_OctalEscapeSequenceOverflow);
            }
            this.offset++;
            i++;
        }
        return this.offset - start;
    };
    /**
     * Scans the contents of a constant string.
     */
    PhpLexer.prototype.scanSingleQuoteString = function () {
        var start = this.offset;
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            if (ch === 39 /* SingleQuote */) {
                break;
            }
            else if (ch === 92 /* Backslash */ && this.offset + 1 < this.end) {
                this.offset = this.offset + 2;
            }
            else {
                this.offset++;
            }
        }
        return this.offset - start;
    };
    /**
     * Scans for constant text within a string template.
     */
    PhpLexer.prototype.scanStringTemplateLiteral = function () {
        var start = this.offset;
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            var next = this.peek(this.offset + 1);
            // String terminators.
            if (this.state === PhpLexerState_1.PhpLexerState.InDoubleQuote && ch === 34 /* DoubleQuote */) {
                break;
            }
            else if (this.state === PhpLexerState_1.PhpLexerState.InShellCommand && ch === 96 /* BackQuote */) {
                break;
            }
            // End of constant text.
            if (ch === 36 /* Dollar */ && (next === 123 /* OpenBrace */ || Character_1.CharacterInfo.isIdentifierStart(next, this.phpVersion))) {
                break;
            }
            else if (ch === 123 /* OpenBrace */ && next === 36 /* Dollar */) {
                break;
            }
            else if ((this.state === PhpLexerState_1.PhpLexerState.InFlexibleHeredoc || this.state === PhpLexerState_1.PhpLexerState.LookingForHeredocIndent) && Character_1.CharacterInfo.isLineBreak(ch)) {
                break;
            }
            if (ch === 92 /* Backslash */ && Character_1.CharacterInfo.isDoubleQuoteEscape(next)) {
                this.offset++;
            }
            this.offset++;
        }
        return this.offset - start;
    };
    /**
     * Scans for a unicode escape sequence.
     */
    PhpLexer.prototype.scanUnicodeEscape = function () {
        var start = this.offset;
        var ch = this.peek(this.offset);
        // JSON-serialized strings are silently ignored since they may contain
        // unicode escape sequences that do not follow the PHP format.
        if (ch !== 123 /* OpenBrace */) {
            return 0;
        }
        this.offset++; // "{"
        while (this.offset < this.end) {
            ch = this.text.charCodeAt(this.offset);
            if (ch === 125 /* CloseBrace */) {
                break;
            }
            if (!Character_1.CharacterInfo.isHexDigit(ch)) {
                this.addError(start - this.tokenStart - 2, this.offset - start + 2, ErrorCode_Generated_1.ErrorCode.ERR_UnterminatedUnicodeEscapeSequence);
                return this.offset - start;
            }
            this.offset++;
        }
        // A unicode escape sequence cannot be empty.
        var length = this.offset - start - 1;
        if (length === 0) {
            this.addError(start - this.tokenStart - 2, 4, ErrorCode_Generated_1.ErrorCode.ERR_InvalidEscapeSequenceUnicode);
            return this.offset - start;
        }
        if (Number.parseInt(this.text.substring(start + 1, length), 16) > 0x10FFFF) {
            this.addError(start - this.tokenStart - 2, length + 4, ErrorCode_Generated_1.ErrorCode.ERR_UnicodeEscapeSequenceOverflow);
        }
        return this.offset - start;
    };
    /**
     * Scans any remaining whitespace characters.
     */
    PhpLexer.prototype.scanWhitespace = function () {
        var start = this.offset;
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            if (!Character_1.CharacterInfo.isWhitespace(ch)) {
                break;
            }
            this.offset++;
        }
        return this.offset - start;
    };
    /**
     * Determines if an object operator and property name are present at the
     * scanner's current location.
     */
    PhpLexer.prototype.startsWithObjectProperty = function () {
        if (this.offset + 3 > this.end) {
            return false;
        }
        return this.text.charCodeAt(this.offset) === 45 /* Minus */ &&
            this.text.charCodeAt(this.offset + 1) === 62 /* GreaterThan */ &&
            Character_1.CharacterInfo.isIdentifierStart(this.text.charCodeAt(this.offset + 2), this.phpVersion);
    };
    /**
     * Returns a keyword or identifier token for the scanned text.
     */
    PhpLexer.prototype.textToIdentifierToken = function () {
        var tokenText = this.text.substring(this.tokenStart, this.offset - this.tokenStart).toLowerCase();
        var keyword = PhpLexer.KeywordTokens.get(tokenText);
        if (keyword !== undefined) {
            // Backward compatibility: Am I a joke to you?
            if (tokenText === 'fn' && this.phpVersion < PhpVersion_1.PhpVersion.PHP7_4) {
                return TokenKind_1.TokenKind.Identifier;
            }
            return keyword;
        }
        return TokenKind_1.TokenKind.Identifier;
    };
    /**
     * Attempts to scan for a heredoc or nowdoc string. If not found, a left
     * shift token is scanned instead.
     */
    PhpLexer.prototype.tryScanHeredoc = function (spans) {
        var start = this.offset;
        var info = this.tryScanHeredocStartLabel();
        if (info !== null) {
            spans.length = 0; // Need to modify the existing array.
            // The starting label consumes a trailing new line, so for an empty
            // string, the search for an ending label would never be triggered.
            if (this.isHeredocEnd(info.label)) {
                this.tokenKind = Character_1.CharacterInfo.isWhitespace(this.text.charCodeAt(this.offset))
                    ? TokenKind_1.TokenKind.FlexdocTemplate : TokenKind_1.TokenKind.HeredocTemplate;
                var labelStart = this.offset - start;
                var indentLength = this.scanWhitespace();
                this.offset = this.offset + info.label.length;
                spans.push(new TemplateSpan_1.TemplateSpan(PhpLexerState_1.PhpLexerState.LookingForHeredocLabel, labelStart, indentLength + info.label.length));
                return this.offset - start;
            }
            if (info.isNowdoc) {
                this.scanNowdoc(info.label);
            }
            else {
                this.scanInterpolatedString(info.label, spans, info.fullLength);
            }
            if (this.isHeredocEnd(info.label)) {
                this.tokenKind = Character_1.CharacterInfo.isWhitespace(this.text.charCodeAt(this.offset))
                    ? TokenKind_1.TokenKind.FlexdocTemplate : TokenKind_1.TokenKind.HeredocTemplate;
                var labelStart = this.offset - start;
                var indentLength = this.scanWhitespace();
                this.offset = this.offset + info.label.length;
                spans.push(new TemplateSpan_1.TemplateSpan(PhpLexerState_1.PhpLexerState.LookingForHeredocLabel, labelStart, indentLength + info.label.length));
            }
            else {
                this.addError(0, this.offset - start, info.isNowdoc ? ErrorCode_Generated_1.ErrorCode.ERR_UnterminatedStringConstant : ErrorCode_Generated_1.ErrorCode.ERR_UnterminatedString);
                this.tokenKind = TokenKind_1.TokenKind.HeredocTemplate;
            }
        }
        else {
            // Starting label not found.
            this.offset = this.offset + 2;
            this.tokenKind = TokenKind_1.TokenKind.ShiftLeft;
        }
        return this.offset - start;
    };
    /**
     * Attempts to scan for a variable name in a string template that uses "${}"
     * syntax to explicity specify the name. If not found, nothing is scanned.
     */
    PhpLexer.prototype.tryScanInterpolatedVariableName = function () {
        var start = this.offset;
        var ch = this.peek(this.offset);
        if (Character_1.CharacterInfo.isIdentifierStart(ch, this.phpVersion)) {
            this.offset++;
            this.scanIdentifierPart();
            ch = this.peek(this.offset);
            if (ch === 91 /* OpenBracket */ || ch === 125 /* CloseBrace */) {
                return this.offset - start;
            }
        }
        this.offset = start;
        return 0;
    };
    /**
     * Attempts to scan for a PHP script opening tag. If not found, nothing is
     * scanned.
     */
    PhpLexer.prototype.tryScanOpenTag = function () {
        var start = this.offset;
        if (this.peek(this.offset) === 60 /* LessThan */) {
            if (this.peek(this.offset + 1) === 63 /* Question */) {
                this.offset = this.offset + 2; // "<?"
                if (this.peek(this.offset) === 61 /* Equal */) {
                    this.offset++;
                }
                else if (this.allowShortOpen) {
                    // Nothing to do except take precedence over the full open tag. This
                    // is technically a bug in PHP since the lexer should be greedy.
                }
                else if (this.startsWith('php')) {
                    if (Character_1.CharacterInfo.isWhitespaceLike(this.peek(this.offset + 3))) {
                        this.offset = this.offset + 3;
                    }
                    else if (this.offset + 3 === this.end && this.phpVersion >= PhpVersion_1.PhpVersion.PHP7_4) {
                        this.offset = this.offset + 3;
                    }
                    else {
                        // Partial match, not an open tag.
                        this.offset = start;
                    }
                }
                else {
                    this.offset = start;
                }
            }
        }
        return this.offset - start;
    };
    /**
     * Attempts to scan a full type cast token. If not found, only the opening
     * parenthesis is scanned instead.
     *
     * @todo Disabled optimization: Unsupported phi use of const or let variable.
     */
    PhpLexer.prototype.tryScanTypeCast = function () {
        var castStart = this.offset;
        this.offset++;
        this.scanWhitespace();
        var typeStart = this.offset;
        while (this.offset < this.end) {
            var ch = this.text.charCodeAt(this.offset);
            if ((ch >= 97 /* a */ && ch <= 122 /* z */) || (ch >= 65 /* A */ && ch <= 90 /* Z */)) {
                this.offset++;
            }
            else {
                break;
            }
            // Max length of a cast is 7 (tied between 'boolean' and 'integer'), save
            // time and end early if there are too many characters.
            if (this.offset - typeStart === 8) {
                this.offset = castStart + 1;
                this.tokenKind = TokenKind_1.TokenKind.OpenParen;
                return 1;
            }
        }
        // Cast types are between 3 and 7 characters inclusive.
        var length = this.offset - typeStart;
        if (length >= 3) {
            this.scanWhitespace();
            // It's still not a cast until we get a closing parenthesis.
            if (this.peek(this.offset) === 41 /* CloseParen */) {
                var type = this.text.substring(typeStart, length).toLowerCase();
                if (PhpLexer.CastTokens.has(type)) {
                    this.offset++; // ")"
                    // Suppress TS2322: Result cannot be undefined due to if-condition.
                    this.tokenKind = PhpLexer.CastTokens.get(type);
                    return this.offset - castStart;
                }
            }
        }
        // Not found.
        this.offset = castStart + 1;
        this.tokenKind = TokenKind_1.TokenKind.OpenParen;
        return 1;
    };
    /**
     * Attempts to scan for the opening label or a heredoc string. If not found,
     * nothing is scanned.
     */
    PhpLexer.prototype.tryScanHeredocStartLabel = function () {
        var start = this.offset;
        this.offset = this.offset + 3; // "<<<"
        // Skip leading tabs and spaces after the operator.
        this.scanWhitespace();
        var quoteCh = 0;
        // Optional opening quote.
        var ch = this.peek(this.offset);
        if (ch === 34 /* DoubleQuote */ || ch === 39 /* SingleQuote */) {
            quoteCh = ch;
            this.offset++;
        }
        var labelStart = this.offset;
        var label;
        // Label.
        ch = this.peek(this.offset);
        if (!Character_1.CharacterInfo.isIdentifierStart(ch, this.phpVersion)) {
            this.offset = start;
            return null;
        }
        this.offset++;
        this.scanIdentifierPart();
        // Closing quote.
        if (quoteCh) {
            if (this.peek(this.offset) !== quoteCh) {
                this.offset = start;
                return null;
            }
            label = this.text.substring(labelStart, this.offset - labelStart);
            this.offset++;
        }
        else {
            label = this.text.substring(labelStart, this.offset - labelStart);
        }
        // A line break after the label is required as well.
        ch = this.peek(this.offset);
        if (ch === 13 /* CarriageReturn */) {
            this.offset++;
            // PHP does NOT require a well-formed CRLF here.
            if (this.peek(this.offset) === 10 /* LineFeed */) {
                this.offset++;
            }
        }
        else if (ch === 10 /* LineFeed */) {
            this.offset++;
        }
        else {
            // Missing line break, not a heredoc label.
            this.offset = start;
            return null;
        }
        return new HeredocLabelInfo(label, this.offset - start, quoteCh === 39 /* SingleQuote */);
    };
    /**
     * A map of cast types to their associated tokens.
     */
    PhpLexer.CastTokens = new Map([
        ['array', TokenKind_1.TokenKind.ArrayCast],
        ['binary', TokenKind_1.TokenKind.BinaryCast],
        ['bool', TokenKind_1.TokenKind.BoolCast],
        ['boolean', TokenKind_1.TokenKind.BooleanCast],
        ['double', TokenKind_1.TokenKind.DoubleCast],
        ['float', TokenKind_1.TokenKind.FloatCast],
        ['int', TokenKind_1.TokenKind.IntCast],
        ['integer', TokenKind_1.TokenKind.IntegerCast],
        ['object', TokenKind_1.TokenKind.ObjectCast],
        ['real', TokenKind_1.TokenKind.RealCast],
        ['string', TokenKind_1.TokenKind.StringCast],
        ['unset', TokenKind_1.TokenKind.UnsetCast]
    ]);
    /**
     * A map of keywords to their associated tokens.
     */
    PhpLexer.KeywordTokens = new Map([
        ['__class__', TokenKind_1.TokenKind.MagicClass],
        ['__dir__', TokenKind_1.TokenKind.MagicDirectory],
        ['__file__', TokenKind_1.TokenKind.MagicFile],
        ['__function__', TokenKind_1.TokenKind.MagicFunction],
        ['__halt_compiler', TokenKind_1.TokenKind.HaltCompiler],
        ['__line__', TokenKind_1.TokenKind.MagicLine],
        ['__method__', TokenKind_1.TokenKind.MagicMethod],
        ['__namespace__', TokenKind_1.TokenKind.MagicNamespace],
        ['__trait__', TokenKind_1.TokenKind.MagicTrait],
        ['abstract', TokenKind_1.TokenKind.Abstract],
        ['and', TokenKind_1.TokenKind.LogicalAnd],
        ['array', TokenKind_1.TokenKind.Array],
        ['as', TokenKind_1.TokenKind.As],
        ['break', TokenKind_1.TokenKind.Break],
        ['callable', TokenKind_1.TokenKind.Callable],
        ['case', TokenKind_1.TokenKind.Case],
        ['catch', TokenKind_1.TokenKind.Catch],
        ['class', TokenKind_1.TokenKind.Class],
        ['clone', TokenKind_1.TokenKind.Clone],
        ['const', TokenKind_1.TokenKind.Const],
        ['continue', TokenKind_1.TokenKind.Continue],
        ['declare', TokenKind_1.TokenKind.Declare],
        ['default', TokenKind_1.TokenKind.Default],
        ['die', TokenKind_1.TokenKind.Die],
        ['do', TokenKind_1.TokenKind.Do],
        ['echo', TokenKind_1.TokenKind.Echo],
        ['else', TokenKind_1.TokenKind.Else],
        ['elseif', TokenKind_1.TokenKind.ElseIf],
        ['empty', TokenKind_1.TokenKind.Empty],
        ['enddeclare', TokenKind_1.TokenKind.EndDeclare],
        ['endfor', TokenKind_1.TokenKind.EndFor],
        ['endforeach', TokenKind_1.TokenKind.EndForEach],
        ['endif', TokenKind_1.TokenKind.EndIf],
        ['endswitch', TokenKind_1.TokenKind.EndSwitch],
        ['endwhile', TokenKind_1.TokenKind.EndWhile],
        ['eval', TokenKind_1.TokenKind.Eval],
        ['exit', TokenKind_1.TokenKind.Exit],
        ['extends', TokenKind_1.TokenKind.Extends],
        ['final', TokenKind_1.TokenKind.Final],
        ['finally', TokenKind_1.TokenKind.Finally],
        ['fn', TokenKind_1.TokenKind.Fn],
        ['for', TokenKind_1.TokenKind.For],
        ['foreach', TokenKind_1.TokenKind.ForEach],
        ['function', TokenKind_1.TokenKind.Function],
        ['global', TokenKind_1.TokenKind.Global],
        ['goto', TokenKind_1.TokenKind.GoTo],
        ['if', TokenKind_1.TokenKind.If],
        ['implements', TokenKind_1.TokenKind.Implements],
        ['include', TokenKind_1.TokenKind.Include],
        ['include_once', TokenKind_1.TokenKind.IncludeOnce],
        ['instanceof', TokenKind_1.TokenKind.InstanceOf],
        ['insteadof', TokenKind_1.TokenKind.InsteadOf],
        ['interface', TokenKind_1.TokenKind.Interface],
        ['isset', TokenKind_1.TokenKind.IsSet],
        ['list', TokenKind_1.TokenKind.List],
        ['namespace', TokenKind_1.TokenKind.Namespace],
        ['new', TokenKind_1.TokenKind.New],
        ['or', TokenKind_1.TokenKind.LogicalOr],
        ['print', TokenKind_1.TokenKind.Print],
        ['private', TokenKind_1.TokenKind.Private],
        ['protected', TokenKind_1.TokenKind.Protected],
        ['public', TokenKind_1.TokenKind.Public],
        ['require', TokenKind_1.TokenKind.Require],
        ['require_once', TokenKind_1.TokenKind.RequireOnce],
        ['return', TokenKind_1.TokenKind.Return],
        ['static', TokenKind_1.TokenKind.Static],
        ['switch', TokenKind_1.TokenKind.Switch],
        ['throw', TokenKind_1.TokenKind.Throw],
        ['trait', TokenKind_1.TokenKind.Trait],
        ['try', TokenKind_1.TokenKind.Try],
        ['while', TokenKind_1.TokenKind.While],
        ['unset', TokenKind_1.TokenKind.Unset],
        ['use', TokenKind_1.TokenKind.Use],
        ['var', TokenKind_1.TokenKind.Var],
        ['xor', TokenKind_1.TokenKind.LogicalXor],
        ['yield', TokenKind_1.TokenKind.Yield]
    ]);
    return PhpLexer;
}(Lexer_1.LexerBase));
exports.PhpLexer = PhpLexer;
