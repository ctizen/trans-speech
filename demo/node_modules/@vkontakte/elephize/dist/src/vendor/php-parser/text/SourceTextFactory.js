/**
 * Copyright 2017 Matt Acosta
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceTextFactory = void 0;
var php_common_1 = require("../../php-common");
var BomKind_1 = require("./BomKind");
var CompositeText_1 = require("./CompositeText");
var Encoding_1 = require("./Encoding");
var StringText_1 = require("./StringText");
/**
 * @todo Document SourceTextFactory.
 */
var SourceTextFactory = /** @class */ (function () {
    function SourceTextFactory() {
    }
    /**
     * Creates a source text container from other source texts.
     *
     * @param {ReadonlyArray<ISourceText>} sources
     *   A list of ordered text segments.
     * @param {number} sourceLength
     *   The total length of the stored text. This may be greater than the length
     *   of the text.
     * @param {Encoding} encoding
     *   The original encoding of the source text.
     *
     * @internal
     */
    SourceTextFactory.createContainer = function (sources, sourceLength, encoding) {
        return CompositeText_1.CompositeText.from(sources, sourceLength, encoding);
    };
    /**
     * Creates a source text object from a string.
     *
     * @param {string} text
     *   A string containing source code.
     * @param {Encoding=} encoding
     *   The original encoding of the source text. Defaults to `Encoding.Utf8`.
     */
    SourceTextFactory.from = function (text, encoding) {
        if (encoding === void 0) { encoding = Encoding_1.Encoding.Utf8; }
        return new StringText_1.StringText(text, encoding);
    };
    /**
     * Attempts to determine if a byte order mark is present in the source text.
     *
     * @param {Uint8Array} buffer
     *   A byte-array containing the encoded source text.
     * @param {number} length
     *   The number of valid bytes in the buffer.
     */
    SourceTextFactory.tryReadByteOrderMark = function (buffer, length) {
        if (length > buffer.length) {
            throw new php_common_1.ArgumentOutOfRangeException();
        }
        if (length >= 2) {
            if (buffer[0] === 0xFE && buffer[1] === 0xFF) {
                return BomKind_1.BomKind.UTF16BE;
            }
            if (buffer[0] === 0xFF && buffer[1] === 0xFE) {
                return BomKind_1.BomKind.UTF16LE;
            }
            if (buffer[0] === 0xEF) {
                if (length >= 3 && buffer[1] === 0xBB && buffer[2] === 0xBF) {
                    return BomKind_1.BomKind.UTF8;
                }
            }
        }
        return BomKind_1.BomKind.Unknown;
    };
    /**
     * An empty source text container.
     */
    SourceTextFactory.EmptyText = new StringText_1.StringText('', Encoding_1.Encoding.Utf8);
    /**
     * The maximum length of a string before a more efficient source text
     * container is created.
     *
     * @todo Experimental.
     * @todo Unused.
     */
    SourceTextFactory.LargeTextLimit = 4 * 1024; // 4KB
    return SourceTextFactory;
}());
exports.SourceTextFactory = SourceTextFactory;
