/**
 * Copyright 2017 Matt Acosta
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeBase = void 0;
var php_common_1 = require("../../../php-common");
/**
 * Provides a base class for all nodes in a tree (both terminal and non-terminal).
 */
var NodeBase = /** @class */ (function () {
    /**
     * Constructs a `NodeBase` object.
     *
     * @param {ReadonlyArray<SyntaxDiagnostic>} diagnostics
     *   A list of diagnostics associated with the token or token collection.
     */
    function NodeBase(diagnostics) {
        // IMPORTANT: This is a performance critical method.
        // NOTE: This class does not implement any properties because everything
        // inherits from this class, and any operation that would cause `this` to
        // be dereferenced would also cause V8 to perform a map check which would
        // subsequently fail.
        if (diagnostics.length > 0) {
            NodeBase.DiagnosticWeakMap.set(this, diagnostics);
        }
    }
    Object.defineProperty(NodeBase.prototype, "containsDiagnostics", {
        /**
         * @inheritDoc
         */
        get: function () {
            return (this._flags & 1 /* ContainsDiagnostics */) !== 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "containsSkippedText", {
        /**
         * @inheritDoc
         */
        get: function () {
            return (this._flags & 2 /* ContainsSkippedText */) !== 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "count", {
        /**
         * @inheritDoc
         */
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "diagnostics", {
        /**
         * @inheritDoc
         */
        get: function () {
            if (NodeBase.DiagnosticWeakMap.has(this)) {
                // Suppress TS2322: Result cannot be undefined due to if-condition.
                return NodeBase.DiagnosticWeakMap.get(this);
            }
            // Do not create a new array on every call.
            return NodeBase.EmptyDiagnosticList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "isMissing", {
        /**
         * @inheritDoc
         */
        get: function () {
            return (this._flags & 8 /* IsNotMissing */) === 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "isList", {
        /**
         * @inheritDoc
         */
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "isToken", {
        /**
         * @inheritDoc
         */
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "isTrivia", {
        /**
         * @inheritDoc
         */
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "leadingTrivia", {
        /**
         * @inheritDoc
         */
        get: function () {
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "leadingTriviaWidth", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._fullWidth !== 0 ? this.getFirstToken().leadingTriviaWidth : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "width", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._fullWidth - this.leadingTriviaWidth;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    NodeBase.prototype.indexAtOffset = function (relativeOffset) {
        if (relativeOffset < 0 || relativeOffset >= this.fullWidth) {
            throw new php_common_1.ArgumentOutOfRangeException();
        }
        var width = 0;
        var length = this.count;
        for (var i = 0; i < length; i++) {
            var child = this.childAt(i);
            if (child !== null) {
                width += child.fullWidth;
                if (relativeOffset < width) {
                    return i;
                }
            }
        }
        // Offset was not within parent node.
        throw new php_common_1.Exception('Child node expected');
    };
    /**
     * @inheritDoc
     */
    NodeBase.prototype.offsetAt = function (index) {
        if (index < 0 || index >= this.count) {
            throw new php_common_1.ArgumentOutOfRangeException();
        }
        var offset = 0;
        for (var i = 0; i < index; i++) {
            var child = this.childAt(i);
            if (child !== null) {
                offset += child.fullWidth;
            }
        }
        return offset;
    };
    /**
     * Gets the first node that does not have any children.
     */
    NodeBase.prototype.getFirstToken = function () {
        var length = this.count;
        var node = this;
        // Terminal nodes (tokens and trivia) should not indirectly call this
        // method, as that indicates a missing override.
        php_common_1.Debug.assert(length !== 0);
        do {
            var firstChild = null;
            for (var i = 0; i < length; i++) {
                var child = node.childAt(i);
                if (child !== null) {
                    firstChild = child;
                    length = child.count;
                    break;
                }
            }
            node = firstChild;
        } while (node !== null && length > 0);
        if (node === null) {
            // The parser should not have created this node.
            throw new php_common_1.Exception('Child node expected');
        }
        return node;
    };
    /**
     * Gets the last node that does not have any children.
     */
    NodeBase.prototype.getLastToken = function () {
        var length = this.count;
        var node = this;
        // Terminal nodes (tokens and trivia) should not indirectly call this
        // method, as that indicates a missing override.
        php_common_1.Debug.assert(length !== 0);
        do {
            var lastChild = null;
            for (var i = length - 1; i >= 0; i--) {
                var child = node.childAt(i);
                if (child !== null) {
                    lastChild = child;
                    length = child.count;
                    break;
                }
            }
            node = lastChild;
        } while (node !== null && length > 0);
        if (node === null) {
            // The parser should not have created this node.
            throw new php_common_1.Exception('Child node expected');
        }
        return node;
    };
    /**
     * A map of all diagnostics attached to nodes.
     *
     * Since nodes are more likely to not contain any diagnostics, this saves
     * memory by not adding a diagnostic field to every node. Diagnostics are
     * instead maintained using a weak reference to the associated node, so that
     * they can still be reclaimed automatically when the node is no longer
     * referenced.
     */
    NodeBase.DiagnosticWeakMap = new WeakMap();
    /**
     * An empty diagnostic array.
     */
    NodeBase.EmptyDiagnosticList = [];
    return NodeBase;
}());
exports.NodeBase = NodeBase;
