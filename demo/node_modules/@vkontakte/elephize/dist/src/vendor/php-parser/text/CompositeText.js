/**
 * Copyright 2017 Matt Acosta
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompositeText = exports.CompositePosition = void 0;
var php_common_1 = require("../../php-common");
var SourceTextBase_1 = require("./SourceTextBase");
var SourceTextBuilder_1 = require("./SourceTextBuilder");
var SourceTextFactory_1 = require("./SourceTextFactory");
var TextSpan_1 = require("./TextSpan");
/**
 * @internal
 */
var CompositePosition = /** @class */ (function () {
    function CompositePosition(index, offset) {
        this.index = index;
        this.offset = offset;
    }
    return CompositePosition;
}());
exports.CompositePosition = CompositePosition;
/**
 * A source code container created from other source texts.
 *
 * @internal
 */
var CompositeText = /** @class */ (function (_super) {
    __extends(CompositeText, _super);
    /**
     * Constructs a `CompositeText` object.
     *
     * @param {ReadonlyArray<ISourceText>} sources
     *   A list of text segments.
     * @param {number} sourceLength
     *   The total length of the stored text. This may be greater than the length
     *   of the text.
     * @param {Encoding} encoding
     *   The original encoding of the source text.
     */
    function CompositeText(sources, sourceLength, encoding) {
        var _this = _super.call(this) || this;
        /**
         * The index of a segment that was previously searched for.
         */
        _this.previousIndex = 0;
        var length = 0;
        var segmentOffsets = new Array(sources.length);
        for (var i = 0; i < sources.length; i++) {
            segmentOffsets[i] = length;
            length += sources[i].length;
        }
        _this.encoding = encoding;
        _this.length = length;
        _this.sourceKey = _this;
        _this.sourceLength = sourceLength;
        _this.sources = sources;
        _this.segmentOffsets = segmentOffsets;
        return _this;
    }
    /**
     * @todo Document CompositeText.from().
     */
    CompositeText.from = function (sources, sourceLength, encoding) {
        if (sources.length === 0) {
            return SourceTextFactory_1.SourceTextFactory.EmptyText;
        }
        if (sources.length === 1) {
            php_common_1.Debug.assert(sources[0].encoding === encoding);
            return sources[0];
        }
        return new CompositeText(sources, sourceLength, encoding);
    };
    /**
     * Compares two offsets and returns the difference.
     */
    CompositeText.offsetComparer = function (a, b) {
        // Since offsets are always positive integers, just subtract.
        return a - b;
    };
    /**
     * @inheritDoc
     */
    CompositeText.prototype.charCodeAt = function (offset) {
        if (offset < 0 || offset >= this.length) {
            return NaN;
        }
        // The offset is typically just incremented by one on each call, so there
        // is a good chance that it's in a previously found segment.
        var segmentStart = this.segmentOffsets[this.previousIndex];
        if (offset >= segmentStart && (offset - segmentStart) < this.sources[this.previousIndex].length) {
            return this.sources[this.previousIndex].charCodeAt(offset - segmentStart);
        }
        // The offset is in a different segment.
        var segmentPosition = this.positionAt(offset);
        this.previousIndex = segmentPosition.index;
        return this.sources[segmentPosition.index].charCodeAt(segmentPosition.offset);
    };
    /**
     * @inheritDoc
     */
    CompositeText.prototype.slice = function (position) {
        if (typeof position === 'number') {
            position = TextSpan_1.TextSpan.fromBounds(position, this.length);
        }
        if (!this.isSpanInText(position)) {
            throw new php_common_1.ArgumentOutOfRangeException();
        }
        var segmentPosition = this.positionAt(position.start);
        var builder = new SourceTextBuilder_1.SourceTextBuilder(this.encoding);
        var index = segmentPosition.index;
        var offset = segmentPosition.offset;
        var remainder = position.length;
        while (remainder > 0) {
            var length_1 = Math.min(remainder, this.sources[index].length - offset);
            builder.append(this.sources[index].slice(new TextSpan_1.TextSpan(offset, length_1)));
            index++;
            offset = 0;
            remainder -= length_1;
        }
        return builder.toSourceText();
    };
    /**
     * @inheritDoc
     */
    CompositeText.prototype.substring = function (start, length) {
        if (start < 0) {
            start = this.length + start;
        }
        if (start < 0 || start > this.length) {
            throw new php_common_1.ArgumentOutOfRangeException();
        }
        if (length === void 0) {
            length = this.length - start;
        }
        if (length < 0) {
            length = 0;
        }
        if (length > this.length - start) {
            throw new php_common_1.ArgumentOutOfRangeException();
        }
        var segmentPosition = this.positionAt(start);
        var text = '';
        var index = segmentPosition.index;
        var offset = segmentPosition.offset;
        var remainder = length;
        while (remainder > 0) {
            var segmentLength = Math.min(remainder, this.sources[index].length - offset);
            text += this.sources[index].substring(offset, segmentLength);
            index++;
            offset = 0;
            remainder -= segmentLength;
        }
        return text;
    };
    /**
     * @inheritDoc
     */
    CompositeText.prototype.withEncoding = function (encoding) {
        // @todo This incurs a slight performance penalty because it recomputes
        //   offsets and overall length. Those could be made lazy in the future.
        return new CompositeText(this.sources, this.sourceLength, encoding);
    };
    /**
     * Determines which segment contains the specified offset.
     *
     * @param {number} offset
     *   The offset to search for.
     *
     * @return {CompositePosition}
     *   The segment and offset within that segment, of the specified offset.
     */
    CompositeText.prototype.positionAt = function (offset) {
        var index = php_common_1.List.binarySearch(this.segmentOffsets, offset, CompositeText.offsetComparer);
        // If not found, the result is the two's complement of the index where it
        // should be, so the offset must be in the previous segment.
        index = index >= 0 ? index : (~index - 1);
        return new CompositePosition(index, offset - this.segmentOffsets[index]);
    };
    return CompositeText;
}(SourceTextBase_1.SourceTextBase));
exports.CompositeText = CompositeText;
