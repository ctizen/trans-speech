/**
 * Copyright 2017 Matt Acosta
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyntaxTrivia = void 0;
var NodeExtensions_1 = require("../node/NodeExtensions");
var TextSpan_1 = require("../../text/TextSpan");
var TokenKind_1 = require("../TokenKind");
/**
 * Represents an insignificant token within a syntax tree.
 */
var SyntaxTrivia = /** @class */ (function () {
    /**
     * Constructs a `SyntaxTrivia` object.
     */
    function SyntaxTrivia(node, token, offset, index) {
        this.index = index;
        this.node = node;
        this.offset = offset;
        this.token = token;
    }
    Object.defineProperty(SyntaxTrivia.prototype, "containsStructuredTrivia", {
        /**
         * @inheritDoc
         */
        get: function () {
            return false; // @todo Not implemented.
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxTrivia.prototype, "containsSkippedText", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this.node !== null ? this.node.containsSkippedText : false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxTrivia.prototype, "fullSpan", {
        /**
         * @inheritDoc
         */
        get: function () {
            return new TextSpan_1.TextSpan(this.offset, this.node !== null ? this.node.fullWidth : 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxTrivia.prototype, "kind", {
        /**
         * @inheritDoc
         */
        get: function () {
            // @todo Use an interface.
            return this.node !== null ? this.node.kind : TokenKind_1.TokenKind.Unknown;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxTrivia.prototype, "span", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this.node !== null
                ? new TextSpan_1.TextSpan(this.offset + this.node.leadingTriviaWidth, this.node.width)
                : new TextSpan_1.TextSpan(this.offset, 0);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Determines if the trivia was created from a skipped token.
     */
    SyntaxTrivia.isSkippedToken = function (trivia) {
        return trivia.containsSkippedText;
    };
    /**
     * @inheritDoc
     */
    SyntaxTrivia.prototype.equals = function (value) {
        if (this === value) {
            return true;
        }
        if (this.offset === value.offset && this.index === value.index && this.token.equals(value.token)) {
            return NodeExtensions_1.NodeExtensions.equals(this.node, value.node);
        }
        return false;
    };
    /**
     * @inheritDoc
     */
    SyntaxTrivia.prototype.getStructure = function () {
        return null; // @todo Not implemented.
    };
    return SyntaxTrivia;
}());
exports.SyntaxTrivia = SyntaxTrivia;
