/**
 * Copyright 2017 Matt Acosta
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhpParser = exports.Parameters = exports.InvocationArguments = exports.Expression = void 0;
var php_common_1 = require("../../php-common");
var Node_Generated_1 = require("../language/node/Node.Generated");
var ErrorCode_Generated_1 = require("../diagnostics/ErrorCode.Generated");
var ExpressionType_1 = require("./ExpressionType");
var Parser_1 = require("./Parser");
var ModifierFlags_1 = require("./ModifierFlags");
var NodeFactory_1 = require("../language/node/NodeFactory");
var PhpLexer_1 = require("./PhpLexer");
var PhpParserOptions_1 = require("./PhpParserOptions");
var PhpVersion_1 = require("./PhpVersion");
var Precedence_1 = require("./Precedence");
var SourceTextNode_1 = require("../language/node/SourceTextNode");
var SyntaxDiagnostic_1 = require("../diagnostics/SyntaxDiagnostic");
var TextSpan_1 = require("../text/TextSpan");
var Token_1 = require("./Token");
var TokenKind_1 = require("../language/TokenKind");
var TokenNode_1 = require("../language/node/TokenNode");
/**
 * A container for a parsed expression (or statement) node and its type.
 */
var Expression = /** @class */ (function () {
    function Expression(node, type) {
        this.node = node;
        this.type = type;
    }
    return Expression;
}());
exports.Expression = Expression;
/**
 * A container for the arguments of an invocation expression.
 */
var InvocationArguments = /** @class */ (function () {
    function InvocationArguments(openParen, argumentList, closeParen) {
        this.openParen = openParen;
        this.argumentList = argumentList;
        this.closeParen = closeParen;
    }
    return InvocationArguments;
}());
exports.InvocationArguments = InvocationArguments;
/**
 * A container for the parameters of a function or method declaration.
 */
var Parameters = /** @class */ (function () {
    function Parameters(openParen, parameterList, closeParen) {
        this.openParen = openParen;
        this.parameterList = parameterList;
        this.closeParen = closeParen;
    }
    return Parameters;
}());
exports.Parameters = Parameters;
/**
 * Parses a PHP file into an abstract syntax tree.
 */
var PhpParser = /** @class */ (function () {
    /**
     * Constructs a `PhpParser` object.
     *
     * @todo Implement incremental parsing.
     * @todo Implement cancellation token support.
     */
    function PhpParser(lexer, options /*, oldTree?: SourceTextSyntaxNode, changes?: TextChange[], cancellationToken?: any*/) {
        if (options === void 0) { options = PhpParserOptions_1.PhpParserOptions.Default; }
        /**
         * A list of trivia nodes that preceed the current token.
         */
        this.leadingTrivia = [];
        /**
         * The width of the current token's leading trivia.
         */
        this.leadingTriviaWidth = 0;
        this.currentContext = 0 /* SourceElements */;
        this.currentToken = new Token_1.Token(TokenKind_1.TokenKind.Unknown, 0, 0);
        this.factory = new NodeFactory_1.NodeFactory();
        this.lexer = lexer;
        this.lexerState = lexer.currentState;
        this.options = options;
    }
    /**
     * @inheritDoc
     */
    PhpParser.prototype.parse = function () {
        this.nextToken();
        return this.parseSourceText().createSyntaxNode();
    };
    /**
     * Force the parser to skip any remaining content.
     *
     * @todo Experimental.
     */
    PhpParser.prototype.forceEndOfFile = function () {
        // @todo Technically this should be the end of the scanning bounds.
        var end = this.lexer.sourceText.length;
        // Already at the end of the file.
        if (this.currentToken.kind === TokenKind_1.TokenKind.EOF) {
            return;
        }
        // The syntax tree still needs to be fully representative, so make a token
        // with any intermediate content...
        this.currentToken = new Token_1.Token(TokenKind_1.TokenKind.InlineText, this.currentToken.offset, end - this.currentToken.offset);
        // ...and then skip it (without a diagnostic).
        var trivia = this.factory.createSkippedTokenTrivia(this.currentToken.kind, this.currentToken.length);
        this.leadingTriviaWidth = this.leadingTriviaWidth + this.currentToken.length;
        this.leadingTrivia.push(trivia);
        // Finally, move the lexer to get the actual EOF token.
        this.lexer.setPosition(end);
        this.nextToken();
    };
    /**
     * Determines if the given version requirements are satisfied.
     *
     * @param {PhpVersion} minVersion
     *   The earliest supported PHP version.
     * @param {PhpVersion} maxVersion
     *   The latest supported PHP version.
     */
    PhpParser.prototype.isSupportedVersion = function (minVersion, maxVersion) {
        if (maxVersion === void 0) { maxVersion = PhpVersion_1.PhpVersion.Latest; }
        return this.options.version >= minVersion && this.options.version <= maxVersion;
    };
    /**
     * @todo Document parseSourceText().
     */
    PhpParser.prototype.parseSourceText = function () {
        var statements = this.parseList(0 /* SourceElements */);
        var eofToken = this.eat(TokenKind_1.TokenKind.EOF);
        return new SourceTextNode_1.SourceTextNode(statements, eofToken);
    };
    // --------------------------------------------------------------------------
    // Token nodes
    // --------------------------------------------------------------------------
    /**
     * Creates a missing token.
     *
     * @param {TokenKind} expected
     *   The expected token kind.
     * @param {TokenKind} actual
     *   The actual token kind that was parsed.
     * @param {boolean} reportError
     *   If `true`, the created token will contain a diagnostic using a generic
     *   error code (depending on the expected and actual tokens found).
     */
    PhpParser.prototype.createMissingToken = function (expected, actual, reportError) {
        var diagnostics = [];
        if (reportError) {
            var diagnostic = this.createExpectedDiagnostic(expected, actual, this.getOffsetForMissingToken(), 0);
            diagnostics.push(diagnostic);
        }
        return this.createMissingTokenWithDiagnostic(expected, diagnostics);
    };
    /**
     * Creates a missing token using the given error code.
     */
    PhpParser.prototype.createMissingTokenWithError = function (expected, code) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var diagnostic = this.createDiagnosticForMissingToken.apply(this, __spreadArray([code], __read(args)));
        return this.createMissingTokenWithDiagnostic(expected, [diagnostic]);
    };
    /**
     * Creates a missing token with the given diagnostics.
     *
     * NOTE: This method should not be called directly from parsing methods.
     * Use `createMissingToken()` or `createMissingTokenWithError()` instead.
     */
    PhpParser.prototype.createMissingTokenWithDiagnostic = function (expected, diagnostics) {
        return this.factory.createMissingToken(expected, null, diagnostics);
    };
    /**
     * Creates a `TokenNode` from a token generated by the lexer.
     *
     * If there was leading trivia prior to this token, it will also be added
     * to the token.
     *
     * @param {Token} token
     *   A token generated by the lexer.
     */
    PhpParser.prototype.createToken = function (token) {
        var diagnostics = token.diagnostics;
        // Adjust token diagnostics for leading trivia on the node.
        for (var i = 0; i < diagnostics.length; i++) {
            diagnostics[i] = diagnostics[i].withOffset(diagnostics[i].offset + this.leadingTriviaWidth);
        }
        if (this.leadingTrivia.length > 0) {
            var trivia = this.factory.createList(this.leadingTrivia);
            this.leadingTrivia = [];
            this.leadingTriviaWidth = 0;
            return this.factory.createTokenWithTrivia(token.kind, token.length, trivia, diagnostics);
        }
        return this.factory.createToken(token.kind, token.length, diagnostics);
    };
    /**
     * Creates a token node.
     *
     * If expected, the lexer will also be moved to the next token.
     *
     * @param {TokenKind} kind
     *   The expected type of the token to parse.
     *
     * @return {TokenNode}
     *   A token node. If the expected token does not match the current token,
     *   this node will be flagged as missing.
     */
    PhpParser.prototype.eat = function (kind) {
        if (this.currentToken.kind === kind) {
            var token = this.createToken(this.currentToken);
            this.nextToken();
            return token;
        }
        return this.createMissingToken(kind, this.currentToken.kind, true);
    };
    /**
     * Creates a token node only if the expected token matches the current token.
     *
     * If expected, the lexer will also be moved to the next token.
     *
     * @param {TokenKind} kind
     *   The expected type of token to parse.
     *
     * @return {TokenNode|null}
     *   A token node, or `null` if the current token was not expected.
     */
    PhpParser.prototype.eatOptional = function (kind) {
        if (this.currentToken.kind === kind) {
            var token = this.createToken(this.currentToken);
            this.nextToken();
            return token;
        }
        return null;
    };
    /**
     * Moves the lexer to the next non-trivia token.
     */
    PhpParser.prototype.nextToken = function () {
        this.scanToken();
        while (TokenKind_1.TokenKindInfo.isTrivia(this.currentToken.kind)) {
            var diagnostics = this.currentToken.diagnostics;
            // Adjust token diagnostics for leading trivia on the node.
            for (var i = 0; i < diagnostics.length; i++) {
                diagnostics[i] = diagnostics[i].withOffset(diagnostics[i].offset + this.leadingTriviaWidth);
            }
            var trivia = this.factory.createTrivia(this.currentToken.kind, this.currentToken.length, diagnostics);
            this.leadingTriviaWidth = this.leadingTriviaWidth + this.currentToken.length;
            this.leadingTrivia.push(trivia);
            this.scanToken();
        }
    };
    /**
     * @todo Document scanToken().
     *
     * @todo Merge into nextToken() if not needed for incremental parsing.
     */
    PhpParser.prototype.scanToken = function () {
        this.currentToken = this.lexer.lex(this.lexerState);
        if (this.lexerState !== this.lexer.currentState) {
            // @todo May need to save the location of the state change.
            this.lexerState = this.lexer.currentState;
        }
    };
    /**
     * Adds the current token to the leading trivia of the next token. The token
     * will be given a generic diagnostic as well.
     */
    PhpParser.prototype.skipToken = function () {
        this.skipTokenWithError(ErrorCode_Generated_1.ErrorCode.ERR_UnexpectedToken, TokenKind_1.TokenKindInfo.getText(this.currentToken.kind));
    };
    /**
     * Adds the current token to the leading trivia of the next token with a
     * given error code.
     */
    PhpParser.prototype.skipTokenWithError = function (code) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var diagnostic = this.createDiagnosticForSkippedToken.apply(this, __spreadArray([code], __read(args)));
        var trivia = this.factory.createSkippedTokenTrivia(this.currentToken.kind, this.currentToken.length, [diagnostic]);
        this.leadingTriviaWidth = this.leadingTriviaWidth + this.currentToken.length;
        this.leadingTrivia.push(trivia);
        this.nextToken();
    };
    // --------------------------------------------------------------------------
    // Diagnostics
    // --------------------------------------------------------------------------
    /**
     * Appends a diagnostic to the given node.
     */
    PhpParser.prototype.addError = function (node, code) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var existing = node.diagnostics;
        var diagnostic = this.createDiagnosticForNode.apply(this, __spreadArray([node, code], __read(args)));
        // Suppress TS2322: Type `INode` is assignable to `INode`.
        return node.withDiagnostics(existing.concat([diagnostic]));
    };
    /**
     * Creates a diagnostic for a node.
     */
    PhpParser.prototype.createDiagnostic = function (offset, width, code) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return new (SyntaxDiagnostic_1.SyntaxDiagnostic.bind.apply(SyntaxDiagnostic_1.SyntaxDiagnostic, __spreadArray([void 0, offset, width, code], __read(args))))();
    };
    /**
     * Creates a diagnostic for a token node with no width.
     */
    PhpParser.prototype.createDiagnosticForMissingToken = function (code) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return this.createDiagnostic.apply(this, __spreadArray([this.getOffsetForMissingToken(), 0, code], __read(args)));
    };
    /**
     * Creates a diagnostic for a node that has already been created.
     */
    PhpParser.prototype.createDiagnosticForNode = function (node, code) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return this.createDiagnostic.apply(this, __spreadArray([node.leadingTriviaWidth, node.width, code], __read(args)));
    };
    /**
     * Creates a diagnostic for a trivia node containing a skipped token.
     */
    PhpParser.prototype.createDiagnosticForSkippedToken = function (code) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return this.createDiagnostic.apply(this, __spreadArray([this.leadingTriviaWidth, this.currentToken.length, code], __read(args)));
    };
    /**
     * Creates a diagnostic at a specified location using an error code
     * appropriate for the expected and actual token kinds.
     */
    PhpParser.prototype.createExpectedDiagnostic = function (expected, actual, offset, width) {
        var code = this.getExpectedTokenErrorCode(expected, actual);
        switch (code) {
            case ErrorCode_Generated_1.ErrorCode.ERR_IdentifierExpectedKeyword:
                return this.createDiagnostic(offset, width, code, TokenKind_1.TokenKindInfo.getText(actual));
            case ErrorCode_Generated_1.ErrorCode.ERR_Syntax:
                return this.createDiagnostic(offset, width, code, TokenKind_1.TokenKindInfo.getText(expected));
            default:
                return this.createDiagnostic(offset, width, code);
        }
    };
    /**
     * Gets an appropriate error code given the expected and actual token kinds.
     */
    PhpParser.prototype.getExpectedTokenErrorCode = function (expected, actual) {
        switch (expected) {
            case TokenKind_1.TokenKind.Identifier:
                // if (TokenKindInfo.isSemiReservedKeyword(actual)) {
                //   return ErrorCode.ERR_IdentifierExpectedKeyword;
                // }
                return ErrorCode_Generated_1.ErrorCode.ERR_IdentifierExpected;
            case TokenKind_1.TokenKind.Semicolon:
                return ErrorCode_Generated_1.ErrorCode.ERR_SemicolonExpected;
            case TokenKind_1.TokenKind.CloseBrace:
                return ErrorCode_Generated_1.ErrorCode.ERR_CloseBraceExpected;
            case TokenKind_1.TokenKind.CloseBracket:
                return ErrorCode_Generated_1.ErrorCode.ERR_CloseBracketExpected;
            case TokenKind_1.TokenKind.CloseParen:
                return ErrorCode_Generated_1.ErrorCode.ERR_CloseParenExpected;
            case TokenKind_1.TokenKind.OpenBrace:
                return ErrorCode_Generated_1.ErrorCode.ERR_OpenBraceExpected;
            case TokenKind_1.TokenKind.OpenParen:
                return ErrorCode_Generated_1.ErrorCode.ERR_OpenParenExpected;
            default:
                return ErrorCode_Generated_1.ErrorCode.ERR_Syntax;
        }
    };
    /**
     * Gets the offset of the last non-whitespace token in the leading trivia.
     *
     * This method is required to properly place diagnostics when multiple tokens
     * have been skipped.
     */
    PhpParser.prototype.getOffsetForMissingToken = function () {
        var offset = this.leadingTriviaWidth;
        for (var i = this.leadingTrivia.length - 1; i >= 0; i--) {
            var trivia = this.leadingTrivia[i];
            // The first skipped token found is where the diagnostic should be.
            if (!TokenKind_1.TokenKindInfo.isTrivia(trivia.kind)) {
                break;
            }
            offset -= trivia.width;
        }
        return offset;
    };
    // --------------------------------------------------------------------------
    // Parse contexts
    // --------------------------------------------------------------------------
    /**
     * Adds a context flag to the parser's currently active contexts.
     */
    PhpParser.prototype.addParseContext = function (context) {
        this.currentContext |= context;
    };
    /**
     * Determines if the parser is currently in the given context.
     */
    PhpParser.prototype.isInContext = function (context) {
        return this.currentContext === context || (this.currentContext & context) !== 0;
    };
    /**
     * Determines if the token kind starts or ends any active contexts.
     */
    PhpParser.prototype.isTokenValidInContexts = function (kind) {
        // The default context needs to be manually checked (1 << 0 != 0).
        if (this.tokenStartsContext(0 /* SourceElements */, kind)) {
            return true;
        }
        for (var context = 1; context < 16 /* Length */; context++) {
            var contextFlag = 1 << context;
            if (this.isInContext(contextFlag)) {
                if (this.tokenStartsContext(contextFlag, kind) || this.tokenEndsContext(contextFlag, kind)) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Determines if a token terminates a specified context.
     *
     * @param {ParseContext} context
     *   The context to check.
     * @param {TokenKind} kind
     *   The token kind.
     */
    PhpParser.prototype.tokenEndsContext = function (context, kind) {
        if (kind === TokenKind_1.TokenKind.EOF) {
            return true;
        }
        switch (context) {
            case 0 /* SourceElements */:
                return false;
            case 2048 /* CaseClauseElements */:
                return kind === TokenKind_1.TokenKind.Case || kind === TokenKind_1.TokenKind.Default;
            case 4096 /* ClassMembers */:
            case 2 /* CompoundStatementElements */:
            case 8192 /* InterfaceMembers */:
            case 4 /* NamespaceElements */:
            case 512 /* SwitchElements */:
            case 16384 /* TraitMembers */:
                return kind === TokenKind_1.TokenKind.CloseBrace;
            case 32768 /* ConstantDeclaration */:
                return kind === TokenKind_1.TokenKind.Semicolon;
            case 8 /* DeclareBlockElements */:
                return kind === TokenKind_1.TokenKind.EndDeclare;
            case 64 /* IfBlockElements */:
                return kind === TokenKind_1.TokenKind.Else || kind === TokenKind_1.TokenKind.ElseIf || kind === TokenKind_1.TokenKind.EndIf;
            case 128 /* IfElseBlockElements */:
                return kind === TokenKind_1.TokenKind.EndIf;
            case 16 /* ForBlockElements */:
                return kind === TokenKind_1.TokenKind.EndFor;
            case 32 /* ForEachBlockElements */:
                return kind === TokenKind_1.TokenKind.EndForEach;
            case 1024 /* SwitchBlockElements */:
                return kind === TokenKind_1.TokenKind.EndSwitch;
            case 256 /* WhileBlockElements */:
                return kind === TokenKind_1.TokenKind.EndWhile;
            default:
                throw new Parser_1.ParserException('Unhandled parse context');
        }
    };
    /**
     * Determines if a token could start a node within the specified context.
     *
     * @param {ParseContext} context
     *   The context to check.
     * @param {TokenKind} kind
     *   The token kind.
     */
    PhpParser.prototype.tokenStartsContext = function (context, kind) {
        switch (context) {
            case 0 /* SourceElements */:
            case 4 /* NamespaceElements */:
                return this.isTopStatementStart(kind);
            case 2048 /* CaseClauseElements */:
            case 8 /* DeclareBlockElements */:
            case 16 /* ForBlockElements */:
            case 32 /* ForEachBlockElements */:
            case 64 /* IfBlockElements */:
            case 128 /* IfElseBlockElements */:
            case 2 /* CompoundStatementElements */:
            case 256 /* WhileBlockElements */:
                return this.isStatementBlockStart(kind);
            case 4096 /* ClassMembers */:
            case 8192 /* InterfaceMembers */:
            case 16384 /* TraitMembers */:
                // Even though some class statements are not allowed in interfaces or
                // traits, they are technically known by the context and can still be
                // parsed. A custom error diagnostic will be added later.
                return this.isClassMemberStart(kind);
            case 32768 /* ConstantDeclaration */:
                return kind === TokenKind_1.TokenKind.Identifier;
            case 512 /* SwitchElements */:
            case 1024 /* SwitchBlockElements */:
                return this.isSwitchCaseStart(kind);
            default:
                throw new Parser_1.ParserException('Unhandled parse context');
        }
    };
    // --------------------------------------------------------------------------
    // Token classification
    // --------------------------------------------------------------------------
    /**
     * Determines if a token starts an argument in an invocation expression.
     */
    PhpParser.prototype.isArgumentStart = function (kind) {
        return this.isExpressionStart(kind) || kind === TokenKind_1.TokenKind.Ellipsis;
    };
    /**
     * Determines if a token starts an element within an array.
     */
    PhpParser.prototype.isArrayElementStart = function (kind) {
        return this.isExpressionStart(kind) || kind === TokenKind_1.TokenKind.Ampersand || kind === TokenKind_1.TokenKind.Ellipsis;
    };
    /**
     * Determines if a token represents an assignment operation.
     */
    PhpParser.prototype.isAssignmentOperator = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.AndEqual:
            case TokenKind_1.TokenKind.CoalesceEqual:
            case TokenKind_1.TokenKind.ConcatEqual:
            case TokenKind_1.TokenKind.DivideEqual:
            case TokenKind_1.TokenKind.Equal:
            case TokenKind_1.TokenKind.MinusEqual:
            case TokenKind_1.TokenKind.ModEqual:
            case TokenKind_1.TokenKind.MultiplyEqual:
            case TokenKind_1.TokenKind.OrEqual:
            case TokenKind_1.TokenKind.PlusEqual:
            case TokenKind_1.TokenKind.PowEqual:
            case TokenKind_1.TokenKind.ShiftLeftEqual:
            case TokenKind_1.TokenKind.ShiftRightEqual:
            case TokenKind_1.TokenKind.XorEqual:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determines if a token represents a binary operation.
     */
    PhpParser.prototype.isBinaryOperator = function (kind) {
        switch (kind) {
            // Arithmetic operators.
            case TokenKind_1.TokenKind.Asterisk:
            case TokenKind_1.TokenKind.Minus:
            case TokenKind_1.TokenKind.Percent:
            case TokenKind_1.TokenKind.Period:
            case TokenKind_1.TokenKind.Plus:
            case TokenKind_1.TokenKind.Pow:
            case TokenKind_1.TokenKind.Slash:
            // Bitwise operators.
            case TokenKind_1.TokenKind.Ampersand:
            case TokenKind_1.TokenKind.Caret:
            case TokenKind_1.TokenKind.ShiftLeft:
            case TokenKind_1.TokenKind.ShiftRight:
            case TokenKind_1.TokenKind.VerticalBar:
            // Comparison operators.
            case TokenKind_1.TokenKind.Coalesce:
            case TokenKind_1.TokenKind.GreaterThan:
            case TokenKind_1.TokenKind.Inequality:
            case TokenKind_1.TokenKind.IsEqual:
            case TokenKind_1.TokenKind.IsGreaterThanOrEqual:
            case TokenKind_1.TokenKind.IsIdentical:
            case TokenKind_1.TokenKind.IsLessThanOrEqual:
            case TokenKind_1.TokenKind.IsNotEqual:
            case TokenKind_1.TokenKind.IsNotIdentical:
            case TokenKind_1.TokenKind.LessThan:
            case TokenKind_1.TokenKind.Spaceship:
            case TokenKind_1.TokenKind.InstanceOf:
            // Logical operators.
            case TokenKind_1.TokenKind.BooleanAnd:
            case TokenKind_1.TokenKind.BooleanOr:
            case TokenKind_1.TokenKind.LogicalAnd:
            case TokenKind_1.TokenKind.LogicalOr:
            case TokenKind_1.TokenKind.LogicalXor:
                return true;
            default:
                return this.isAssignmentOperator(kind);
        }
    };
    /**
     * Determines if a token is a valid identifier for a class member.
     */
    PhpParser.prototype.isClassMemberIdentifier = function (kind) {
        return kind === TokenKind_1.TokenKind.Identifier || TokenKind_1.TokenKindInfo.isSemiReservedKeyword(kind);
    };
    /**
     * Determines if a token starts a class member declaration.
     */
    PhpParser.prototype.isClassMemberStart = function (kind) {
        return this.isModifier(kind) ||
            kind === TokenKind_1.TokenKind.Const ||
            kind === TokenKind_1.TokenKind.Function ||
            kind === TokenKind_1.TokenKind.Use ||
            kind === TokenKind_1.TokenKind.Var;
    };
    /**
     * Determines if a token starts a class name reference found after an
     * `instanceof` or `new` keyword.
     */
    PhpParser.prototype.isClassNameReferenceStart = function (kind) {
        return this.isNameStart(kind) ||
            kind === TokenKind_1.TokenKind.Dollar ||
            kind === TokenKind_1.TokenKind.Static ||
            kind === TokenKind_1.TokenKind.Variable;
    };
    /**
     * Determines if a token starts a postfix expression within a class name
     * reference.
     */
    PhpParser.prototype.isClassNameReferenceExpressionStart = function (kind) {
        return kind === TokenKind_1.TokenKind.DoubleColon ||
            kind === TokenKind_1.TokenKind.ObjectOperator ||
            kind === TokenKind_1.TokenKind.OpenBrace ||
            kind === TokenKind_1.TokenKind.OpenBracket;
    };
    /**
     * Determines if a token starts a dereference of an object.
     *
     * @see PhpParser.isElementAccessStart()
     */
    PhpParser.prototype.isDereferenceStart = function (kind) {
        return kind === TokenKind_1.TokenKind.DoubleColon ||
            kind === TokenKind_1.TokenKind.ObjectOperator ||
            kind === TokenKind_1.TokenKind.OpenBrace ||
            kind === TokenKind_1.TokenKind.OpenBracket ||
            kind === TokenKind_1.TokenKind.OpenParen;
    };
    /**
     * Determines if a token starts a dereference of a non-object.
     *
     * @see isDereferenceStart()
     */
    PhpParser.prototype.isElementAccessStart = function (kind) {
        return kind === TokenKind_1.TokenKind.OpenBracket || kind === TokenKind_1.TokenKind.OpenBrace;
    };
    /**
     * Determines if a token starts an expression.
     */
    PhpParser.prototype.isExpressionStart = function (kind) {
        switch (kind) {
            // names
            case TokenKind_1.TokenKind.Backslash:
            case TokenKind_1.TokenKind.Identifier: // Includes "parent" and "self".
            case TokenKind_1.TokenKind.Namespace:
            // expression
            case TokenKind_1.TokenKind.Clone:
            case TokenKind_1.TokenKind.Include:
            case TokenKind_1.TokenKind.IncludeOnce:
            case TokenKind_1.TokenKind.New:
            case TokenKind_1.TokenKind.List:
            case TokenKind_1.TokenKind.Require:
            case TokenKind_1.TokenKind.RequireOnce:
            case TokenKind_1.TokenKind.Yield:
            case TokenKind_1.TokenKind.YieldFrom:
            // primary-expression
            case TokenKind_1.TokenKind.Array:
            case TokenKind_1.TokenKind.DNumber:
            case TokenKind_1.TokenKind.Dollar:
            case TokenKind_1.TokenKind.FlexdocTemplate:
            case TokenKind_1.TokenKind.Fn:
            case TokenKind_1.TokenKind.Function:
            case TokenKind_1.TokenKind.HeredocTemplate:
            case TokenKind_1.TokenKind.LNumber:
            case TokenKind_1.TokenKind.OpenBracket:
            case TokenKind_1.TokenKind.OpenParen:
            case TokenKind_1.TokenKind.ShellCommandTemplate:
            case TokenKind_1.TokenKind.Static:
            case TokenKind_1.TokenKind.StringLiteral:
            case TokenKind_1.TokenKind.StringTemplate:
            case TokenKind_1.TokenKind.Variable: // Includes "$this".
            // primary-expression > intrinsic
            case TokenKind_1.TokenKind.Die:
            case TokenKind_1.TokenKind.Empty:
            case TokenKind_1.TokenKind.Eval:
            case TokenKind_1.TokenKind.Exit:
            case TokenKind_1.TokenKind.IsSet:
            case TokenKind_1.TokenKind.Print:
            // unary-expression
            case TokenKind_1.TokenKind.At:
            case TokenKind_1.TokenKind.Decrement:
            case TokenKind_1.TokenKind.Exclamation:
            case TokenKind_1.TokenKind.Increment:
            case TokenKind_1.TokenKind.Minus:
            case TokenKind_1.TokenKind.Plus:
            case TokenKind_1.TokenKind.Tilde:
            // unary-expression > cast-expression
            case TokenKind_1.TokenKind.ArrayCast:
            case TokenKind_1.TokenKind.BinaryCast:
            case TokenKind_1.TokenKind.BoolCast:
            case TokenKind_1.TokenKind.BooleanCast:
            case TokenKind_1.TokenKind.DoubleCast:
            case TokenKind_1.TokenKind.FloatCast:
            case TokenKind_1.TokenKind.IntCast:
            case TokenKind_1.TokenKind.IntegerCast:
            case TokenKind_1.TokenKind.ObjectCast:
            case TokenKind_1.TokenKind.RealCast:
            case TokenKind_1.TokenKind.StringCast:
            case TokenKind_1.TokenKind.UnsetCast:
            // magic-constants
            case TokenKind_1.TokenKind.MagicClass:
            case TokenKind_1.TokenKind.MagicDirectory:
            case TokenKind_1.TokenKind.MagicFile:
            case TokenKind_1.TokenKind.MagicFunction:
            case TokenKind_1.TokenKind.MagicLine:
            case TokenKind_1.TokenKind.MagicMethod:
            case TokenKind_1.TokenKind.MagicNamespace:
            case TokenKind_1.TokenKind.MagicTrait:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determines if the token starts a line within a flexible heredoc.
     */
    PhpParser.prototype.isFlexdocTemplateLineStart = function (kind) {
        return kind === TokenKind_1.TokenKind.StringIndent
            || kind === TokenKind_1.TokenKind.StringTemplateLiteral // For error recovery.
            || this.isStringTemplateElementStart(kind); // For error recovery.
    };
    /**
     * Determines if a token is a valid identifier for a function.
     */
    PhpParser.prototype.isFunctionIdentifier = function (kind) {
        if (kind === TokenKind_1.TokenKind.Identifier) {
            return true;
        }
        // Also allow functions with reserved names if the parser is being used to
        // generate metadata about PHP itself.
        if (TokenKind_1.TokenKindInfo.isSemiReservedKeyword(kind) && this.options.allowReservedNames) {
            return true;
        }
        return false;
    };
    /**
     * Determines if a token starts an expression or nested list deconstruction.
     */
    PhpParser.prototype.isListIntrinsicElementStart = function (kind) {
        // The '&' token is also allowed for error recovery purposes.
        return kind === TokenKind_1.TokenKind.Ampersand || kind === TokenKind_1.TokenKind.List || this.isExpressionStart(kind);
    };
    /**
     * Determines if a token is a type or visibility modifier.
     */
    PhpParser.prototype.isModifier = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.Abstract:
            case TokenKind_1.TokenKind.Final:
            case TokenKind_1.TokenKind.Private:
            case TokenKind_1.TokenKind.Protected:
            case TokenKind_1.TokenKind.Public:
            case TokenKind_1.TokenKind.Static:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determines if a token starts a fully qualified, partially qualified, or
     * relative name.
     */
    PhpParser.prototype.isNameStart = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.Backslash:
            case TokenKind_1.TokenKind.Identifier:
            case TokenKind_1.TokenKind.Namespace:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determines if a token is a non-associative binary operator.
     */
    PhpParser.prototype.isNonAssociative = function (kind) {
        switch (kind) {
            // Comparison.
            case TokenKind_1.TokenKind.GreaterThan:
            case TokenKind_1.TokenKind.InstanceOf:
            case TokenKind_1.TokenKind.IsGreaterThanOrEqual:
            case TokenKind_1.TokenKind.IsLessThanOrEqual:
            case TokenKind_1.TokenKind.LessThan:
            // Equality.
            case TokenKind_1.TokenKind.Inequality:
            case TokenKind_1.TokenKind.IsEqual:
            case TokenKind_1.TokenKind.IsIdentical:
            case TokenKind_1.TokenKind.IsNotEqual:
            case TokenKind_1.TokenKind.IsNotIdentical:
            case TokenKind_1.TokenKind.Spaceship:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determines if a token starts a parameter in a function or method declaration.
     */
    PhpParser.prototype.isParameterStart = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.Ampersand:
            case TokenKind_1.TokenKind.Ellipsis:
            case TokenKind_1.TokenKind.Variable:
            // Allowed for better error recovery.
            case TokenKind_1.TokenKind.Dollar:
                return true;
            default:
                return this.isTypeStart(kind);
        }
    };
    /**
     * Determines if a token starts a property declaration.
     */
    PhpParser.prototype.isPropertyStart = function (kind) {
        return kind === TokenKind_1.TokenKind.Dollar || kind === TokenKind_1.TokenKind.Variable || this.isTypeStart(kind);
    };
    /**
     * Determines if a token is a right-associative *binary* operator.
     */
    PhpParser.prototype.isRightAssociative = function (kind) {
        // Fun fact: PHP's grammar lists assignment operators as left associative,
        // but the LHS of `variable_expr = expr` can't be an assignment expression
        // so they end up being parsed like right associative operators anyways.
        switch (kind) {
            // Arithmetic operators.
            case TokenKind_1.TokenKind.Pow:
            // Assignment operators.
            case TokenKind_1.TokenKind.AndEqual:
            case TokenKind_1.TokenKind.CoalesceEqual:
            case TokenKind_1.TokenKind.ConcatEqual:
            case TokenKind_1.TokenKind.DivideEqual:
            case TokenKind_1.TokenKind.Equal:
            case TokenKind_1.TokenKind.MinusEqual:
            case TokenKind_1.TokenKind.ModEqual:
            case TokenKind_1.TokenKind.MultiplyEqual:
            case TokenKind_1.TokenKind.OrEqual:
            case TokenKind_1.TokenKind.PlusEqual:
            case TokenKind_1.TokenKind.PowEqual:
            case TokenKind_1.TokenKind.ShiftLeftEqual:
            case TokenKind_1.TokenKind.ShiftRightEqual:
            case TokenKind_1.TokenKind.XorEqual:
            // Comparison operators.
            case TokenKind_1.TokenKind.Coalesce:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determines if a token starts a declaration or statement within a
     * `compound-statement`.
     */
    PhpParser.prototype.isStatementBlockStart = function (kind) {
        switch (kind) {
            // Allowed for better error recovery.
            case TokenKind_1.TokenKind.HaltCompiler:
            // Declaration statements.
            case TokenKind_1.TokenKind.Abstract:
            case TokenKind_1.TokenKind.Class:
            case TokenKind_1.TokenKind.Final:
            case TokenKind_1.TokenKind.Function:
            case TokenKind_1.TokenKind.Interface:
            case TokenKind_1.TokenKind.Trait:
                return true;
            default:
                return this.isStatementStart(kind);
        }
    };
    /**
     * Determines if a token is a semicolon or close tag.
     */
    PhpParser.prototype.isStatementEnd = function (kind) {
        return kind === TokenKind_1.TokenKind.Semicolon || kind === TokenKind_1.TokenKind.CloseTag;
    };
    /**
     * Determines if a token is the start of a statement.
     */
    PhpParser.prototype.isStatementStart = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.Break:
            case TokenKind_1.TokenKind.CloseTag: // Equivalent to a semicolon.
            case TokenKind_1.TokenKind.Continue:
            case TokenKind_1.TokenKind.Declare:
            case TokenKind_1.TokenKind.Do:
            case TokenKind_1.TokenKind.Echo:
            case TokenKind_1.TokenKind.For:
            case TokenKind_1.TokenKind.ForEach:
            case TokenKind_1.TokenKind.Global:
            case TokenKind_1.TokenKind.GoTo:
            case TokenKind_1.TokenKind.Identifier:
            case TokenKind_1.TokenKind.If:
            case TokenKind_1.TokenKind.InlineText: // Echo statement.
            case TokenKind_1.TokenKind.OpenBrace:
            case TokenKind_1.TokenKind.OpenTagWithEcho: // Echo statement.
            case TokenKind_1.TokenKind.Return:
            case TokenKind_1.TokenKind.Semicolon: // Expression statement.
            case TokenKind_1.TokenKind.Static:
            case TokenKind_1.TokenKind.Switch:
            case TokenKind_1.TokenKind.Throw:
            case TokenKind_1.TokenKind.Try:
            case TokenKind_1.TokenKind.Unset:
            case TokenKind_1.TokenKind.While:
                return true;
            default:
                return this.isExpressionStart(kind);
        }
    };
    /**
     * Determines if a token ends a string template.
     */
    PhpParser.prototype.isStringTemplateEnd = function (kind, terminator) {
        return kind === terminator || kind === TokenKind_1.TokenKind.EOF;
    };
    /**
     * Determines if a token starts a variable offset within an interpolated
     * element access expression.
     */
    PhpParser.prototype.isStringTemplateVariableOffset = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.Identifier:
            case TokenKind_1.TokenKind.StringNumber:
            case TokenKind_1.TokenKind.Variable:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determines if a token is the start of an interpolation within a string
     * template.
     */
    PhpParser.prototype.isStringTemplateElementStart = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.DollarOpenBrace:
            case TokenKind_1.TokenKind.OpenBrace:
            case TokenKind_1.TokenKind.Variable:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determines if a token starts a branch within a switch statement.
     */
    PhpParser.prototype.isSwitchCaseStart = function (kind) {
        return kind === TokenKind_1.TokenKind.Case || kind === TokenKind_1.TokenKind.Default;
    };
    /**
     * Determines if a token is the start of a top-level statement, which
     * includes other statements and expressions.
     */
    PhpParser.prototype.isTopStatementStart = function (kind) {
        switch (kind) {
            // Allowed for a better error recovery.
            case TokenKind_1.TokenKind.Private:
            case TokenKind_1.TokenKind.Protected:
            case TokenKind_1.TokenKind.Public:
            // Generic declarations and statements.
            case TokenKind_1.TokenKind.Const:
            case TokenKind_1.TokenKind.HaltCompiler:
            case TokenKind_1.TokenKind.Namespace:
            case TokenKind_1.TokenKind.Use:
            // Type declaration statements.
            case TokenKind_1.TokenKind.Abstract:
            case TokenKind_1.TokenKind.Class:
            case TokenKind_1.TokenKind.Final:
            case TokenKind_1.TokenKind.Function:
            case TokenKind_1.TokenKind.Interface:
            case TokenKind_1.TokenKind.Trait:
                return true;
            default:
                return this.isStatementStart(kind);
        }
    };
    /**
     * Determines if a token starts a class or method name.
     */
    PhpParser.prototype.isTraitAdaptationStart = function (kind) {
        return this.isNameStart(kind) || TokenKind_1.TokenKindInfo.isSemiReservedKeyword(kind);
    };
    /**
     * Determines if a token is a predefined type or starts a user-defined type.
     */
    PhpParser.prototype.isTypeStart = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.Array:
            case TokenKind_1.TokenKind.Callable:
            case TokenKind_1.TokenKind.Question:
                return true;
            default:
                return this.isNameStart(kind);
        }
    };
    /**
     * Determines if a token represents a unary operation.
     */
    PhpParser.prototype.isUnaryOperator = function (kind) {
        switch (kind) {
            // Arithmatic operators.
            case TokenKind_1.TokenKind.Decrement:
            case TokenKind_1.TokenKind.Increment:
            case TokenKind_1.TokenKind.Minus:
            case TokenKind_1.TokenKind.Plus:
            // Bitwise and logical not operators.
            case TokenKind_1.TokenKind.Exclamation:
            case TokenKind_1.TokenKind.Tilde:
            // Cast operators.
            case TokenKind_1.TokenKind.ArrayCast:
            case TokenKind_1.TokenKind.BinaryCast:
            case TokenKind_1.TokenKind.BoolCast:
            case TokenKind_1.TokenKind.BooleanCast:
            case TokenKind_1.TokenKind.DoubleCast:
            case TokenKind_1.TokenKind.FloatCast:
            case TokenKind_1.TokenKind.IntCast:
            case TokenKind_1.TokenKind.IntegerCast:
            case TokenKind_1.TokenKind.ObjectCast:
            case TokenKind_1.TokenKind.RealCast:
            case TokenKind_1.TokenKind.StringCast:
            case TokenKind_1.TokenKind.UnsetCast:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determines if a token starts a type, function, or constant import.
     */
    PhpParser.prototype.isUseGroupElementStart = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.Const:
            case TokenKind_1.TokenKind.Function:
            case TokenKind_1.TokenKind.Identifier:
                return true;
            default:
                return false;
        }
    };
    // --------------------------------------------------------------------------
    // List generation
    // --------------------------------------------------------------------------
    /**
     * Parses a list of elements separated by a delimiter.
     */
    PhpParser.prototype.parseDelimitedList = function (context, delimiter, terminator) {
        var savedContext = this.currentContext;
        this.addParseContext(context);
        var nodes = [];
        nodes.push(this.parseElement(context));
        // @todo Redesign the delimeter and terminator parameters into callbacks?
        while (this.currentToken.kind !== terminator && this.currentToken.kind !== TokenKind_1.TokenKind.EOF) {
            if (this.currentToken.kind === delimiter || this.tokenStartsContext(context, this.currentToken.kind)) {
                nodes.push(this.eat(delimiter));
                nodes.push(this.parseElement(context));
                continue;
            }
            if (this.isTokenValidInContexts(this.currentToken.kind)) {
                break;
            }
            this.skipToken();
        }
        this.currentContext = savedContext;
        return this.factory.createList(nodes);
    };
    /**
     * Parses a element based on the given context.
     */
    PhpParser.prototype.parseElement = function (context) {
        switch (context) {
            case 0 /* SourceElements */:
            case 4 /* NamespaceElements */:
                return this.parseSourceElement();
            case 2048 /* CaseClauseElements */:
            case 8 /* DeclareBlockElements */:
            case 16 /* ForBlockElements */:
            case 32 /* ForEachBlockElements */:
            case 64 /* IfBlockElements */:
            case 128 /* IfElseBlockElements */:
            case 2 /* CompoundStatementElements */:
            case 256 /* WhileBlockElements */:
                return this.parseStatementBlockElement();
            case 32768 /* ConstantDeclaration */:
                return this.parseConstantElement();
            default:
                throw new Parser_1.ParserException('Unhandled parse context');
        }
    };
    /**
     * Parses a list of elements based on the given context.
     */
    PhpParser.prototype.parseList = function (context) {
        var savedContext = this.currentContext;
        this.addParseContext(context);
        var nodes = [];
        while (!this.tokenEndsContext(context, this.currentToken.kind)) {
            if (this.tokenStartsContext(context, this.currentToken.kind)) {
                nodes.push(this.parseElement(context));
                continue;
            }
            // Check if a parent context knows what to do with this token.
            if (this.isTokenValidInContexts(this.currentToken.kind)) {
                break;
            }
            // Skip the token since none of the contexts know what to do.
            this.skipToken();
        }
        this.currentContext = savedContext;
        return nodes.length > 0 ? this.factory.createList(nodes) : null;
    };
    /**
     * Parses a nested statement.
     */
    PhpParser.prototype.parseStatementBlockElement = function () {
        switch (this.currentToken.kind) {
            case TokenKind_1.TokenKind.Abstract:
            case TokenKind_1.TokenKind.Class:
            case TokenKind_1.TokenKind.Final:
                return this.parseClassDeclaration();
            case TokenKind_1.TokenKind.Function:
                return this.parseExpressionOrTopStatement();
            case TokenKind_1.TokenKind.HaltCompiler:
                var haltCompiler = this.parseHaltCompiler();
                return this.addError(haltCompiler, ErrorCode_Generated_1.ErrorCode.ERR_HaltCompilerScope);
            case TokenKind_1.TokenKind.Interface:
                return this.parseInterfaceDeclaration();
            case TokenKind_1.TokenKind.Trait:
                return this.parseTraitDeclaration();
            default:
                return this.parseStatement();
        }
    };
    /**
     * Parses a top-level statement.
     */
    PhpParser.prototype.parseSourceElement = function () {
        switch (this.currentToken.kind) {
            case TokenKind_1.TokenKind.Abstract:
            case TokenKind_1.TokenKind.Class:
            case TokenKind_1.TokenKind.Final:
            // If the user is coming from a language like C# that allows 'public' on
            // top-level classes (or any modifier on nested classes), then allow
            // visibility modifier tokens so that a custom error message can be added.
            case TokenKind_1.TokenKind.Private:
            case TokenKind_1.TokenKind.Protected:
            case TokenKind_1.TokenKind.Public:
                return this.parseClassDeclaration();
            case TokenKind_1.TokenKind.Const:
                return this.parseConstantDeclaration();
            case TokenKind_1.TokenKind.Function:
                // @todo Test: Required trailing ';' if expression.
                return this.parseExpressionOrTopStatement();
            case TokenKind_1.TokenKind.HaltCompiler:
                var haltCompiler = this.parseHaltCompiler();
                if (!haltCompiler.containsDiagnostics) {
                    this.forceEndOfFile();
                }
                return haltCompiler;
            case TokenKind_1.TokenKind.Interface:
                return this.parseInterfaceDeclaration();
            case TokenKind_1.TokenKind.Namespace:
                // @todo Test: Required trailing ';' if expression.
                return this.parseExpressionOrTopStatement();
            case TokenKind_1.TokenKind.Trait:
                return this.parseTraitDeclaration();
            case TokenKind_1.TokenKind.Use:
                return this.parseUseDeclaration();
            default:
                return this.parseStatement();
        }
    };
    // --------------------------------------------------------------------------
    // Productions (statements)
    // --------------------------------------------------------------------------
    /**
     * Parses a statement.
     */
    PhpParser.prototype.parseStatement = function () {
        switch (this.currentToken.kind) {
            // Statements (keywords).
            case TokenKind_1.TokenKind.Break:
                // @todo Add error when not in loop or switch.
                return this.parseBreak();
            case TokenKind_1.TokenKind.Continue:
                // @todo Add error when not in loop or switch.
                return this.parseContinue();
            case TokenKind_1.TokenKind.Declare:
                return this.parseDeclare();
            case TokenKind_1.TokenKind.Do:
                return this.parseDoWhile();
            case TokenKind_1.TokenKind.Echo:
                return this.parseEcho();
            case TokenKind_1.TokenKind.For:
                return this.parseFor();
            case TokenKind_1.TokenKind.ForEach:
                return this.parseForEach();
            case TokenKind_1.TokenKind.Global:
                return this.parseGlobal();
            case TokenKind_1.TokenKind.GoTo:
                return this.parseGoTo();
            case TokenKind_1.TokenKind.Identifier:
                return this.parseExpressionOrTopStatement();
            case TokenKind_1.TokenKind.If:
                return this.parseIf();
            case TokenKind_1.TokenKind.Return:
                return this.parseReturn();
            case TokenKind_1.TokenKind.Static:
                return this.parseExpressionOrTopStatement();
            case TokenKind_1.TokenKind.Switch:
                return this.parseSwitch();
            case TokenKind_1.TokenKind.Throw:
                return this.parseThrow();
            case TokenKind_1.TokenKind.Try:
                return this.parseTry();
            case TokenKind_1.TokenKind.Unset:
                return this.parseUnset();
            case TokenKind_1.TokenKind.While:
                return this.parseWhile();
            // Statements (other).
            case TokenKind_1.TokenKind.InlineText:
                return this.parseInlineText();
            case TokenKind_1.TokenKind.OpenBrace:
                return this.parseStatementBlock();
            case TokenKind_1.TokenKind.OpenTagWithEcho:
                return this.parseEcho();
            case TokenKind_1.TokenKind.CloseTag:
            case TokenKind_1.TokenKind.Semicolon:
                var semicolon = this.parseStatementEnd();
                return new Node_Generated_1.ExpressionStatementNode(null, semicolon);
            // Expressions.
            default:
                if (this.isExpressionStart(this.currentToken.kind)) {
                    var expr = this.parseExpression();
                    var exprSemicolon = this.parseStatementEnd();
                    return new Node_Generated_1.ExpressionStatementNode(expr, exprSemicolon);
                }
                // Missing call to isStatementStart()?
                throw new Parser_1.ParserException('Unhandled token while attempting to parse statement');
        }
    };
    /**
     * Parses a break statement.
     *
     * Syntax: `BREAK optional-expr ;`
     */
    PhpParser.prototype.parseBreak = function () {
        var breakKeyword = this.eat(TokenKind_1.TokenKind.Break);
        var depth = null;
        if (this.isExpressionStart(this.currentToken.kind)) {
            depth = this.parseBreakOrContinueDepth(TokenKind_1.TokenKind.Break);
        }
        var semicolon = !this.isStatementEnd(this.currentToken.kind) && depth === null
            ? this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, ErrorCode_Generated_1.ErrorCode.ERR_IterationDepthOrSemicolonExpected)
            : this.parseStatementEnd();
        return new Node_Generated_1.BreakNode(breakKeyword, depth, semicolon);
    };
    /**
     * Parses the iteration depth of a `break` or `continue` statement.
     *
     * Syntax: `expr`
     *
     * This syntax is only for compatibility purposes. The node should actually
     * be equivalent to `LNUMBER` or `( LNUMBER )`.
     */
    PhpParser.prototype.parseBreakOrContinueDepth = function (keyword) {
        // The caller should have checked if the depth exists.
        php_common_1.Debug.assert(this.isExpressionStart(this.currentToken.kind));
        if (this.currentToken.kind === TokenKind_1.TokenKind.LNumber) {
            var expr_1 = this.parseExpression();
            // The integer may have been part of a larger expression.
            if (!(expr_1 instanceof Node_Generated_1.LiteralNode)) {
                expr_1 = this.addError(expr_1, ErrorCode_Generated_1.ErrorCode.ERR_InvalidIterationDepth, TokenKind_1.TokenKindInfo.getText(keyword));
            }
            return expr_1;
        }
        // Technically, the iteration depth should strictly be an integer, but due
        // to a quirk in how PHP is parsed, the parentheses in an expression group
        // are ignored, so if the inner expression is an integer, it is also valid.
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
            var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
            // Suppress TS2365: Current token changed after previous method call.
            var isInteger = this.currentToken.kind === TokenKind_1.TokenKind.LNumber;
            var expr_2 = this.parseExpression();
            if (!isInteger || !(expr_2 instanceof Node_Generated_1.LiteralNode)) {
                expr_2 = this.addError(expr_2, ErrorCode_Generated_1.ErrorCode.ERR_InvalidIterationDepth, TokenKind_1.TokenKindInfo.getText(keyword));
            }
            var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
            // Any additional operators cannot be part of a constant expression, so
            // by this point a semicolon should be expected, even though the
            // positioning will probably seem weird to most users.
            return new Node_Generated_1.ExpressionGroupNode(openParen, expr_2, closeParen);
        }
        // While nothing else is valid, the diagnostic message (and recovery in
        // general) is better if a full expression is parsed instead of only
        // accepting the next token.
        //
        //   break 1 + 1;
        //         ~       Error: ';' expected
        //
        //   break 1 + 1;
        //         ~~~~~   Error: Iteration depth in 'break' statement must be an integer.
        //
        var expr = this.parseExpression();
        return this.addError(expr, ErrorCode_Generated_1.ErrorCode.ERR_InvalidIterationDepth, TokenKind_1.TokenKindInfo.getText(keyword));
    };
    /**
     * Parses a list of class constants.
     *
     * Syntax: `visibility-modifier CONST const-elements ;`
     *
     * Where `const-elements` is:
     * - `const-elements , const-element`
     * - `const-element`
     */
    PhpParser.prototype.parseClassConstantDeclaration = function (modifiers, context) {
        for (var i = 0; i < modifiers.length; i++) {
            var modifier = this.getModifierFlag(modifiers[i].kind);
            if (modifier & ModifierFlags_1.ModifierFlags.VisibilityMask) {
                if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_1)) {
                    modifiers[i] = this.addError(modifiers[i], ErrorCode_Generated_1.ErrorCode.ERR_FeatureClassConstantModifiers);
                }
            }
            else {
                modifiers[i] = this.addError(modifiers[i], ErrorCode_Generated_1.ErrorCode.ERR_BadConstantModifier);
            }
        }
        var nodes = [];
        var constKeyword = this.eat(TokenKind_1.TokenKind.Const);
        if (context === 16384 /* TraitMembers */) {
            constKeyword = this.addError(constKeyword, ErrorCode_Generated_1.ErrorCode.ERR_TraitConstant);
        }
        // const savedContext = this.currentContext;
        // this.addParseContext(ParseContext.ClassConstantDeclaration);
        nodes.push(this.parseClassConstantElement());
        // @todo Use parseDelimitedList() instead?
        // @todo See also: skipBadParameterListTokens()
        while (this.currentToken.kind !== TokenKind_1.TokenKind.EOF && this.currentToken.kind !== TokenKind_1.TokenKind.Semicolon) {
            if (this.currentToken.kind === TokenKind_1.TokenKind.Comma || this.isClassMemberIdentifier(this.currentToken.kind)) {
                nodes.push(this.eat(TokenKind_1.TokenKind.Comma));
                nodes.push(this.parseClassConstantElement());
                continue;
            }
            if (this.isTokenValidInContexts(this.currentToken.kind)) {
                break;
            }
            this.skipToken();
        }
        // this.currentContext = savedContext;
        var semicolon = this.parseStatementEnd();
        return new Node_Generated_1.ClassConstantDeclarationNode(modifiers.length > 0 ? this.factory.createList(modifiers) : null, constKeyword, this.factory.createList(nodes), semicolon);
    };
    /**
     * Parses a single constant within a class constant declaration.
     *
     * Syntax: `member-name = expression`
     */
    PhpParser.prototype.parseClassConstantElement = function () {
        // Technically, this error code is incorrect as identifiers or semi-reserved
        // keywords are allowed, but if that were mentioned in the error message,
        // users would be unlikely to know what those keywords are anyways.
        var identifier = this.parseClassMemberName(ErrorCode_Generated_1.ErrorCode.ERR_IdentifierExpected);
        // Unlike other class members, the keyword 'class' is fully reserved for
        // class constants, as any expressions using it would conflict with class
        // name resolution (::class).
        if (identifier.kind === TokenKind_1.TokenKind.Class) {
            identifier = this.addError(identifier, ErrorCode_Generated_1.ErrorCode.ERR_IdentifierExpectedKeyword, TokenKind_1.TokenKindInfo.getText(TokenKind_1.TokenKind.Class));
        }
        var equal = this.eat(TokenKind_1.TokenKind.Equal);
        var expression = this.parseExpression();
        return new Node_Generated_1.ClassConstantElementNode(identifier, equal, expression);
    };
    /**
     * Parses a class declaration statement.
     *
     * Syntax: `class-modifier CLASS IDENTIFIER class-base-clause class-interface-clause { class-member-declarations }`
     *
     * Where `class-base-clause` is:
     * - `EXTENDS qualified-name`
     *
     * Where `class-interface-clause` is:
     * - `IMPLEMENTS qualified-name-list`
     */
    PhpParser.prototype.parseClassDeclaration = function () {
        var modifiers = this.parseClassModifiers();
        var classKeyword = this.eat(TokenKind_1.TokenKind.Class);
        var identifier = this.eat(TokenKind_1.TokenKind.Identifier);
        var extendsKeyword = this.eatOptional(TokenKind_1.TokenKind.Extends);
        var baseType = null;
        if (extendsKeyword !== null) {
            baseType = this.parseTypeName();
            if (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
                // @todo Skip all remaining types in the base clause?
                //
                // class A extends B, C {}
                //                  ~~~
                //
                this.skipTokenWithError(ErrorCode_Generated_1.ErrorCode.ERR_MultipleInheritance);
            }
        }
        var implementsKeyword = this.eatOptional(TokenKind_1.TokenKind.Implements);
        var interfaces = null;
        if (implementsKeyword !== null) {
            interfaces = this.parseQualifiedNameList();
            if (this.currentToken.kind === TokenKind_1.TokenKind.Extends && extendsKeyword === null) {
                this.skipTokenWithError(ErrorCode_Generated_1.ErrorCode.ERR_BaseClauseAfterImplements);
            }
        }
        var openBrace;
        if (this.currentToken.kind !== TokenKind_1.TokenKind.OpenBrace) {
            if (implementsKeyword === null) {
                var code = extendsKeyword ? ErrorCode_Generated_1.ErrorCode.ERR_IncompleteClassDeclarationWithExtends : ErrorCode_Generated_1.ErrorCode.ERR_IncompleteClassDeclaration;
                openBrace = this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenBrace, code);
            }
            else {
                openBrace = this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenBrace, ErrorCode_Generated_1.ErrorCode.ERR_CommaOrOpenBraceExpected);
            }
        }
        else {
            openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
        }
        var members = null;
        if (!identifier.isMissing && !openBrace.isMissing) {
            members = this.parseClassMembers(4096 /* ClassMembers */);
        }
        // If the opening brace is missing, then create a missing close brace as
        // well since the next close brace is most likely part of another block.
        //
        // namespace {
        //   class | <-- cursor here
        // }
        //
        var closeBrace = openBrace.isMissing
            ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
            : this.eat(TokenKind_1.TokenKind.CloseBrace);
        return new Node_Generated_1.ClassDeclarationNode(modifiers, classKeyword, identifier, extendsKeyword, baseType, implementsKeyword, interfaces, openBrace, members, closeBrace);
    };
    /**
     * Parses a list of member declarations within a type declaration.
     */
    PhpParser.prototype.parseClassMembers = function (context) {
        var savedContext = this.currentContext;
        this.addParseContext(context);
        var varKeyword; // Do not move, method optimization.
        var members = [];
        while (!this.tokenEndsContext(context, this.currentToken.kind)) {
            if (this.tokenStartsContext(context, this.currentToken.kind)) {
                switch (this.currentToken.kind) {
                    case TokenKind_1.TokenKind.Const:
                        members.push(this.parseClassConstantDeclaration([], context));
                        break;
                    case TokenKind_1.TokenKind.Function:
                        members.push(this.parseMethodDeclaration([], ModifierFlags_1.ModifierFlags.None, context));
                        break;
                    case TokenKind_1.TokenKind.Use:
                        members.push(this.parseTraitUse(context));
                        break;
                    case TokenKind_1.TokenKind.Var:
                        varKeyword = this.eat(TokenKind_1.TokenKind.Var);
                        members.push(this.parsePropertyDeclaration([varKeyword], context));
                        break;
                    default:
                        // Modifier tokens.
                        members.push(this.parseClassMemberDeclaration(context));
                        break;
                }
            }
            else {
                // If an error occurs in a declaration or statement above a method
                // declaration, then its opening brace would normally be skipped,
                // which would then cause its closing brace to be treated as part of
                // the class declaration.
                this.skipBadMemberTokens();
            }
        }
        this.currentContext = savedContext;
        return members.length > 0 ? this.factory.createList(members) : null;
    };
    /**
     * @todo Document parseClassMemberDeclaration().
     */
    PhpParser.prototype.parseClassMemberDeclaration = function (context) {
        // Anything that is not a modifier should have been handled by the caller.
        php_common_1.Debug.assert(this.getModifierFlag(this.currentToken.kind) !== ModifierFlags_1.ModifierFlags.None);
        var modifiers = [];
        var modifierFlags = this.parseClassMemberModifiers(modifiers, context);
        if (this.currentToken.kind === TokenKind_1.TokenKind.Const) {
            return this.parseClassConstantDeclaration(modifiers, context);
        }
        if (this.currentToken.kind === TokenKind_1.TokenKind.Function) {
            return this.parseMethodDeclaration(modifiers, modifierFlags, context);
        }
        if (this.isPropertyStart(this.currentToken.kind)) {
            return this.parsePropertyDeclaration(modifiers, context);
        }
        var code;
        if (context === 4096 /* ClassMembers */) {
            code = ErrorCode_Generated_1.ErrorCode.ERR_ClassMemberExpected;
        }
        else {
            code = context === 8192 /* InterfaceMembers */ ? ErrorCode_Generated_1.ErrorCode.ERR_InterfaceMemberExpected : ErrorCode_Generated_1.ErrorCode.ERR_TraitMemberExpected;
        }
        modifiers[modifiers.length - 1] = this.addError(modifiers[modifiers.length - 1], code);
        return new Node_Generated_1.IncompleteMemberNode(this.factory.createList(modifiers));
    };
    /**
     * Parses the modifiers of a class member declaration.
     */
    PhpParser.prototype.parseClassMemberModifiers = function (tokens, context) {
        var modifiers = ModifierFlags_1.ModifierFlags.None;
        var flag = this.getModifierFlag(this.currentToken.kind);
        while (flag !== ModifierFlags_1.ModifierFlags.None) {
            var keyword = this.eat(this.currentToken.kind);
            if (modifiers & flag) {
                keyword = this.addError(keyword, ErrorCode_Generated_1.ErrorCode.ERR_DuplicateModifier, TokenKind_1.TokenKindInfo.getText(keyword.kind));
            }
            else if (context === 8192 /* InterfaceMembers */ && (flag === ModifierFlags_1.ModifierFlags.Abstract || flag === ModifierFlags_1.ModifierFlags.Final)) {
                keyword = this.addError(keyword, ErrorCode_Generated_1.ErrorCode.ERR_BadInterfaceModifier);
            }
            else {
                if (flag & ModifierFlags_1.ModifierFlags.VisibilityMask) {
                    if (modifiers & ModifierFlags_1.ModifierFlags.VisibilityMask) {
                        keyword = this.addError(keyword, ErrorCode_Generated_1.ErrorCode.ERR_MultipleVisibilityModifiers, TokenKind_1.TokenKindInfo.getText(keyword.kind));
                    }
                    if (flag !== ModifierFlags_1.ModifierFlags.Public && context === 8192 /* InterfaceMembers */) {
                        keyword = this.addError(keyword, ErrorCode_Generated_1.ErrorCode.ERR_InterfaceMemberNotPublic);
                    }
                }
                if (modifiers & ModifierFlags_1.ModifierFlags.Abstract || modifiers & ModifierFlags_1.ModifierFlags.Final) {
                    // Since this token cannot be a duplicate, it must be the other.
                    if (flag === ModifierFlags_1.ModifierFlags.Abstract || flag === ModifierFlags_1.ModifierFlags.Final) {
                        keyword = this.addError(keyword, ErrorCode_Generated_1.ErrorCode.ERR_AbstractMemberIsFinal);
                    }
                }
                if (this.isAbstractAndPrivate(modifiers, flag)) {
                    keyword = this.addError(keyword, ErrorCode_Generated_1.ErrorCode.ERR_AbstractMemberIsPrivate);
                }
            }
            modifiers = modifiers | flag;
            tokens.push(keyword);
            flag = this.getModifierFlag(this.currentToken.kind);
        }
        return modifiers;
    };
    /**
     * Parses a class member name.
     *
     * Syntax: `member-name`
     *
     * Where `member-name` is:
     * - `IDENTIFIER`
     * - `semi-reserved-keyword`
     */
    PhpParser.prototype.parseClassMemberName = function (code) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var member = this.isClassMemberIdentifier(this.currentToken.kind)
            ? this.eat(this.currentToken.kind)
            : this.createMissingTokenWithError.apply(this, __spreadArray([TokenKind_1.TokenKind.Identifier, code], __read(args)));
        return member;
    };
    /**
     * Parses the modifiers of a class declaration.
     *
     * All modifiers except `abstract` and `final` will generate a diagnostic.
     */
    PhpParser.prototype.parseClassModifiers = function () {
        var tokens = [];
        var modifiers = ModifierFlags_1.ModifierFlags.None;
        var flag = this.getModifierFlag(this.currentToken.kind);
        while (flag !== ModifierFlags_1.ModifierFlags.None) {
            var keyword = this.eat(this.currentToken.kind);
            if (modifiers & flag) {
                keyword = this.addError(keyword, ErrorCode_Generated_1.ErrorCode.ERR_DuplicateModifier, TokenKind_1.TokenKindInfo.getText(keyword.kind));
            }
            else if (flag & ModifierFlags_1.ModifierFlags.VisibilityMask || flag === ModifierFlags_1.ModifierFlags.Static) {
                keyword = this.addError(keyword, ErrorCode_Generated_1.ErrorCode.ERR_BadTypeModifier, TokenKind_1.TokenKindInfo.getText(keyword.kind));
            }
            else if (modifiers & ModifierFlags_1.ModifierFlags.Abstract || modifiers & ModifierFlags_1.ModifierFlags.Final) {
                // Since this token cannot be a duplicate, it must be the other.
                if (flag === ModifierFlags_1.ModifierFlags.Abstract || flag === ModifierFlags_1.ModifierFlags.Final) {
                    keyword = this.addError(keyword, ErrorCode_Generated_1.ErrorCode.ERR_AbstractClassIsFinal);
                }
            }
            modifiers = modifiers | flag;
            tokens.push(keyword);
            flag = this.getModifierFlag(this.currentToken.kind);
        }
        return tokens.length > 0 ? this.factory.createList(tokens) : null;
    };
    /**
     * Parses a constant declaration statement.
     *
     * Syntax: `CONST const-list ;`
     *
     * Where `const-list` is:
     * - `const-list , const-element`
     * - `const-element`
     */
    PhpParser.prototype.parseConstantDeclaration = function () {
        var constKeyword = this.eat(TokenKind_1.TokenKind.Const);
        var constants = this.parseDelimitedList(32768 /* ConstantDeclaration */, TokenKind_1.TokenKind.Comma, TokenKind_1.TokenKind.Semicolon);
        var semicolon = this.isStatementEnd(this.currentToken.kind)
            ? this.parseStatementEnd()
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, ErrorCode_Generated_1.ErrorCode.ERR_CommaOrSemicolonExpected);
        return new Node_Generated_1.ConstantDeclarationNode(constKeyword, constants, semicolon);
    };
    /**
     * Parses a single constant from a constant declaration statement.
     *
     * Syntax: `IDENTIFIER = expression`
     */
    PhpParser.prototype.parseConstantElement = function () {
        var identifier = this.eat(TokenKind_1.TokenKind.Identifier);
        var equal = this.eat(TokenKind_1.TokenKind.Equal);
        // If the user is adding a constant and the identifier and '=' are missing
        // then the next expression may not be part of the assignment.
        //
        //   const A = 1,|  <-- cursor here
        //   $i++;
        //
        // In this case, simply create an artificial expression.
        var expression;
        if (identifier.isMissing && equal.isMissing) {
            var literal = this.createMissingToken(TokenKind_1.TokenKind.LNumber, this.currentToken.kind, false);
            expression = new Node_Generated_1.LiteralNode(literal);
        }
        else {
            expression = this.parseExpression();
        }
        return new Node_Generated_1.ConstantElementNode(identifier, equal, expression);
    };
    /**
     * Parses a continue statement.
     *
     * Syntax: `CONTINUE optional-expr ;`
     */
    PhpParser.prototype.parseContinue = function () {
        var continueKeyword = this.eat(TokenKind_1.TokenKind.Continue);
        var depth = null;
        if (this.isExpressionStart(this.currentToken.kind)) {
            depth = this.parseBreakOrContinueDepth(TokenKind_1.TokenKind.Continue);
        }
        var semicolon = !this.isStatementEnd(this.currentToken.kind) && depth === null
            ? this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, ErrorCode_Generated_1.ErrorCode.ERR_IterationDepthOrSemicolonExpected)
            : this.parseStatementEnd();
        return new Node_Generated_1.ContinueNode(continueKeyword, depth, semicolon);
    };
    /**
     * Parses a declare statement.
     *
     * Syntax:
     * - `DECLARE ( const-list ) statement`
     * - `DECLARE ( const-list ) : statement-list ENDDECLARE ;`
     */
    PhpParser.prototype.parseDeclare = function () {
        var declareKeyword = this.eat(TokenKind_1.TokenKind.Declare);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var directives = [];
        directives.push(this.parseConstantElement());
        // @todo Use parseDelimitedList() instead?
        while (this.currentToken.kind !== TokenKind_1.TokenKind.EOF && this.currentToken.kind !== TokenKind_1.TokenKind.CloseParen) {
            if (this.currentToken.kind === TokenKind_1.TokenKind.Comma || this.currentToken.kind === TokenKind_1.TokenKind.Identifier) {
                directives.push(this.eat(TokenKind_1.TokenKind.Comma));
                directives.push(this.parseConstantElement());
                continue;
            }
            if (this.isTokenValidInContexts(this.currentToken.kind)) {
                break;
            }
            this.skipToken();
        }
        var closeParen = this.currentToken.kind === TokenKind_1.TokenKind.CloseParen
            ? this.eat(TokenKind_1.TokenKind.CloseParen)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, ErrorCode_Generated_1.ErrorCode.ERR_CommaOrCloseParenExpected);
        // Alternate syntax.
        if (this.currentToken.kind === TokenKind_1.TokenKind.Colon) {
            var colon = this.eat(TokenKind_1.TokenKind.Colon);
            var statements = this.parseList(8 /* DeclareBlockElements */);
            var endDeclare = this.eat(TokenKind_1.TokenKind.EndDeclare);
            var semicolon = this.parseStatementEnd();
            return new Node_Generated_1.DeclareBlockNode(declareKeyword, openParen, this.factory.createList(directives), closeParen, colon, statements, endDeclare, semicolon);
        }
        var statement = this.parseEmbeddedStatement(false, ErrorCode_Generated_1.ErrorCode.ERR_StatementOrColonExpected);
        return new Node_Generated_1.DeclareNode(declareKeyword, openParen, this.factory.createList(directives), closeParen, statement);
    };
    /**
     * Parses a do-while statement.
     *
     * Syntax: `DO statement WHILE ( expression ) ;`
     */
    PhpParser.prototype.parseDoWhile = function () {
        var doKeyword = this.eat(TokenKind_1.TokenKind.Do);
        var statement = this.parseEmbeddedStatement(false, ErrorCode_Generated_1.ErrorCode.ERR_StatementExpected);
        var whileKeyword = this.eat(TokenKind_1.TokenKind.While);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var condition = this.parseExpression();
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        var semicolon = this.parseStatementEnd();
        return new Node_Generated_1.DoWhileNode(doKeyword, statement, whileKeyword, openParen, condition, closeParen, semicolon);
    };
    /**
     * Parses an echo expression.
     *
     * Syntax: `ECHO echo-list ;`
     *
     * Where `echo-list` is:
     * - `echo-list , expr`
     * - `expr`
     */
    PhpParser.prototype.parseEcho = function () {
        // Inline text should not reach this method.
        php_common_1.Debug.assert(this.currentToken.kind === TokenKind_1.TokenKind.Echo || this.currentToken.kind === TokenKind_1.TokenKind.OpenTagWithEcho);
        var echoKeyword = this.eat(this.currentToken.kind);
        var semicolon;
        var expressions = [];
        expressions.push(this.parseExpression());
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            expressions.push(this.eat(TokenKind_1.TokenKind.Comma));
            expressions.push(this.parseExpression());
        }
        semicolon = this.isStatementEnd(this.currentToken.kind)
            ? this.parseStatementEnd()
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, ErrorCode_Generated_1.ErrorCode.ERR_CommaOrSemicolonExpected);
        return new Node_Generated_1.EchoNode(echoKeyword, this.factory.createList(expressions), semicolon);
    };
    /**
     * Parses an `elseif` clause of an if statement.
     *
     * Syntax: `ELSEIF ( expr ) statement`
     */
    PhpParser.prototype.parseElseIf = function () {
        var elseIfKeyword = this.eat(TokenKind_1.TokenKind.ElseIf);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var condition = this.parseExpression();
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        var statement = this.parseEmbeddedStatement(true, ErrorCode_Generated_1.ErrorCode.ERR_StatementExpected);
        return new Node_Generated_1.ElseIfNode(elseIfKeyword, openParen, condition, closeParen, statement);
    };
    /**
     * Parses an `elseif` clause of an if statement (alternate syntax).
     *
     * Syntax: `ELSEIF ( expr ) : statement-list`
     */
    PhpParser.prototype.parseElseIfBlock = function () {
        var elseIfKeyword = this.eat(TokenKind_1.TokenKind.ElseIf);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var condition = this.parseExpression();
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        var colon = this.eat(TokenKind_1.TokenKind.Colon);
        var statements = this.parseList(64 /* IfBlockElements */);
        return new Node_Generated_1.ElseIfBlockNode(elseIfKeyword, openParen, condition, closeParen, colon, statements);
    };
    /**
     * Parses a single statement or, if the statement is missing, an empty
     * statement is created with a diagnostic.
     *
     * @param {boolean} warnIfEmpty
     *   If `true` and the next token is a semicolon, then a warning is added to
     *   the generated empty statement.
     * @param {ErrorCode} code
     *   An error code to use if the statement is missing.
     * @param {...any[]} args
     *   A list of arguments given to the diagnostic created if the statement is
     *   missing.
     */
    PhpParser.prototype.parseEmbeddedStatement = function (warnIfEmpty, code) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var statement;
        if (this.isStatementStart(this.currentToken.kind)) {
            if (this.currentToken.kind === TokenKind_1.TokenKind.Semicolon && warnIfEmpty) {
                statement = this.parseStatement();
                statement = this.addError(statement, ErrorCode_Generated_1.ErrorCode.WRN_PossibleMistakenEmptyStatement);
            }
            else {
                statement = this.parseStatement();
            }
        }
        else {
            // Create an empty expression statement to act as our placeholder.
            var semicolon = this.createMissingToken(TokenKind_1.TokenKind.Semicolon, this.currentToken.kind, false);
            statement = new Node_Generated_1.ExpressionStatementNode(null, semicolon);
            statement = this.addError.apply(this, __spreadArray([statement, code], __read(args)));
        }
        return statement;
    };
    /**
     * Parses a for statement (or its alternate syntax).
     *
     * Syntax:
     * - `FOR ( for-expr ; for-expr ; for-expr ) statement`
     * - `FOR ( for-expr ; for-expr ; for-expr ) : statement-list ENDFOR ;`
     */
    PhpParser.prototype.parseFor = function () {
        var forKeyword = this.eat(TokenKind_1.TokenKind.For);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var initializerExpressions = this.parseForExpressionList(TokenKind_1.TokenKind.Semicolon);
        var initializers = initializerExpressions.length > 0 ? this.factory.createList(initializerExpressions) : null;
        // Depending on what is being parsed and what is missing, semicolon errors
        // may not indicate the proper correction. For example, if a for statement
        // is being added:
        //
        //   for|  <-- cursor here
        //   $a;
        //
        // Instead of telling the user to add a semicolon after the statement, only
        // the missing open parenthesis is reported, and additional errors are
        // ignored.
        var firstSemicolon;
        if (!this.isStatementEnd(this.currentToken.kind)) {
            if (openParen.isMissing) {
                firstSemicolon = this.createMissingToken(TokenKind_1.TokenKind.Semicolon, this.currentToken.kind, false);
            }
            else {
                var code = initializers !== null ? ErrorCode_Generated_1.ErrorCode.ERR_CommaOrSemicolonExpected : ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrSemicolonExpected;
                firstSemicolon = this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, code);
            }
        }
        else {
            firstSemicolon = this.parseStatementEnd();
        }
        var conditionExpressions = this.parseForExpressionList(TokenKind_1.TokenKind.Semicolon);
        var conditions = conditionExpressions.length > 0 ? this.factory.createList(conditionExpressions) : null;
        var secondSemicolon;
        if (!this.isStatementEnd(this.currentToken.kind)) {
            if (openParen.isMissing || firstSemicolon.isMissing) {
                secondSemicolon = this.createMissingToken(TokenKind_1.TokenKind.Semicolon, this.currentToken.kind, false);
            }
            else {
                var code = conditions !== null ? ErrorCode_Generated_1.ErrorCode.ERR_CommaOrSemicolonExpected : ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrSemicolonExpected;
                secondSemicolon = this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, code);
            }
        }
        else {
            secondSemicolon = this.parseStatementEnd();
        }
        var iterationExpressions = this.parseForExpressionList(TokenKind_1.TokenKind.CloseParen);
        var iterations = iterationExpressions.length > 0 ? this.factory.createList(iterationExpressions) : null;
        var closeParen;
        if (this.currentToken.kind === TokenKind_1.TokenKind.CloseParen) {
            closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        }
        else if (openParen.isMissing || firstSemicolon.isMissing || secondSemicolon.isMissing) {
            closeParen = this.createMissingToken(TokenKind_1.TokenKind.CloseParen, this.currentToken.kind, false);
        }
        else {
            var code = void 0;
            if (iterationExpressions.length > 0) {
                var lastExpression = iterationExpressions[iterationExpressions.length - 1];
                code = lastExpression.isMissing ? ErrorCode_Generated_1.ErrorCode.ERR_CloseParenExpected : ErrorCode_Generated_1.ErrorCode.ERR_CommaOrCloseParenExpected;
            }
            else {
                code = ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrCloseParenExpected;
            }
            closeParen = this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, code);
        }
        // Alternate syntax.
        if (this.currentToken.kind === TokenKind_1.TokenKind.Colon) {
            var colon = this.eat(TokenKind_1.TokenKind.Colon);
            var statements = this.parseList(16 /* ForBlockElements */);
            var endForKeyword = this.eat(TokenKind_1.TokenKind.EndFor);
            var semicolon = this.parseStatementEnd();
            return new Node_Generated_1.ForBlockNode(forKeyword, openParen, initializers, firstSemicolon, conditions, secondSemicolon, iterations, closeParen, colon, statements, endForKeyword, semicolon);
        }
        var statement = this.parseEmbeddedStatement(true, ErrorCode_Generated_1.ErrorCode.ERR_StatementOrColonExpected);
        return new Node_Generated_1.ForNode(forKeyword, openParen, initializers, firstSemicolon, conditions, secondSemicolon, iterations, closeParen, statement);
    };
    /**
     * Parses a comma-separated list of expressions within a for statement.
     */
    PhpParser.prototype.parseForExpressionList = function (terminator) {
        var expressions = [];
        if (this.isExpressionStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            expressions.push(this.parseExpression());
        }
        var kind = this.currentToken.kind; // WARNING: Side-effects!
        while (kind !== TokenKind_1.TokenKind.CloseParen && kind !== TokenKind_1.TokenKind.Semicolon && kind !== TokenKind_1.TokenKind.EOF) {
            if (this.isExpressionStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
                expressions.push(this.eat(TokenKind_1.TokenKind.Comma));
                expressions.push(this.parseExpression());
                kind = this.currentToken.kind;
                continue;
            }
            if (this.isTokenValidInContexts(this.currentToken.kind)) {
                break;
            }
            this.skipBadForExpressionListTokens(terminator);
            kind = this.currentToken.kind;
        }
        return expressions;
    };
    /**
     * Parses a foreach statement.
     *
     * Syntax:
     * - `FOREACH ( expr AS foreach-value ) statement`
     * - `FOREACH ( expr AS foreach-value ) : statement-list ENDFOREACH ;`
     * - `FOREACH ( expr AS expr => foreach-value ) statement`
     * - `FOREACH ( expr AS expr => foreach-value ) : statement-list ENDFOREACH ;`
     *
     * Where `foreach-value` is:
     * - `expr`
     * - `& expr`
     * - `LIST ( list-elements )`
     * - `[ list-elements ]`
     */
    PhpParser.prototype.parseForEach = function () {
        var forEachKeyword = this.eat(TokenKind_1.TokenKind.ForEach);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var sourceExpr = this.parseExpression();
        var asKeyword = this.eat(TokenKind_1.TokenKind.As);
        var isValue = true;
        var ampersand = null;
        var value;
        // Array keys cannot be lists, nor can they be accessed by reference, so
        // if either is found, the first expression represents the value element.
        switch (this.currentToken.kind) {
            case TokenKind_1.TokenKind.Ampersand:
                ampersand = this.eat(TokenKind_1.TokenKind.Ampersand);
                value = this.parseExpression(ExpressionType_1.ExpressionType.Explicit);
                break;
            case TokenKind_1.TokenKind.List:
                value = this.parseListDestructure();
                break;
            default:
                value = this.parseForEachVariable();
                isValue = (value instanceof Node_Generated_1.ArrayNode && value.arrayKeyword === null);
                break;
        }
        var doubleArrow = null;
        var key = null;
        // NOTE: While PHP allows parsing of these invalid key expressions, the
        // resulting statement always results in an error ("key element cannot be
        // a reference" and "cannot use list as key element").
        if (this.currentToken.kind === TokenKind_1.TokenKind.DoubleArrow && !isValue) {
            key = value;
            doubleArrow = this.eat(TokenKind_1.TokenKind.DoubleArrow);
            // Suppress TS2365: Current token changed after previous method call.
            switch (this.currentToken.kind) {
                case TokenKind_1.TokenKind.Ampersand:
                    ampersand = this.eat(TokenKind_1.TokenKind.Ampersand);
                    value = this.parseExpression(ExpressionType_1.ExpressionType.Explicit);
                    break;
                case TokenKind_1.TokenKind.List:
                    value = this.parseListDestructure();
                    break;
                default:
                    value = this.parseForEachVariable();
                    break;
            }
        }
        var code = !isValue && doubleArrow === null
            ? ErrorCode_Generated_1.ErrorCode.ERR_DoubleArrowOrCloseParenExpected
            : ErrorCode_Generated_1.ErrorCode.ERR_CloseParenExpected;
        var closeParen = this.currentToken.kind === TokenKind_1.TokenKind.CloseParen
            ? this.eat(TokenKind_1.TokenKind.CloseParen)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, code);
        if (this.currentToken.kind === TokenKind_1.TokenKind.Colon) {
            var colon = this.eat(TokenKind_1.TokenKind.Colon);
            var statements = this.parseList(32 /* ForEachBlockElements */);
            var endForEach = this.eat(TokenKind_1.TokenKind.EndForEach);
            var semicolon = this.parseStatementEnd();
            return new Node_Generated_1.ForEachBlockNode(forEachKeyword, openParen, sourceExpr, asKeyword, key, doubleArrow, ampersand, value, closeParen, colon, statements, endForEach, semicolon);
        }
        var statement = this.parseEmbeddedStatement(true, ErrorCode_Generated_1.ErrorCode.ERR_StatementOrColonExpected);
        return new Node_Generated_1.ForEachNode(forEachKeyword, openParen, sourceExpr, asKeyword, key, doubleArrow, ampersand, value, closeParen, statement);
    };
    /**
     * @todo Document parseForEachVariable().
     */
    PhpParser.prototype.parseForEachVariable = function () {
        // Due to a rather unfortunate ambiguity in PHP's grammar, an array
        // initializer and deconstruction may have the exact same syntax.
        //
        //   foreach ($a as [$b, $c]()->d) {}  // Equivalent to `$b::$c()->d`.
        //                  ^-- parser here
        //
        // In the above scenario, the parser does not know if the opening bracket
        // should start a deconstruction or an array initializer and as a result,
        // needs to parse it as either. Sadly, this means that invalid
        // array initializers are not syntax errors.
        //
        //   [,$a]   // Valid deconstruction, invalid array.
        //
        var expr = this.parseExpressionTree();
        var value = expr.node;
        // The only diagnostic that can be added is for implicit expressions that
        // are not short-form arrays.
        if (!value.containsDiagnostics && expr.type !== ExpressionType_1.ExpressionType.Explicit && !(value instanceof Node_Generated_1.ArrayNode && value.arrayKeyword === null)) {
            value = this.addError(value, ErrorCode_Generated_1.ErrorCode.ERR_ExpressionNotAddressable);
        }
        return value;
    };
    /**
     * Parses a qualified name that begins with a namespace separator.
     */
    PhpParser.prototype.parseFullyQualifiedName = function () {
        var leadingBackslash = this.eat(TokenKind_1.TokenKind.Backslash);
        var namespaceName = this.factory.createList(this.parseNamespaceName());
        return new Node_Generated_1.FullyQualifiedNameNode(leadingBackslash, namespaceName);
    };
    /**
     * Parses a function declaration statement.
     *
     * Syntax: `FUNCTION & IDENTIFIER ( parameter-list ) return-type statement-block`
     */
    PhpParser.prototype.parseFunctionDeclaration = function (functionKeyword, ampersand) {
        // The caller should have checked if the name is valid.
        php_common_1.Debug.assert(this.isFunctionIdentifier(this.currentToken.kind));
        var identifier = this.eat(this.currentToken.kind);
        var parameters = this.parseParameterList();
        var colon = this.eatOptional(TokenKind_1.TokenKind.Colon);
        var returnType = colon ? this.parseType() : null;
        var openBrace = this.currentToken.kind !== TokenKind_1.TokenKind.OpenBrace && colon === null
            ? this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenBrace, ErrorCode_Generated_1.ErrorCode.ERR_OpenBraceOrColonExpected)
            : this.eat(TokenKind_1.TokenKind.OpenBrace);
        var statements = this.parseList(2 /* CompoundStatementElements */);
        var closeBrace = openBrace.isMissing
            ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
            : this.eat(TokenKind_1.TokenKind.CloseBrace);
        return new Node_Generated_1.FunctionDeclarationNode(functionKeyword, ampersand, identifier, parameters.openParen, parameters.parameterList, parameters.closeParen, colon, returnType, new Node_Generated_1.StatementBlockNode(openBrace, statements, closeBrace));
    };
    /**
     * Parses a global variable declaration statement.
     *
     * Syntax: `GLOBAL global-variable-list ;`
     *
     * Where `global-variable-list` is:
     * - `global-variable-list , simple-variable`
     * - `simple-variable`
     */
    PhpParser.prototype.parseGlobal = function () {
        var globalKeyword = this.eat(TokenKind_1.TokenKind.Global);
        var variables = [];
        variables.push(this.parseSimpleVariable());
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            variables.push(this.eat(TokenKind_1.TokenKind.Comma));
            variables.push(this.parseSimpleVariable());
        }
        var semicolon = this.isStatementEnd(this.currentToken.kind)
            ? this.parseStatementEnd()
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, ErrorCode_Generated_1.ErrorCode.ERR_CommaOrSemicolonExpected);
        return new Node_Generated_1.GlobalNode(globalKeyword, this.factory.createList(variables), semicolon);
    };
    /**
     * Parses a goto statement.
     *
     * Syntax: `GOTO IDENTIFIER ;`
     */
    PhpParser.prototype.parseGoTo = function () {
        var gotoKeyword = this.eat(TokenKind_1.TokenKind.GoTo);
        var label = this.eat(TokenKind_1.TokenKind.Identifier);
        var semicolon = this.parseStatementEnd();
        return new Node_Generated_1.GoToNode(gotoKeyword, label, semicolon);
    };
    /**
     * Parses a halt compiler statement.
     *
     * Syntax: `HALT_COMPILER ( ) ;`
     */
    PhpParser.prototype.parseHaltCompiler = function () {
        var haltKeyword = this.eat(TokenKind_1.TokenKind.HaltCompiler);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        var semicolon = this.parseStatementEnd();
        // The caller will determine the context and, if necessary, stop the parser.
        return new Node_Generated_1.HaltCompilerNode(haltKeyword, openParen, closeParen, semicolon);
    };
    /**
     * Parses an if statement.
     *
     * Syntax:
     * - `if-statement`
     * - `if-statement ELSE statement`
     *
     * Where `if-statement` is:
     * - `IF ( expr ) statement`
     * - `IF ( expr ) statement elseif-clause`
     */
    PhpParser.prototype.parseIf = function () {
        var ifKeyword = this.eat(TokenKind_1.TokenKind.If);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var condition = this.parseExpression();
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        // Alternate syntax.
        if (this.currentToken.kind === TokenKind_1.TokenKind.Colon) {
            var colon = this.eat(TokenKind_1.TokenKind.Colon);
            var statements = this.parseList(64 /* IfBlockElements */);
            var elseIfClauses_1 = [];
            // Suppress TS2365: Current token changed after previous method call.
            while (this.currentToken.kind === TokenKind_1.TokenKind.ElseIf) {
                elseIfClauses_1.push(this.parseElseIfBlock());
            }
            var elseClause_1 = null;
            // Suppress TS2365: Current token changed after previous method call.
            if (this.currentToken.kind === TokenKind_1.TokenKind.Else) {
                var elseKeyword = this.eat(TokenKind_1.TokenKind.Else);
                var elseColon = this.eat(TokenKind_1.TokenKind.Colon);
                var elseStatements = this.parseList(128 /* IfElseBlockElements */);
                elseClause_1 = new Node_Generated_1.ElseBlockNode(elseKeyword, elseColon, elseStatements);
            }
            var endIf = this.eat(TokenKind_1.TokenKind.EndIf);
            var semicolon = this.parseStatementEnd();
            return new Node_Generated_1.IfBlockNode(ifKeyword, openParen, condition, closeParen, colon, statements, elseIfClauses_1.length > 0 ? this.factory.createList(elseIfClauses_1) : null, elseClause_1, endIf, semicolon);
        }
        var statement = this.parseEmbeddedStatement(true, ErrorCode_Generated_1.ErrorCode.ERR_StatementOrColonExpected);
        var elseIfClauses = [];
        while (this.currentToken.kind === TokenKind_1.TokenKind.ElseIf) {
            elseIfClauses.push(this.parseElseIf());
        }
        var elseClause = null;
        if (this.currentToken.kind === TokenKind_1.TokenKind.Else) {
            var elseKeyword = this.eat(TokenKind_1.TokenKind.Else);
            var elseStatement = this.parseEmbeddedStatement(true, ErrorCode_Generated_1.ErrorCode.ERR_StatementExpected);
            elseClause = new Node_Generated_1.ElseNode(elseKeyword, elseStatement);
        }
        return new Node_Generated_1.IfNode(ifKeyword, openParen, condition, closeParen, statement, elseIfClauses.length > 0 ? this.factory.createList(elseIfClauses) : null, elseClause);
    };
    /**
     * Parses inline text (which actually gets treated as an echo statement).
     *
     * Syntax: `INLINE_TEXT`
     */
    PhpParser.prototype.parseInlineText = function () {
        var inlineText = this.eat(TokenKind_1.TokenKind.InlineText);
        var exprList = this.factory.createList([inlineText]);
        // Fun fact: TypeScript sucks! Note the lack of an error in:
        //   new EchoNode(null, inlineText, null);
        return new Node_Generated_1.EchoNode(null, exprList, null);
    };
    /**
     * Parses an interface declaration statement.
     *
     * Syntax: `INTERFACE IDENTIFIER interface-base-clause { interface-member-declarations }`
     *
     * Where `interface-base-clause` is:
     * - `EXTENDS qualified-name-list`
     */
    PhpParser.prototype.parseInterfaceDeclaration = function () {
        var interfaceKeyword = this.eat(TokenKind_1.TokenKind.Interface);
        var identifier = this.eat(TokenKind_1.TokenKind.Identifier);
        var extendsKeyword = this.eatOptional(TokenKind_1.TokenKind.Extends);
        var baseInterfaces = null;
        if (extendsKeyword !== null) {
            baseInterfaces = this.parseQualifiedNameList();
        }
        if (this.currentToken.kind === TokenKind_1.TokenKind.Implements) {
            this.skipTokenWithError(ErrorCode_Generated_1.ErrorCode.ERR_InterfaceImplementsList);
        }
        var openBrace;
        if (this.currentToken.kind !== TokenKind_1.TokenKind.OpenBrace) {
            var code = extendsKeyword !== null ? ErrorCode_Generated_1.ErrorCode.ERR_CommaOrOpenBraceExpected : ErrorCode_Generated_1.ErrorCode.ERR_IncompleteInterfaceDeclaration;
            openBrace = this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenBrace, code);
        }
        else {
            openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
        }
        var members = null;
        if (!identifier.isMissing && !openBrace.isMissing) {
            members = this.parseClassMembers(8192 /* InterfaceMembers */);
        }
        var closeBrace = openBrace.isMissing
            ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
            : this.eat(TokenKind_1.TokenKind.CloseBrace);
        return new Node_Generated_1.InterfaceDeclarationNode(interfaceKeyword, identifier, extendsKeyword, baseInterfaces, openBrace, members, closeBrace);
    };
    /**
     * Parses a method declaration statement.
     *
     * Syntax: `modifiers FUNCTION & member-name ( parameter-list ) return-type method-body`
     *
     * Where `method-body` is:
     * - `statement-block`
     * - `;`
     *
     * @param {TokenNode[]} modifiers
     *   A list of previously parsed modifier keywords.
     * @param {ModifierFlags} modifierFlags
     *   A bit field representing all the modifiers that were parsed.
     * @param {ParseContext} context
     *   The context that this declaration should be parsed in.
     */
    PhpParser.prototype.parseMethodDeclaration = function (modifiers, modifierFlags, context) {
        var functionKeyword = this.eat(TokenKind_1.TokenKind.Function);
        var ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
        var identifier = this.parseClassMemberName(ampersand !== null ? ErrorCode_Generated_1.ErrorCode.ERR_MethodNameExpected : ErrorCode_Generated_1.ErrorCode.ERR_MethodNameOrAmpersandExpected);
        var parameters = this.parseParameterList();
        var colon = this.eatOptional(TokenKind_1.TokenKind.Colon);
        var returnType = colon ? this.parseType() : null;
        var statements = null;
        var semicolon = null;
        // If there is an opening brace, then unconditionally parse a statement
        // block, even if this is an abstract method or if this declaration is
        // inside an interface. This should allow for a more useful error message,
        // and prevent the parser from getting too far off track.
        var isInterfaceOrAbstract = context === 8192 /* InterfaceMembers */ || modifierFlags & ModifierFlags_1.ModifierFlags.Abstract;
        if (this.currentToken.kind !== TokenKind_1.TokenKind.OpenBrace && isInterfaceOrAbstract) {
            semicolon = this.isStatementEnd(this.currentToken.kind)
                ? this.parseStatementEnd()
                : this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, ErrorCode_Generated_1.ErrorCode.ERR_ColonOrSemicolonExpected);
        }
        else {
            var openBrace = void 0;
            if (this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace) {
                openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
                if (context === 8192 /* InterfaceMembers */) {
                    // @todo Test: Diagnostic priority over ERR_AbstractMethodHasBody.
                    openBrace = this.addError(openBrace, ErrorCode_Generated_1.ErrorCode.ERR_InterfaceMethodDefinition);
                }
                if (modifierFlags & ModifierFlags_1.ModifierFlags.Abstract) {
                    openBrace = this.addError(openBrace, ErrorCode_Generated_1.ErrorCode.ERR_AbstractMethodHasBody);
                }
            }
            else {
                var code = colon !== null ? ErrorCode_Generated_1.ErrorCode.ERR_OpenBraceExpected : ErrorCode_Generated_1.ErrorCode.ERR_OpenBraceOrColonExpected;
                openBrace = this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenBrace, code);
            }
            var statementList = this.parseList(2 /* CompoundStatementElements */);
            var closeBrace = openBrace.isMissing
                ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
                : this.eat(TokenKind_1.TokenKind.CloseBrace);
            statements = new Node_Generated_1.StatementBlockNode(openBrace, statementList, closeBrace);
        }
        // A method body must be present or explicitly ommitted (even if the
        // semicolon token is missing).
        php_common_1.Debug.assert(!(statements === null && semicolon === null));
        return new Node_Generated_1.MethodDeclarationNode(modifiers.length > 0 ? this.factory.createList(modifiers) : null, functionKeyword, ampersand, identifier, parameters.openParen, parameters.parameterList, parameters.closeParen, colon, returnType, statements, semicolon);
    };
    /**
     * Parses a namespace declaration.
     *
     * Syntax:
     * - `NAMESPACE name;`
     * - `NAMESPACE name { namespaced-statement-list }`
     * - `NAMESPACE { namespaced-statement-list }`
     */
    PhpParser.prototype.parseNamespaceDeclaration = function (namespaceKeyword) {
        // The next token should not be missing or part of a relative name.
        php_common_1.Debug.assert(this.currentToken.kind === TokenKind_1.TokenKind.Identifier || this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace);
        // NOTE: While PHP will generate an error when mixed namespace declaration
        // types are used in a file, there is nothing in the language grammar that
        // makes such a statement invalid. As such, it is strictly a semantic issue
        // and not prohibited by this parser.
        // Global namespace.
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace) {
            var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
            var statements = this.parseList(4 /* NamespaceElements */);
            var closeBrace = this.eat(TokenKind_1.TokenKind.CloseBrace);
            return new Node_Generated_1.NamespaceGroupDeclarationNode(namespaceKeyword, null, openBrace, statements, closeBrace);
        }
        var name = this.parsePartiallyQualifiedName();
        // Suppress TS2365: Current token changed after previous method call.
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace) {
            var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
            var statements = this.parseList(4 /* NamespaceElements */);
            var closeBrace = this.eat(TokenKind_1.TokenKind.CloseBrace);
            return new Node_Generated_1.NamespaceGroupDeclarationNode(namespaceKeyword, name, openBrace, statements, closeBrace);
        }
        var semicolon = this.isStatementEnd(this.currentToken.kind)
            ? this.parseStatementEnd()
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, ErrorCode_Generated_1.ErrorCode.ERR_OpenBraceOrSemicolonExpected);
        return new Node_Generated_1.NamespaceDeclarationNode(namespaceKeyword, name, semicolon);
    };
    /**
     * Parses a delimited list of tokens representing a name.
     *
     * @param {boolean=} noTrailingBackslash
     *   If `true`, a missing identifier is appended to the list of returned
     *   tokens if an unrecognized token is found after a namespace separator.
     *
     * @return {TokenNode[]}
     *   A list of tokens making up the name. An actual node to contain these
     *   tokens must be created by the caller.
     */
    PhpParser.prototype.parseNamespaceName = function (noTrailingBackslash) {
        if (noTrailingBackslash === void 0) { noTrailingBackslash = true; }
        var namespaces = [];
        var identifier = this.currentToken.kind === TokenKind_1.TokenKind.Identifier
            ? this.eat(TokenKind_1.TokenKind.Identifier)
            : this.createMissingToken(TokenKind_1.TokenKind.Identifier, this.currentToken.kind, false);
        namespaces.push(identifier);
        if (identifier.isMissing) {
            // @todo This is not the ideal error code in every situation.
            namespaces[0] = this.addError(namespaces[0], ErrorCode_Generated_1.ErrorCode.ERR_IdentifierExpected);
            return namespaces;
        }
        while (this.currentToken.kind === TokenKind_1.TokenKind.Backslash) {
            namespaces.push(this.eat(TokenKind_1.TokenKind.Backslash));
            // If the next token is an identifier or another backslash, then eat an
            // identifier (which should be missing in the latter case). If it is
            // something else, then only add a missing identifier token if allowed.
            // @todo Needs IDE testing.
            // Suppress TS2365: Current token changed after previous method call.
            var kind = this.currentToken.kind;
            if (kind === TokenKind_1.TokenKind.Identifier || kind === TokenKind_1.TokenKind.Backslash || noTrailingBackslash) {
                namespaces.push(this.eat(TokenKind_1.TokenKind.Identifier));
            }
        }
        return namespaces;
    };
    /**
     * Parses a single parameter within a function or method's parameter list.
     *
     * Syntax:
     * - `type & ELLIPSIS VARIABLE`
     * - `type & ELLIPSIS VARIABLE = expr`
     */
    PhpParser.prototype.parseParameter = function () {
        var type = null;
        if (this.isTypeStart(this.currentToken.kind)) {
            type = this.parseType();
        }
        var ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
        var variadic = this.eatOptional(TokenKind_1.TokenKind.Ellipsis);
        var variable;
        if (this.currentToken.kind === TokenKind_1.TokenKind.Dollar) {
            variable = this.eat(TokenKind_1.TokenKind.Dollar);
            variable = this.addError(variable, ErrorCode_Generated_1.ErrorCode.ERR_VariableNameExpected);
        }
        else {
            if (this.currentToken.kind !== TokenKind_1.TokenKind.Variable) {
                // From right to left, determine what could still be expected.
                var code = void 0;
                if (variadic !== null) {
                    code = ErrorCode_Generated_1.ErrorCode.ERR_VariableExpected;
                }
                else if (ampersand !== null) {
                    code = ErrorCode_Generated_1.ErrorCode.ERR_VariableOrEllipsisExpected;
                }
                else {
                    code = type !== null ? ErrorCode_Generated_1.ErrorCode.ERR_IncompleteParameter : ErrorCode_Generated_1.ErrorCode.ERR_ParameterExpected;
                }
                variable = this.createMissingTokenWithError(TokenKind_1.TokenKind.Variable, code);
            }
            else {
                variable = this.eat(TokenKind_1.TokenKind.Variable);
            }
        }
        var equal = this.eatOptional(TokenKind_1.TokenKind.Equal);
        if (variadic !== null && equal !== null) {
            equal = this.addError(equal, ErrorCode_Generated_1.ErrorCode.ERR_VariadicHasDefaultValue);
        }
        var defaultValue = equal !== null ? this.parseExpression() : null;
        return new Node_Generated_1.ParameterNode(type, ampersand, variadic, variable, equal, defaultValue);
    };
    /**
     * Parses a comma separated list of parameters.
     *
     * Syntax: `( parameter-list )`
     *
     * Where `parameter-list` is:
     * - `parameter-list , parameter`
     * - `parameter`
     */
    PhpParser.prototype.parseParameterList = function () {
        var parameters = [];
        var variadicIndex = -1;
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        // const savedContext = this.currentContext;
        // this.addParseContext(ParseContext.ParameterListElements);
        if (this.isParameterStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            var parameter = this.parseParameter();
            parameters.push(parameter);
            if (parameter.ellipsis) {
                variadicIndex = 0;
            }
        }
        // @todo Replace with tokenEndsContext()?
        while (this.currentToken.kind !== TokenKind_1.TokenKind.CloseParen && this.currentToken.kind !== TokenKind_1.TokenKind.EOF) {
            if (this.isParameterStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
                parameters.push(this.eat(TokenKind_1.TokenKind.Comma));
                var parameter = this.parseParameter();
                parameters.push(parameter);
                if (parameter.ellipsis !== null && variadicIndex === -1) {
                    variadicIndex = parameters.length - 1;
                }
                continue;
            }
            if (this.isTokenValidInContexts(this.currentToken.kind)) {
                break;
            }
            this.skipBadParameterListTokens();
        }
        if (variadicIndex !== -1 && variadicIndex < parameters.length - 1) {
            parameters[variadicIndex] = this.addError(parameters[variadicIndex], ErrorCode_Generated_1.ErrorCode.ERR_VariadicIsNotLastParameter);
        }
        // this.currentContext = savedContext;
        var closeParen;
        if (openParen.isMissing) {
            closeParen = this.createMissingToken(TokenKind_1.TokenKind.CloseParen, this.currentToken.kind, false);
        }
        else if (this.currentToken.kind === TokenKind_1.TokenKind.CloseParen) {
            closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        }
        else {
            var code = void 0;
            if (parameters.length > 0) {
                var lastParameter = parameters[parameters.length - 1];
                if (lastParameter.ellipsis !== null) {
                    code = ErrorCode_Generated_1.ErrorCode.ERR_CloseParenExpected;
                }
                else if (lastParameter.equal !== null) {
                    code = ErrorCode_Generated_1.ErrorCode.ERR_CommaOrCloseParenExpected;
                }
                else {
                    code = ErrorCode_Generated_1.ErrorCode.ERR_IncompleteParameterList;
                }
            }
            else {
                code = ErrorCode_Generated_1.ErrorCode.ERR_ParameterOrCloseParenExpected;
            }
            closeParen = this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, code);
        }
        // NOTE: Just like `InvocationArguments`, this temporary object is used to
        // standardize how parameter lists are parsed.
        return new Parameters(openParen, parameters.length > 0 ? this.factory.createList(parameters) : null, closeParen);
    };
    /**
     * Parses a name that starts with an identifier and may include namespaces.
     *
     * Syntax: `name`
     *
     * Where `name` is:
     * - `name \ IDENTIFIER`
     * - `IDENTIFIER`
     *
     * @see parseQualifiedName()
     */
    PhpParser.prototype.parsePartiallyQualifiedName = function () {
        var namespaceName = this.factory.createList(this.parseNamespaceName());
        return new Node_Generated_1.PartiallyQualifiedNameNode(namespaceName);
    };
    /**
     * Parses a property declaration statement.
     *
     * Syntax: `property-modifiers type property-list ;`
     *
     * Where `property-modifiers` is:
     * - `modifiers`
     * - `VAR`
     *
     * Where `property-list` is:
     * - `property-list , property-element`
     * - `property-element`
     *
     * @param {TokenNode[]} modifiers
     *   Previously parsed modifier keywords.
     * @param {ParseContext} context
     *   The parent parsing context (class, interface, or trait members).
     */
    PhpParser.prototype.parsePropertyDeclaration = function (modifiers, context) {
        for (var i = 0; i < modifiers.length; i++) {
            var modifier = this.getModifierFlag(modifiers[i].kind);
            if (modifier === ModifierFlags_1.ModifierFlags.Abstract || modifier === ModifierFlags_1.ModifierFlags.Final) {
                // Since these modifiers are already invalid within an interface, there
                // is no need to add another diagnostic.
                if (context !== 8192 /* InterfaceMembers */) {
                    modifiers[i] = this.addError(modifiers[i], ErrorCode_Generated_1.ErrorCode.ERR_BadPropertyModifier);
                }
            }
        }
        // Even though 'callable' is semantically invalid, it is not a parse error.
        var type = null;
        if (this.isTypeStart(this.currentToken.kind)) {
            type = this.parseType();
            if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_4)) {
                type = this.addError(type, ErrorCode_Generated_1.ErrorCode.ERR_FeatureTypedProperties);
            }
        }
        var property = this.parsePropertyElement();
        if (context === 8192 /* InterfaceMembers */) {
            property = this.addError(property, ErrorCode_Generated_1.ErrorCode.ERR_InterfaceProperty);
        }
        // Shouldn't be able to parse a property without seeing one of these first.
        // @todo Attempt to parse for error recovery and assume 'public'?
        php_common_1.Debug.assert(modifiers.length > 0);
        var nodes = [];
        nodes.push(property);
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            nodes.push(this.eat(TokenKind_1.TokenKind.Comma));
            nodes.push(this.parsePropertyElement());
        }
        var semicolon;
        if (this.isStatementEnd(this.currentToken.kind)) {
            semicolon = this.parseStatementEnd();
        }
        else {
            var lastProperty = nodes[nodes.length - 1];
            var code = lastProperty.equal !== null ? ErrorCode_Generated_1.ErrorCode.ERR_CommaOrSemicolonExpected : ErrorCode_Generated_1.ErrorCode.ERR_IncompletePropertyDeclaration;
            semicolon = this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, code);
        }
        return new Node_Generated_1.PropertyDeclarationNode(this.factory.createList(modifiers), type, this.factory.createList(nodes), semicolon);
    };
    /**
     * Parses the declaration of an individual property.
     *
     * Syntax: `property-element`
     *
     * Where `property-element` is:
     * - `VARIABLE`
     * - `VARIABLE = expression` (technically `constant-expression`)
     */
    PhpParser.prototype.parsePropertyElement = function () {
        var variable = this.parsePropertyName();
        var equal = this.eatOptional(TokenKind_1.TokenKind.Equal);
        var expression = equal !== null ? this.parseExpression() : null;
        return new Node_Generated_1.PropertyElementNode(variable, equal, expression);
    };
    /**
     * Parses a property name.
     *
     * Syntax: `VARIABLE`
     */
    PhpParser.prototype.parsePropertyName = function () {
        // If the user is declaring the property then a trailing '$' would simply
        // be skipped and added to trailing trivia.
        //
        //   public $
        //
        // If the user is renaming a property, then subsequent tokens have a high
        // probability of being successfully parsed here.
        //
        //   public $ = 1;      -or-
        //   public $a = 1, $;
        //
        // In both cases, the diagnostic message is much better than PHP's
        // "expecting function or const" error, which isn't even close to what the
        // user was trying to do.
        var variable;
        if (this.currentToken.kind === TokenKind_1.TokenKind.Dollar) {
            variable = this.eat(TokenKind_1.TokenKind.Dollar);
            variable = this.addError(variable, ErrorCode_Generated_1.ErrorCode.ERR_PropertyNameExpected);
        }
        else {
            variable = this.currentToken.kind === TokenKind_1.TokenKind.Variable
                ? this.eat(TokenKind_1.TokenKind.Variable)
                : this.createMissingTokenWithError(TokenKind_1.TokenKind.Variable, ErrorCode_Generated_1.ErrorCode.ERR_PropertyExpected);
        }
        return variable;
    };
    /**
     * Parses a potentially qualified identifier for name resolution.
     *
     * Syntax: `qualified-name`
     *
     * Where `qualified-name` is:
     * - `name`
     * - `\ name` (fully qualified)
     * - `NAMESPACE \ name` (relative)
     */
    PhpParser.prototype.parseQualifiedName = function (allowRelativeNames) {
        if (allowRelativeNames === void 0) { allowRelativeNames = true; }
        // @todo May want to re-design this to allow naming options.
        // - Use flags? FQN | Relative | NoTrailingBackslash
        // - Partially qualified names would always be allowed.
        switch (this.currentToken.kind) {
            case TokenKind_1.TokenKind.Backslash:
                return this.parseFullyQualifiedName();
            case TokenKind_1.TokenKind.Namespace:
                if (allowRelativeNames) {
                    return this.parseRelativeName();
                }
            // Fall-through.
            default:
                // Expects an identifier, but creates a missing node otherwise.
                return this.parsePartiallyQualifiedName();
        }
    };
    /**
     * Parses a comma separated list of qualified names.
     */
    PhpParser.prototype.parseQualifiedNameList = function () {
        var nodes = [];
        // Depending on the desired error code, an alternative is to directly use
        // `parseQualifiedName()` instead.
        nodes.push(this.parseTypeName());
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            nodes.push(this.eat(TokenKind_1.TokenKind.Comma));
            nodes.push(this.parseTypeName());
        }
        return this.factory.createList(nodes);
    };
    /**
     * Parses a name that begins with a `NAMESPACE` token.
     */
    PhpParser.prototype.parseRelativeName = function () {
        var namespaceKeyword = this.eat(TokenKind_1.TokenKind.Namespace);
        var leadingBackslash = this.eat(TokenKind_1.TokenKind.Backslash);
        var namespaceName = this.factory.createList(this.parseNamespaceName());
        return new Node_Generated_1.RelativeNameNode(namespaceKeyword, leadingBackslash, namespaceName);
    };
    /**
     * Parses a return statement.
     *
     * Syntax: `RETURN optional-expr ;`
     */
    PhpParser.prototype.parseReturn = function () {
        var returnKeyword = this.eat(TokenKind_1.TokenKind.Return);
        var expression = this.isExpressionStart(this.currentToken.kind) ? this.parseExpression() : null;
        var semicolon = expression === null && !this.isStatementEnd(this.currentToken.kind)
            ? this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrSemicolonExpected)
            : this.parseStatementEnd();
        return new Node_Generated_1.ReturnNode(returnKeyword, expression, semicolon);
    };
    /**
     * Parses a static variable declaration statement.
     *
     * Syntax: `STATIC static-variable-list ;`
     *
     * Where `static-variable-list` is:
     * - `static-variable-list , static-variable`
     * - `static-variable`
     */
    PhpParser.prototype.parseStatic = function (staticKeyword) {
        var variables = [];
        variables.push(this.parseStaticElement());
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            variables.push(this.eat(TokenKind_1.TokenKind.Comma));
            variables.push(this.parseStaticElement());
        }
        var semicolon;
        if (this.isStatementEnd(this.currentToken.kind)) {
            semicolon = this.parseStatementEnd();
        }
        else {
            var lastVariable = variables[variables.length - 1];
            var code = lastVariable.equal !== null ? ErrorCode_Generated_1.ErrorCode.ERR_CommaOrSemicolonExpected : ErrorCode_Generated_1.ErrorCode.ERR_IncompleteStaticDeclaration;
            semicolon = this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, code);
        }
        return new Node_Generated_1.StaticNode(staticKeyword, this.factory.createList(variables), semicolon);
    };
    /**
     * Parses a static variable with an optional initialization expression.
     *
     * Syntax:
     * - `VARIABLE`
     * - `VARIABLE = expr`
     */
    PhpParser.prototype.parseStaticElement = function () {
        // A '$' is usually an incomplete variable.
        if (this.currentToken.kind === TokenKind_1.TokenKind.Dollar) {
            var dollar = this.eat(TokenKind_1.TokenKind.Dollar);
            dollar = this.addError(dollar, ErrorCode_Generated_1.ErrorCode.ERR_VariableNameExpected);
            return new Node_Generated_1.StaticElementNode(dollar, null, null);
        }
        var variable = this.currentToken.kind === TokenKind_1.TokenKind.Variable
            ? this.eat(TokenKind_1.TokenKind.Variable)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Variable, ErrorCode_Generated_1.ErrorCode.ERR_VariableExpected);
        if (this.currentToken.kind === TokenKind_1.TokenKind.Equal) {
            var equal = this.eat(TokenKind_1.TokenKind.Equal);
            var expression = this.parseExpression();
            return new Node_Generated_1.StaticElementNode(variable, equal, expression);
        }
        return new Node_Generated_1.StaticElementNode(variable, null, null);
    };
    /**
     * Parses a list of statements within surrounding braces.
     *
     * Syntax: `{ statement-list }`
     *
     * Alias: `compound-statement`
     */
    PhpParser.prototype.parseStatementBlock = function () {
        var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
        var statements = this.parseList(2 /* CompoundStatementElements */);
        var closeBrace = openBrace.isMissing
            ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
            : this.eat(TokenKind_1.TokenKind.CloseBrace);
        return new Node_Generated_1.StatementBlockNode(openBrace, statements, closeBrace);
    };
    /**
     * Parses a semicolon or closing tag.
     *
     * Syntax:
     * - `;`
     * - `?>`
     */
    PhpParser.prototype.parseStatementEnd = function () {
        // @todo Add a warning if a statement ends in a close tag?
        return this.currentToken.kind === TokenKind_1.TokenKind.Semicolon || this.currentToken.kind === TokenKind_1.TokenKind.CloseTag
            ? this.eat(this.currentToken.kind)
            : this.createMissingToken(TokenKind_1.TokenKind.Semicolon, this.currentToken.kind, true);
    };
    /**
     * Parses a switch statement.
     *
     * Syntax:
     * - `SWITCH ( expr ) { ; switch-case-list }`
     * - `SWITCH ( expr ) : ; switch-case-list ENDSWITCH ;`
     */
    PhpParser.prototype.parseSwitch = function () {
        var switchKeyword = this.eat(TokenKind_1.TokenKind.Switch);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var expression = this.parseExpression();
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        if (this.currentToken.kind === TokenKind_1.TokenKind.Colon) {
            var colon = this.eat(TokenKind_1.TokenKind.Colon);
            var caseSemicolon_1 = this.eatOptional(TokenKind_1.TokenKind.Semicolon);
            // Suppress TS2365: Current token changed after previous method call.
            if (!colon.isMissing && caseSemicolon_1 === null && this.currentToken.kind === TokenKind_1.TokenKind.EndSwitch) {
                colon = this.addError(colon, ErrorCode_Generated_1.ErrorCode.WRN_EmptySwitchBlock);
            }
            var caseClauses_1 = !colon.isMissing
                ? this.parseSwitchElements(1024 /* SwitchBlockElements */)
                : null;
            var endSwitch = this.eat(TokenKind_1.TokenKind.EndSwitch);
            var semicolon = this.parseStatementEnd();
            return new Node_Generated_1.SwitchBlockNode(switchKeyword, openParen, expression, closeParen, colon, caseSemicolon_1, caseClauses_1, endSwitch, semicolon);
        }
        var openBrace = this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace
            ? this.eat(TokenKind_1.TokenKind.OpenBrace)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenBrace, ErrorCode_Generated_1.ErrorCode.ERR_OpenBraceOrColonExpected);
        var caseSemicolon = this.eatOptional(TokenKind_1.TokenKind.Semicolon);
        // There is no good reason for this; show the user the error of their ways.
        if (!openBrace.isMissing && caseSemicolon === null && this.currentToken.kind === TokenKind_1.TokenKind.CloseBrace) {
            openBrace = this.addError(openBrace, ErrorCode_Generated_1.ErrorCode.WRN_EmptySwitchBlock);
        }
        var caseClauses = null;
        if (!openBrace.isMissing) {
            caseClauses = this.parseSwitchElements(512 /* SwitchElements */);
        }
        var closeBrace = openBrace.isMissing
            ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
            : this.eat(TokenKind_1.TokenKind.CloseBrace);
        return new Node_Generated_1.SwitchNode(switchKeyword, openParen, expression, closeParen, openBrace, caseSemicolon, caseClauses, closeBrace);
    };
    /**
     * Parses a switch case or default clause.
     *
     * Syntax:
     * - `CASE expression case-separator statement-list`
     * - `DEFAULT case-separator statement-list`
     */
    PhpParser.prototype.parseSwitchCase = function (label) {
        var specifier = label.kind === TokenKind_1.TokenKind.Case ? this.parseExpression() : null;
        var separator = this.currentToken.kind === TokenKind_1.TokenKind.Colon || this.currentToken.kind === TokenKind_1.TokenKind.Semicolon
            ? this.eat(this.currentToken.kind)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Colon, ErrorCode_Generated_1.ErrorCode.ERR_CaseLabelSeparatorExpected);
        var statements = this.parseList(2048 /* CaseClauseElements */);
        return new Node_Generated_1.SwitchCaseNode(label, specifier, separator, statements);
    };
    /**
     * Parses a list of switch case or default clauses.
     *
     * Syntax: `switch-case-list`
     *
     * Where `switch-case-list` is:
     * - `switch-case-list switch-case-clause`
     * - `switch-case-list switch-default-clause`
     */
    PhpParser.prototype.parseSwitchElements = function (context) {
        var clauses = [];
        var hasDefault = false;
        var savedContext = this.currentContext;
        this.addParseContext(context);
        while (!this.tokenEndsContext(context, this.currentToken.kind)) {
            if (this.tokenStartsContext(context, this.currentToken.kind)) {
                var label = this.eat(this.currentToken.kind);
                if (label.kind === TokenKind_1.TokenKind.Default) {
                    if (hasDefault) {
                        // @todo Technically this check can be done later, which could
                        //   allow this method to be merged with parseList().
                        label = this.addError(label, ErrorCode_Generated_1.ErrorCode.ERR_MultipleDefaultSwitchLabels);
                    }
                    hasDefault = true;
                }
                var switchCase = this.parseSwitchCase(label);
                clauses.push(switchCase);
                continue;
            }
            if (this.isTokenValidInContexts(this.currentToken.kind)) {
                break;
            }
            this.skipToken();
        }
        this.currentContext = savedContext;
        return clauses.length > 0 ? this.factory.createList(clauses) : null;
    };
    /**
     * Parses a throw statement.
     *
     * Syntax: `THROW expr ;`
     */
    PhpParser.prototype.parseThrow = function () {
        var throwKeyword = this.eat(TokenKind_1.TokenKind.Throw);
        var expression = this.parseExpression();
        var semicolon = this.parseStatementEnd();
        return new Node_Generated_1.ThrowNode(throwKeyword, expression, semicolon);
    };
    /**
     * Parses a list of trait adaptations.
     *
     * Syntax: `trait-adaptation-list`
     *
     * Where `trait-adaptation-list` is:
     * - `trait-adaptation-list trait-adaptation`
     * - `trait-adaptation`
     *
     * Where `trait-adaptation` is:
     * - `trait-alias ;`
     * - `trait-precedence ;`
     *
     * Where `trait-precedence` is:
     * - `method-reference INSTEADOF qualified-name-list`
     */
    PhpParser.prototype.parseTraitAdaptationList = function () {
        var adaptations = [];
        while (this.currentToken.kind !== TokenKind_1.TokenKind.CloseBrace && this.currentToken.kind !== TokenKind_1.TokenKind.EOF) {
            if (!this.isTraitAdaptationStart(this.currentToken.kind)) {
                // Method names used in a trait adaptation can also be keywords that
                // would otherwise be valid in an enclosing context.
                this.skipBadTraitUseTokens();
                continue;
            }
            //         -------- qualified name --------
            //         identifier  namespace  backslash  keyword
            // method  y           y          n          y
            // class   y           y          y          n
            var className = void 0;
            // If part of a relative name, then this keyword is part of a class name,
            // otherwise it is a method name (eliminate column 2).
            if (this.currentToken.kind === TokenKind_1.TokenKind.Namespace) {
                var namespaceKeyword = this.eat(this.currentToken.kind);
                // Suppress TS2365: Current token changed after previous method call.
                if (this.currentToken.kind === TokenKind_1.TokenKind.Backslash) {
                    var leadingBackslash = this.eat(this.currentToken.kind);
                    var namespaceName = this.factory.createList(this.parseNamespaceName());
                    className = new Node_Generated_1.RelativeNameNode(namespaceKeyword, leadingBackslash, namespaceName);
                }
                else {
                    var alias = this.parseTraitAlias(namespaceKeyword);
                    adaptations.push(alias);
                    continue;
                }
            }
            // Only class names can be fully qualified (eliminate column 3).
            else if (this.currentToken.kind === TokenKind_1.TokenKind.Backslash) {
                className = this.parseQualifiedName();
            }
            // Only method names can be semi-reserved keywords (eliminate column 4).
            else if (TokenKind_1.TokenKindInfo.isSemiReservedKeyword(this.currentToken.kind)) {
                var alias = this.parseTraitAlias(this.eat(this.currentToken.kind));
                adaptations.push(alias);
                continue;
            }
            else {
                php_common_1.Debug.assert(this.currentToken.kind === TokenKind_1.TokenKind.Identifier);
                var namespaces = this.parseNamespaceName();
                // So there are now two possibilities:
                // - If more than one token was parsed then the name was qualified, and
                //   is therefore a class name that is part of a method reference.
                // - If only one token was parsed then it could still be both, but the
                //   next token should be '::' if it was meant as a class name, or 'as'
                //   if it was meant as a method name.
                if (namespaces.length === 1) {
                    if (this.currentToken.kind === TokenKind_1.TokenKind.As) {
                        var alias = this.parseTraitAlias(namespaces[0]);
                        adaptations.push(alias);
                        continue;
                    }
                    // Now there are two possible error scenarios:
                    //
                    // 1. The user is adding an adaptation.
                    //    use A {
                    //      A|  <-- cursor here
                    // 2. The user is editing an existing adaptation.
                    //    use B {
                    //      B| insteadof C;
                    //       ^-- cursor here
                    // So if there is nothing the parser can work with, bail out now.
                    if (this.currentToken.kind !== TokenKind_1.TokenKind.DoubleColon && this.currentToken.kind !== TokenKind_1.TokenKind.InsteadOf) {
                        namespaces[0] = this.addError(namespaces[0], ErrorCode_Generated_1.ErrorCode.ERR_IncompleteTraitAdaptation);
                        adaptations.push(new Node_Generated_1.IncompleteNamedTraitAdaptationNode(namespaces[0]));
                        continue;
                    }
                }
                className = new Node_Generated_1.PartiallyQualifiedNameNode(this.factory.createList(namespaces));
            }
            // At this point, only a class name is being parsed.
            var doubleColon = this.currentToken.kind === TokenKind_1.TokenKind.DoubleColon
                ? this.eat(TokenKind_1.TokenKind.DoubleColon)
                : this.createMissingTokenWithError(TokenKind_1.TokenKind.DoubleColon, ErrorCode_Generated_1.ErrorCode.ERR_MalformedMethodReference);
            // Before parsing the method name however, consider if a user has gone
            // back to add a trait use clause:
            //
            // class A {
            //   use B {
            //     B::| <-- cursor here
            //   public function x() {}
            // }
            //
            // The next modifier or 'function' keyword may be part of a member
            // declaration instead of being a continuation of the adaptation's
            // method reference.
            var methodName = void 0;
            if (this.isPossibleMemberDeclarationStart()) {
                // Since it is far more likely that the adaptation is incomplete in
                // this case, create a missing name now instead of consuming the name
                // and complaining about a missing 'as' or 'insteadof' in the middle
                // of the following declaration.
                methodName = this.createMissingToken(TokenKind_1.TokenKind.Identifier, this.currentToken.kind, false);
            }
            else {
                // Otherwise, a possible name is on the same line.
                if (this.isClassMemberIdentifier(this.currentToken.kind)) {
                    methodName = this.eat(this.currentToken.kind);
                    // NOTE: There should be no error correction here. If the parser
                    // encounters "<keyword> name" here, it cannot choose between:
                    //
                    //   A::<missing> <keyword> name  -or-
                    //   A::<keyword> <missing> name
                    //
                    // Additionally the user could also be adding an adaptation:
                    //
                    //   use A {
                    //     A::insteadof|  <-- cursor here
                    //     name as name;
                    //   }
                    //
                    // This may result in a slightly odd "keyword expected" error later.
                }
                else {
                    methodName = this.createMissingToken(TokenKind_1.TokenKind.Identifier, this.currentToken.kind, false);
                }
            }
            if (methodName.isMissing) {
                methodName = this.addError(methodName, ErrorCode_Generated_1.ErrorCode.ERR_MethodNameExpected);
            }
            // The reference is FINALLY complete!
            var reference = new Node_Generated_1.MethodReferenceNode(className, doubleColon, methodName);
            switch (this.currentToken.kind) {
                case TokenKind_1.TokenKind.As:
                    adaptations.push(this.parseTraitAlias(reference));
                    break;
                case TokenKind_1.TokenKind.InsteadOf:
                    var insteadOfKeyword = this.eat(TokenKind_1.TokenKind.InsteadOf);
                    var names = this.parseQualifiedNameList();
                    var semicolon = this.parseStatementEnd();
                    adaptations.push(new Node_Generated_1.TraitPrecedenceNode(reference, insteadOfKeyword, names, semicolon));
                    break;
                default:
                    // If there was a problem with the reference, then it should already
                    // have a diagnostic that is more useful.
                    if (!doubleColon.isMissing && !methodName.isMissing) {
                        reference = this.addError(reference, ErrorCode_Generated_1.ErrorCode.ERR_TraitAdaptationKeywordExpected);
                    }
                    adaptations.push(new Node_Generated_1.IncompleteReferencedTraitAdaptationNode(reference));
                    break;
            }
        }
        return adaptations.length > 0 ? this.factory.createList(adaptations) : null;
    };
    /**
     * Parses a trait alias adaptation.
     *
     * Syntax:
     * - `trait-method AS IDENTIFIER`
     * - `trait-method AS non-modifier-keywords`
     * - `trait-method AS modifier member-name`
     * - `trait-method AS modifier`
     *
     * Where `trait-method` is:
     * - `member-name`
     * - `method-reference`
     */
    PhpParser.prototype.parseTraitAlias = function (methodNameOrReference) {
        var asKeyword = this.eat(TokenKind_1.TokenKind.As);
        var modifier = null;
        var alias = null;
        // If a trait use statement is being added, the next token may be part of
        // a declaration on the following line.
        //
        //   class A {
        //     use B {
        //       foo as|  <-- cursor here
        //     public function x() {}
        //   }
        //
        // In which case, the alias should end, instead of creating additional
        // diagnostics in the declaration.
        if (this.isPossibleMemberDeclarationStart()) {
            alias = this.createMissingTokenWithError(TokenKind_1.TokenKind.Identifier, ErrorCode_Generated_1.ErrorCode.ERR_MethodNameExpected);
        }
        else {
            var flag = this.getModifierFlag(this.currentToken.kind);
            if (flag !== ModifierFlags_1.ModifierFlags.None) {
                modifier = this.eat(this.currentToken.kind);
                if ((flag & ModifierFlags_1.ModifierFlags.VisibilityMask) === 0) {
                    modifier = this.addError(modifier, ErrorCode_Generated_1.ErrorCode.ERR_BadTraitAliasModifier, TokenKind_1.TokenKindInfo.getText(modifier.kind));
                }
            }
            if (this.isClassMemberIdentifier(this.currentToken.kind)) {
                alias = this.eat(this.currentToken.kind);
            }
            else if (modifier === null) {
                alias = this.createMissingTokenWithError(TokenKind_1.TokenKind.Identifier, ErrorCode_Generated_1.ErrorCode.ERR_MethodNameExpected);
            }
        }
        // At a minimum, an alias must contain a modifier or (missing) name.
        php_common_1.Debug.assert(!(modifier === null && alias === null));
        var semicolon = this.parseStatementEnd();
        return methodNameOrReference instanceof TokenNode_1.TokenNode
            ? new Node_Generated_1.NamedTraitAliasNode(methodNameOrReference, asKeyword, modifier, alias, semicolon)
            : new Node_Generated_1.ReferencedTraitAliasNode(methodNameOrReference, asKeyword, modifier, alias, semicolon);
    };
    /**
     * Parses a trait declaration statement.
     *
     * Syntax: `TRAIT name { trait-member-declarations }`
     */
    PhpParser.prototype.parseTraitDeclaration = function () {
        var traitKeyword = this.eat(TokenKind_1.TokenKind.Trait);
        var identifier = this.eat(TokenKind_1.TokenKind.Identifier);
        var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
        var members = null;
        if (!identifier.isMissing && !openBrace.isMissing) {
            members = this.parseClassMembers(16384 /* TraitMembers */);
        }
        var closeBrace = openBrace.isMissing
            ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
            : this.eat(TokenKind_1.TokenKind.CloseBrace);
        return new Node_Generated_1.TraitDeclarationNode(traitKeyword, identifier, openBrace, members, closeBrace);
    };
    /**
     * Parses a trait import statement (also known as a trait use clause).
     *
     * Syntax:
     * - `USE qualified-name-list ;`
     * - `USE qualified-name-list { trait-adaptation-list }`
     */
    PhpParser.prototype.parseTraitUse = function (context) {
        var useKeyword = this.eat(TokenKind_1.TokenKind.Use);
        if (context === 8192 /* InterfaceMembers */) {
            useKeyword = this.addError(useKeyword, ErrorCode_Generated_1.ErrorCode.ERR_InterfaceTrait);
        }
        var names = this.parseQualifiedNameList();
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace) {
            var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
            var adaptations = this.parseTraitAdaptationList();
            var closeBrace = openBrace.isMissing
                ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
                : this.eat(TokenKind_1.TokenKind.CloseBrace);
            return new Node_Generated_1.TraitUseGroupNode(useKeyword, names, openBrace, adaptations, closeBrace);
        }
        var semicolon = this.isStatementEnd(this.currentToken.kind)
            ? this.parseStatementEnd()
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, ErrorCode_Generated_1.ErrorCode.ERR_IncompleteTraitUse);
        return new Node_Generated_1.TraitUseNode(useKeyword, names, semicolon);
    };
    /**
     * Parses a try statement.
     *
     * Syntax:
     *  - `TRY { statement-list } catch-list`
     *  - `TRY { statement-list } catch-list finally-clause`
     *  - `TRY { statement-list } finally-clause`
     *
     * Where `catch-list` is:
     * - `catch-list catch-clause`
     * - `catch-clause`
     */
    PhpParser.prototype.parseTry = function () {
        var tryKeyword = this.eat(TokenKind_1.TokenKind.Try);
        var statements = this.parseStatementBlock();
        var hasCatchOrFinally = false;
        var catchClause = null;
        if (this.currentToken.kind === TokenKind_1.TokenKind.Catch) {
            var catches = [];
            while (this.currentToken.kind === TokenKind_1.TokenKind.Catch) {
                catches.push(this.parseTryCatch());
            }
            if (catches.length > 0) {
                catchClause = this.factory.createList(catches);
            }
            hasCatchOrFinally = true;
        }
        var finallyClause = null;
        if (this.currentToken.kind === TokenKind_1.TokenKind.Finally) {
            finallyClause = this.parseTryFinally();
            hasCatchOrFinally = true;
        }
        if (!hasCatchOrFinally) {
            // @todo Implement INode.GetLastToken(/* allowMissing = false */) and
            //   append diagnostic to the try-statement's block using calculated
            //   offsets instead of making an artificial finally clause.
            var finallyKeyword = this.createMissingTokenWithError(TokenKind_1.TokenKind.Finally, ErrorCode_Generated_1.ErrorCode.ERR_CatchOrFinallyExpected);
            var openBrace = this.createMissingToken(TokenKind_1.TokenKind.OpenBrace, this.currentToken.kind, false);
            var closeBrace = this.createMissingToken(TokenKind_1.TokenKind.OpenBrace, this.currentToken.kind, false);
            var finallyBlock = new Node_Generated_1.StatementBlockNode(openBrace, null, closeBrace);
            finallyClause = new Node_Generated_1.TryFinallyNode(finallyKeyword, finallyBlock);
        }
        return new Node_Generated_1.TryNode(tryKeyword, statements, catchClause, finallyClause);
    };
    /**
     * Parses a try statement's catch clause.
     *
     * Syntax: `CATCH ( catch-name-list VARIABLE ) { statement-list }`
     *
     * Where `catch-name-list` is:
     * - `catch-name-list | qualified-name`
     * - `qualified-name`
     */
    PhpParser.prototype.parseTryCatch = function () {
        var catchKeyword = this.eat(TokenKind_1.TokenKind.Catch);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var types = [];
        types.push(this.parseTypeName());
        // @todo Implement `CatchClause` parse context?
        var kind = this.currentToken.kind;
        while (kind !== TokenKind_1.TokenKind.Dollar && kind !== TokenKind_1.TokenKind.Variable && kind !== TokenKind_1.TokenKind.CloseParen && kind !== TokenKind_1.TokenKind.EOF) {
            if (kind === TokenKind_1.TokenKind.VerticalBar || this.isNameStart(kind)) {
                types.push(this.eat(TokenKind_1.TokenKind.VerticalBar));
                types.push(this.parseTypeName());
                kind = this.currentToken.kind;
                continue;
            }
            if (this.isTokenValidInContexts(this.currentToken.kind)) {
                break;
            }
            this.skipToken();
            kind = this.currentToken.kind;
        }
        var typeUnion = this.factory.createList(types);
        if (types.length > 1 && !this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_1)) {
            typeUnion = this.addError(typeUnion, ErrorCode_Generated_1.ErrorCode.ERR_FeatureTryCatchUnionTypes);
        }
        var variable; // See also: parseParameter().
        if (this.currentToken.kind === TokenKind_1.TokenKind.Dollar) {
            variable = this.eat(TokenKind_1.TokenKind.Dollar);
            variable = this.addError(variable, ErrorCode_Generated_1.ErrorCode.ERR_VariableNameExpected);
        }
        else {
            variable = this.currentToken.kind === TokenKind_1.TokenKind.Variable
                ? this.eat(TokenKind_1.TokenKind.Variable)
                : this.createMissingTokenWithError(TokenKind_1.TokenKind.Variable, ErrorCode_Generated_1.ErrorCode.ERR_TryUnionOrVariableExpected);
        }
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        var statements = this.parseStatementBlock();
        return new Node_Generated_1.TryCatchNode(catchKeyword, openParen, typeUnion, variable, closeParen, statements);
    };
    /**
     * Parses a try statement's finally clause.
     *
     * Syntax: `FINALLY { statement-list }`
     */
    PhpParser.prototype.parseTryFinally = function () {
        var finallyKeyword = this.eat(TokenKind_1.TokenKind.Finally);
        var statements = this.parseStatementBlock();
        return new Node_Generated_1.TryFinallyNode(finallyKeyword, statements);
    };
    /**
     * Parses a (nullable) type.
     *
     * Syntax: `? type`
     */
    PhpParser.prototype.parseType = function ( /* isNullable = true */) {
        var question = this.eatOptional(TokenKind_1.TokenKind.Question);
        if (question !== null && !this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_1)) {
            question = this.addError(question, ErrorCode_Generated_1.ErrorCode.ERR_FeatureNullableTypes);
        }
        if (this.currentToken.kind === TokenKind_1.TokenKind.Array || this.currentToken.kind === TokenKind_1.TokenKind.Callable) {
            var typeKeyword = this.eat(this.currentToken.kind);
            return new Node_Generated_1.PredefinedTypeNode(question, typeKeyword);
        }
        var name = this.parseTypeName();
        return new Node_Generated_1.NamedTypeNode(question, name);
    };
    /**
     * Parses a qualified name that should be a type.
     *
     * This method is equivalent to `parseQualifiedName()`, but uses a custom
     * error message when the name is missing.
     */
    PhpParser.prototype.parseTypeName = function () {
        if (this.isNameStart(this.currentToken.kind)) {
            return this.parseQualifiedName();
        }
        var identifier = this.createMissingTokenWithError(TokenKind_1.TokenKind.Identifier, ErrorCode_Generated_1.ErrorCode.ERR_TypeExpected);
        var namespaceNames = this.factory.createList([identifier]);
        return new Node_Generated_1.PartiallyQualifiedNameNode(namespaceNames);
    };
    /**
     * Parses an unset statement.
     *
     * Syntax: `UNSET ( unset-list ) ;`
     *
     * Where `unset-list` is:
     * - `unset-list , expr`
     * - `expr`
     */
    PhpParser.prototype.parseUnset = function () {
        var unsetKeyword = this.eat(TokenKind_1.TokenKind.Unset);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var expressions = [];
        expressions.push(this.parseExpression(ExpressionType_1.ExpressionType.Explicit));
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            var comma = this.eat(TokenKind_1.TokenKind.Comma);
            if (!this.isExpressionStart(this.currentToken.kind)) {
                if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_3)) {
                    comma = this.addError(comma, ErrorCode_Generated_1.ErrorCode.ERR_FeatureTrailingCommasInArgumentLists);
                }
                expressions.push(comma);
                break;
            }
            else {
                expressions.push(comma);
                expressions.push(this.parseExpression(ExpressionType_1.ExpressionType.Explicit));
            }
        }
        var closeParen = this.currentToken.kind === TokenKind_1.TokenKind.CloseParen
            ? this.eat(TokenKind_1.TokenKind.CloseParen)
            : expressions.length & 1
                ? this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, ErrorCode_Generated_1.ErrorCode.ERR_CommaOrCloseParenExpected)
                : this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrCloseParenExpected);
        var semicolon = this.parseStatementEnd();
        return new Node_Generated_1.UnsetNode(unsetKeyword, openParen, this.factory.createList(expressions), closeParen, semicolon);
    };
    /**
     * @todo Document parseUseDeclaration().
     */
    PhpParser.prototype.parseUseDeclaration = function () {
        var useKeyword = this.eat(TokenKind_1.TokenKind.Use);
        var useType = this.currentToken.kind === TokenKind_1.TokenKind.Const || this.currentToken.kind === TokenKind_1.TokenKind.Function
            ? this.eat(this.currentToken.kind) : null;
        var leadingBackslash = this.eatOptional(TokenKind_1.TokenKind.Backslash);
        var names;
        if (this.currentToken.kind === TokenKind_1.TokenKind.Identifier) {
            names = this.parseNamespaceName(false);
        }
        else {
            var code_1 = (useType !== null || leadingBackslash !== null) ? ErrorCode_Generated_1.ErrorCode.ERR_IdentifierExpected : ErrorCode_Generated_1.ErrorCode.ERR_UseTypeExpected;
            var identifier = this.createMissingTokenWithError(TokenKind_1.TokenKind.Identifier, code_1);
            names = [identifier];
        }
        if (names[names.length - 1].kind === TokenKind_1.TokenKind.Backslash) {
            // An opening brace must be present to parse a group declaration. If it
            // is not, then a simple use declaration is probably being added instead.
            //
            //   use A\B\|  <-- cursor here
            //
            if (this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace) {
                var hasUseType = useType !== null;
                var rootNames = leadingBackslash ? [leadingBackslash].concat(names) : names;
                var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
                var elements = [];
                elements.push(this.parseUseGroupElement(hasUseType));
                // Suppress TS2365: Current token changed after previous method call.
                while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
                    var comma = this.eat(TokenKind_1.TokenKind.Comma);
                    if (!this.isUseGroupElementStart(this.currentToken.kind) && this.currentToken.kind !== TokenKind_1.TokenKind.Comma) {
                        if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_2)) {
                            comma = this.addError(comma, ErrorCode_Generated_1.ErrorCode.ERR_FeatureTrailingCommasInUseDeclarations);
                        }
                        elements.push(comma);
                        break;
                    }
                    else {
                        elements.push(comma);
                        elements.push(this.parseUseGroupElement(hasUseType));
                    }
                }
                // Error recovery is greatly simplified when everything can end in a
                // closing brace. It is just a matter of picking the right message...
                var closeBrace = void 0;
                if (this.currentToken.kind === TokenKind_1.TokenKind.CloseBrace) {
                    closeBrace = this.eat(TokenKind_1.TokenKind.CloseBrace);
                }
                else {
                    var code_2;
                    if (elements.length & 1) {
                        // Odd: Ended in use element.
                        var lastElement_1 = elements[elements.length - 1];
                        code_2 = lastElement_1.asKeyword !== null ? ErrorCode_Generated_1.ErrorCode.ERR_CommaOrCloseBraceExpected : ErrorCode_Generated_1.ErrorCode.ERR_IncompleteUseGroupDeclaration;
                    }
                    else {
                        // Even: Ended in comma.
                        code_2 = hasUseType ? ErrorCode_Generated_1.ErrorCode.ERR_IdentifierOrCloseBraceExpected : ErrorCode_Generated_1.ErrorCode.ERR_UseTypeOrCloseBraceExpected;
                    }
                    closeBrace = this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseBrace, code_2);
                }
                var semicolon_1 = this.parseStatementEnd();
                return new Node_Generated_1.UseGroupDeclarationNode(useKeyword, useType, this.factory.createList(rootNames), openBrace, this.factory.createList(elements), closeBrace, semicolon_1);
            }
            // The name is more likely to be incomplete.
            var identifier = this.createMissingTokenWithError(TokenKind_1.TokenKind.Identifier, ErrorCode_Generated_1.ErrorCode.ERR_IncompleteUseName);
            names.push(identifier);
        }
        var nodes = [];
        // Create the first element since the name has already been parsed.
        var typeName = leadingBackslash
            ? new Node_Generated_1.FullyQualifiedNameNode(leadingBackslash, this.factory.createList(names))
            : new Node_Generated_1.PartiallyQualifiedNameNode(this.factory.createList(names));
        var asKeyword = this.eatOptional(TokenKind_1.TokenKind.As);
        var alias = asKeyword !== null ? this.eat(TokenKind_1.TokenKind.Identifier) : null;
        nodes.push(new Node_Generated_1.UseElementNode(null, typeName, asKeyword, alias));
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            nodes.push(this.eat(TokenKind_1.TokenKind.Comma));
            nodes.push(this.parseUseElement());
        }
        var lastElement = nodes[nodes.length - 1];
        var code = lastElement.asKeyword !== null
            ? ErrorCode_Generated_1.ErrorCode.ERR_CommaOrSemicolonExpected
            : ErrorCode_Generated_1.ErrorCode.ERR_IncompleteUseDeclaration;
        var semicolon = this.isStatementEnd(this.currentToken.kind)
            ? this.parseStatementEnd()
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Semicolon, code);
        return new Node_Generated_1.UseDeclarationNode(useKeyword, useType, this.factory.createList(nodes), semicolon);
    };
    /**
     * Parses a use element.
     *
     * Syntax: `use-inline-name AS IDENTIFIER`
     *
     * Where `use-inline-name` is:
     * - `name`
     * - `\ name`
     */
    PhpParser.prototype.parseUseElement = function () {
        var name = this.parseQualifiedName(false);
        var asKeyword = this.eatOptional(TokenKind_1.TokenKind.As);
        var alias = asKeyword !== null ? this.eat(TokenKind_1.TokenKind.Identifier) : null;
        return new Node_Generated_1.UseElementNode(null, name, asKeyword, alias);
    };
    /**
     * Parses a group use element.
     *
     * Syntax: `use-type name AS IDENTIFIER`
     *
     * Where `use-type` is:
     * - `CONST`
     * - `FUNCTION`
     *
     * @param {boolean} hasGroupUseType
     *   When `true`, the use declaration already specifies a type, and any use
     *   types found inside this clause should generate an error.
     */
    PhpParser.prototype.parseUseGroupElement = function (hasGroupUseType) {
        var useType = this.currentToken.kind === TokenKind_1.TokenKind.Const || this.currentToken.kind === TokenKind_1.TokenKind.Function
            ? this.eat(this.currentToken.kind) : null;
        if (useType !== null && hasGroupUseType) {
            useType = this.addError(useType, ErrorCode_Generated_1.ErrorCode.ERR_UseTypeAlreadySpecified);
        }
        var name;
        if (this.currentToken.kind !== TokenKind_1.TokenKind.Identifier) {
            var code = (useType !== null || hasGroupUseType) ? ErrorCode_Generated_1.ErrorCode.ERR_IdentifierExpected : ErrorCode_Generated_1.ErrorCode.ERR_UseTypeExpected;
            var identifier = this.createMissingTokenWithError(TokenKind_1.TokenKind.Identifier, code);
            var namespaceName = this.factory.createList([identifier]);
            name = new Node_Generated_1.PartiallyQualifiedNameNode(namespaceName);
        }
        else {
            name = this.parsePartiallyQualifiedName();
        }
        var asKeyword = this.eatOptional(TokenKind_1.TokenKind.As);
        var alias = asKeyword !== null ? this.eat(TokenKind_1.TokenKind.Identifier) : null;
        return new Node_Generated_1.UseElementNode(useType, name, asKeyword, alias);
    };
    /**
     * Parses a while statement.
     *
     * Syntax:
     * - `WHILE ( expr ) statement`
     * - `WHILE ( expr ) : statement-list ENDWHILE ;`
     */
    PhpParser.prototype.parseWhile = function () {
        var whileKeyword = this.eat(TokenKind_1.TokenKind.While);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var condition = this.parseExpression();
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        if (this.currentToken.kind === TokenKind_1.TokenKind.Colon) {
            var colon = this.eat(TokenKind_1.TokenKind.Colon);
            var statements = this.parseList(256 /* WhileBlockElements */);
            var endWhile = this.eat(TokenKind_1.TokenKind.EndWhile);
            var semicolon = this.parseStatementEnd();
            return new Node_Generated_1.WhileBlockNode(whileKeyword, openParen, condition, closeParen, colon, statements, endWhile, semicolon);
        }
        var statement = this.parseEmbeddedStatement(true, ErrorCode_Generated_1.ErrorCode.ERR_StatementOrColonExpected);
        return new Node_Generated_1.WhileNode(whileKeyword, openParen, condition, closeParen, statement);
    };
    // --------------------------------------------------------------------------
    // Productions (expressions)
    // --------------------------------------------------------------------------
    /**
     * Parses an expression.
     */
    PhpParser.prototype.parseExpression = function (expectedType, precedence) {
        if (expectedType === void 0) { expectedType = ExpressionType_1.ExpressionType.Any; }
        if (precedence === void 0) { precedence = Precedence_1.Precedence.None; }
        var expr = this.parseExpressionTree(expectedType, precedence);
        var exprNode = expr.node;
        // Add the mismatched expression type diagnostic, unless the expression
        // already contains an error; in which case, the parser should not make
        // any assumptions about the expression or its type.
        if (!exprNode.containsDiagnostics && expectedType === ExpressionType_1.ExpressionType.Explicit && expr.type === ExpressionType_1.ExpressionType.Implicit) {
            exprNode = this.addError(exprNode, ErrorCode_Generated_1.ErrorCode.ERR_ExpressionNotAddressable);
        }
        return exprNode;
    };
    /**
     * Parses an expression or, if possible, a statement.
     */
    PhpParser.prototype.parseExpressionOrTopStatement = function () {
        // A top-level expression has no expected type.
        var expr = this.parseExpressionTree(ExpressionType_1.ExpressionType.Any, Precedence_1.Precedence.None, true);
        if (expr.type !== ExpressionType_1.ExpressionType.Any) {
            php_common_1.Debug.assert(expr.node instanceof Node_Generated_1.ExpressionNode);
            var semicolon = this.parseStatementEnd();
            return new Node_Generated_1.ExpressionStatementNode(expr.node, semicolon);
        }
        else {
            php_common_1.Debug.assert(expr.node instanceof Node_Generated_1.StatementNode);
            return expr.node;
        }
    };
    /**
     * Parses a sequence of one or more operands and zero or more operators into
     * a tree-like structure representing an expression.
     *
     * @param {ExpressionType=} expectedType
     *   The expected type of the term.
     * @param {Precedence=} precedence
     *   The precedence of the operator prior to this expression term.
     * @param {boolean=} isStatementExpected
     *   If `true`, a statement may be parsed instead of an expression. Defaults
     *   to `false`.
     */
    PhpParser.prototype.parseExpressionTree = function (expectedType, precedence, isStatementExpected) {
        if (expectedType === void 0) { expectedType = ExpressionType_1.ExpressionType.Any; }
        if (precedence === void 0) { precedence = Precedence_1.Precedence.None; }
        if (isStatementExpected === void 0) { isStatementExpected = false; }
        var expr;
        var kind = this.currentToken.kind;
        if (this.isUnaryOperator(kind) && this.isUnaryOperatorExpected(kind, expectedType)) {
            // When a unary operator is encountered, the operand is treated as its
            // own independent expression, so the parser also expects a different
            // expression type for it as well.
            var unaryType = ExpressionType_1.ExpressionType.Any;
            // The operand of a prefix-increment or prefix-decrement expression
            // requires an explicitly declared variable however.
            if (kind === TokenKind_1.TokenKind.Decrement || kind === TokenKind_1.TokenKind.Increment) {
                unaryType = ExpressionType_1.ExpressionType.Explicit;
            }
            var unaryPrecedence = kind === TokenKind_1.TokenKind.Exclamation ? Precedence_1.Precedence.LogicalNot : Precedence_1.Precedence.Unary;
            var operator = this.eat(kind);
            var operand = this.parseExpression(unaryType, unaryPrecedence);
            var unaryNode = new Node_Generated_1.UnaryNode(operator, operand);
            if (kind === TokenKind_1.TokenKind.RealCast) {
                // No version check; deprecation warnings are retroactive.
                unaryNode = this.addError(unaryNode, ErrorCode_Generated_1.ErrorCode.WRN_RealCast);
            }
            if (kind === TokenKind_1.TokenKind.UnsetCast) {
                // No version check; deprecation warnings are retroactive.
                unaryNode = this.addError(unaryNode, ErrorCode_Generated_1.ErrorCode.WRN_UnsetCast);
            }
            expr = new Expression(unaryNode, ExpressionType_1.ExpressionType.Implicit);
        }
        else if (kind === TokenKind_1.TokenKind.Array || kind === TokenKind_1.TokenKind.OpenBracket) {
            expr = this.parseArrayOrDeconstruction();
        }
        else if (kind === TokenKind_1.TokenKind.Function) {
            expr = this.parseFunctionDeclarationOrClosure(isStatementExpected);
            if (expr.type === ExpressionType_1.ExpressionType.Any) {
                return expr; // Found a function declaration statement.
            }
        }
        else if (kind === TokenKind_1.TokenKind.Identifier) {
            expr = this.parseLabelOrExpression(isStatementExpected);
            if (expr.type === ExpressionType_1.ExpressionType.Any) {
                return expr; // Found a label declaration statement.
            }
        }
        else if (kind === TokenKind_1.TokenKind.Namespace) {
            expr = this.parseNamespaceDeclarationOrExpression(isStatementExpected);
            if (expr.type === ExpressionType_1.ExpressionType.Any) {
                return expr; // Found a namespace declaration statement.
            }
        }
        else if (kind === TokenKind_1.TokenKind.Static) {
            expr = this.parseStaticDeclarationOrExpression(isStatementExpected);
            if (expr.type === ExpressionType_1.ExpressionType.Any) {
                return expr; // Found a static variable declaration statement.
            }
        }
        else if (kind === TokenKind_1.TokenKind.List) {
            var lhs = this.parseListDestructure();
            var equal = this.eat(TokenKind_1.TokenKind.Equal);
            var rhs = this.parseExpression(ExpressionType_1.ExpressionType.Any, Precedence_1.Precedence.Assignment);
            var assignment = new Node_Generated_1.DestructuringAssignmentNode(lhs, equal, rhs);
            return new Expression(assignment, ExpressionType_1.ExpressionType.Implicit);
        }
        else {
            expr = this.parsePrimaryExpression(expectedType);
        }
        if (expr.type === ExpressionType_1.ExpressionType.Explicit) {
            expr = this.parsePostfixExpression(expr, expectedType);
        }
        // There are no binary expressions that result in an explicit expression.
        return expectedType === ExpressionType_1.ExpressionType.Explicit ? expr : this.parseBinaryExpression(expr, precedence);
    };
    /**
     * @todo Document parseBinaryExpression().
     */
    PhpParser.prototype.parseBinaryExpression = function (leftTerm, precedence) {
        if (precedence === void 0) { precedence = Precedence_1.Precedence.None; }
        // Statements should never be part of an expression.
        php_common_1.Debug.assert(leftTerm.node instanceof Node_Generated_1.ExpressionNode);
        var leftExpr = leftTerm.node;
        var leftType = leftTerm.type;
        // Operator precendence and associativity:
        // 1. low to high      a + b * c
        // 2. high to low      a * b + c
        // 3. same, left       a + b + c
        // 4. same, right      a ** b ** c
        // 5. same, non-assoc  a <= b <= c
        // @todo It is possible to exhaust the call stack here if a very long
        //   right associative expression is being parsed.
        // The precedence of the last operator parsed by this loop, which may not
        // be the same as the last operator that was parsed.
        var prevPrecedence = Precedence_1.Precedence.None;
        while (this.isBinaryOperator(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Question) {
            // The LHS of an assignment expression must have an explicit variable.
            if (leftType !== ExpressionType_1.ExpressionType.Explicit && this.isAssignmentOperator(this.currentToken.kind)) {
                break;
            }
            var nextPrecedence = this.getPrecedence(this.currentToken.kind);
            // All binary operators need a precedence.
            php_common_1.Debug.assert(nextPrecedence !== Precedence_1.Precedence.None);
            if (nextPrecedence < precedence && !this.isBinaryOperatorExpected(this.currentToken.kind, leftType)) {
                break;
            }
            if (nextPrecedence === precedence && !this.isRightAssociative(this.currentToken.kind)) {
                break;
            }
            if (nextPrecedence === prevPrecedence && this.isNonAssociative(this.currentToken.kind)) {
                break;
            }
            var operator = this.eat(this.currentToken.kind);
            var rightExpr = void 0;
            if (this.isAssignmentOperator(operator.kind)) {
                var ampersand = null;
                if (operator.kind === TokenKind_1.TokenKind.Equal && this.currentToken.kind === TokenKind_1.TokenKind.Ampersand) {
                    ampersand = this.eat(this.currentToken.kind);
                    rightExpr = this.parseExpression(ExpressionType_1.ExpressionType.Explicit, nextPrecedence);
                }
                else {
                    rightExpr = this.parseExpression(ExpressionType_1.ExpressionType.Any, nextPrecedence);
                }
                leftExpr = new Node_Generated_1.AssignmentNode(leftExpr, operator, ampersand, rightExpr);
            }
            else if (operator.kind === TokenKind_1.TokenKind.InstanceOf) {
                leftExpr = this.parseInstanceOf(leftExpr, operator);
            }
            else if (operator.kind === TokenKind_1.TokenKind.Question) {
                leftExpr = this.parseConditionalExpression(leftExpr, operator);
            }
            else {
                rightExpr = this.parseExpression(ExpressionType_1.ExpressionType.Any, nextPrecedence);
                leftExpr = new Node_Generated_1.BinaryNode(leftExpr, operator, rightExpr);
            }
            leftType = ExpressionType_1.ExpressionType.Implicit;
            prevPrecedence = nextPrecedence;
        }
        return new Expression(leftExpr, leftType);
    };
    /**
     * @todo Document parsePostfixExpression().
     */
    PhpParser.prototype.parsePostfixExpression = function (term, expectedType) {
        // Statements should not be reaching this point.
        php_common_1.Debug.assert(term.node instanceof Node_Generated_1.ExpressionNode);
        // The LHS of a postfix expression must have an explicit variable.
        php_common_1.Debug.assert(term.type === ExpressionType_1.ExpressionType.Explicit);
        var node = term.node;
        var type = term.type;
        while (type === ExpressionType_1.ExpressionType.Explicit) {
            switch (this.currentToken.kind) {
                case TokenKind_1.TokenKind.Decrement:
                case TokenKind_1.TokenKind.Increment:
                    // If an explicit expression is expected (only true for prefix-
                    // decrement, prefix-increment, and byref assignments), then the
                    // operand is complete.
                    //
                    //   ++$i|  <-- cursor here
                    //   ++$j;
                    //
                    // The parser should not continue and generate an "unusable address"
                    // diagnostic on the postfix expression.
                    if (expectedType === ExpressionType_1.ExpressionType.Explicit) {
                        return new Expression(node, type);
                    }
                    node = new Node_Generated_1.PostfixUnaryNode(node, this.eat(this.currentToken.kind));
                    type = ExpressionType_1.ExpressionType.Implicit;
                    break;
                case TokenKind_1.TokenKind.DoubleColon:
                    // @todo Is it possible for this method to just return the node?
                    var expr = this.parseScopedAccessOrInvocation(node, this.eat(TokenKind_1.TokenKind.DoubleColon));
                    node = expr.node;
                    type = expr.type;
                    break;
                case TokenKind_1.TokenKind.ObjectOperator:
                    node = this.parseMemberAccessOrInvocation(node, true);
                    break;
                case TokenKind_1.TokenKind.OpenBrace:
                case TokenKind_1.TokenKind.OpenBracket:
                    node = this.parseElementAccess(node);
                    break;
                case TokenKind_1.TokenKind.OpenParen:
                    node = this.parseFunctionInvocation(node);
                    break;
                default:
                    return new Expression(node, type);
            }
        }
        // Found an expression that changed to an implicit type.
        return new Expression(node, type);
    };
    /**
     * @todo Document parsePrimaryExpression().
     */
    PhpParser.prototype.parsePrimaryExpression = function (expectedType) {
        var expr = null;
        var type = ExpressionType_1.ExpressionType.Any;
        switch (this.currentToken.kind) {
            // Implicit expressions.
            case TokenKind_1.TokenKind.At:
                expr = this.parseErrorControl();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.Clone:
                expr = this.parseClone();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.DNumber:
            case TokenKind_1.TokenKind.LNumber:
                expr = new Node_Generated_1.LiteralNode(this.eat(this.currentToken.kind));
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.Empty:
                expr = this.parseEmpty();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.Eval:
                expr = this.parseEval();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.Die:
            case TokenKind_1.TokenKind.Exit:
                expr = this.parseExit();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.FlexdocTemplate:
                expr = this.parseFlexdocTemplate();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.Fn:
                expr = this.parseArrowFunction(null);
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.HeredocTemplate:
                expr = this.parseHeredocTemplate();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.Include:
            case TokenKind_1.TokenKind.IncludeOnce:
            case TokenKind_1.TokenKind.Require:
            case TokenKind_1.TokenKind.RequireOnce:
                expr = this.parseScriptInclusion();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.IsSet:
                expr = this.parseIsSet();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.MagicClass:
            case TokenKind_1.TokenKind.MagicDirectory:
            case TokenKind_1.TokenKind.MagicFile:
            case TokenKind_1.TokenKind.MagicFunction:
            case TokenKind_1.TokenKind.MagicLine:
            case TokenKind_1.TokenKind.MagicMethod:
            case TokenKind_1.TokenKind.MagicNamespace:
            case TokenKind_1.TokenKind.MagicTrait:
                // Technically this could use a custom node.
                expr = new Node_Generated_1.LiteralNode(this.eat(this.currentToken.kind));
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.New:
                expr = this.parseObjectCreationExpression();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.Print:
                expr = this.parsePrint();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.ShellCommandTemplate:
                expr = this.parseShellCommandTemplate();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.StringTemplate:
                expr = this.parseStringTemplate();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.Yield:
                expr = this.parseYield();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            case TokenKind_1.TokenKind.YieldFrom:
                expr = this.parseYieldFrom();
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
            // Explicit expressions.
            case TokenKind_1.TokenKind.Dollar:
            case TokenKind_1.TokenKind.Variable:
                expr = this.parseSimpleVariable();
                type = ExpressionType_1.ExpressionType.Explicit;
                break;
            // Undetermined expressions.
            case TokenKind_1.TokenKind.Backslash:
            case TokenKind_1.TokenKind.Namespace:
                // A name is only implicit when used to reference a constant.
                var name_1 = this.parseQualifiedName();
                return this.parseNamedExpression(name_1);
            case TokenKind_1.TokenKind.OpenParen:
                // A parenthetical expression may be implicit if it is standalone or
                // used to access a class constant, otherwise it is explicit.
                return this.parseExpressionGroup();
            case TokenKind_1.TokenKind.StringLiteral:
                // String literals are implicit if there is no dereference.
                return this.parseStringLiteral();
            default:
                // This point should have been reached intentionally. If not, then the
                // parser may not move forward and could enter an infinite loop.
                php_common_1.Debug.assert(!this.isExpressionStart(this.currentToken.kind) ||
                    (this.isUnaryOperator(this.currentToken.kind) && !this.isUnaryOperatorExpected(this.currentToken.kind, expectedType)));
                // @todo Use variable if expectedType is explicit and identifier otherwise?
                var variable = this.createMissingToken(TokenKind_1.TokenKind.Variable, this.currentToken.kind, false);
                // Except for EOF, the text of all tokens being used in the error
                // message is known, as all other categories are pre-defined, ignored
                // (trivia), or would have started an expression.
                variable = this.currentToken.kind === TokenKind_1.TokenKind.EOF
                    ? this.addError(variable, ErrorCode_Generated_1.ErrorCode.ERR_ExpressionExpectedEOF)
                    : this.addError(variable, ErrorCode_Generated_1.ErrorCode.ERR_ExpressionExpected, TokenKind_1.TokenKindInfo.getText(this.currentToken.kind));
                expr = new Node_Generated_1.LocalVariableNode(variable);
                type = ExpressionType_1.ExpressionType.Implicit;
                break;
        }
        return new Expression(expr, type);
    };
    // --------------------------------------------------------------------------
    /**
     * Parses an anonymous class.
     *
     * Syntax:
     * - `CLASS class-base-clause class-interface-clause { class-member-declarations }`
     * - `CLASS ( argument-list ) class-base-clause class-interface-clause { class-member-declarations }`
     *
     * @see PhpParser.parseObjectCreationExpression()
     */
    PhpParser.prototype.parseAnonymousClass = function () {
        var classKeyword = this.eat(TokenKind_1.TokenKind.Class);
        var openParen = null;
        var argumentList = null;
        var closeParen = null;
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
            var invocationArgs = this.parseArgumentList();
            openParen = invocationArgs.openParen;
            argumentList = invocationArgs.argumentList;
            closeParen = invocationArgs.closeParen;
        }
        var extendsKeyword = this.eatOptional(TokenKind_1.TokenKind.Extends);
        var baseType = null;
        if (extendsKeyword !== null) {
            baseType = this.parseTypeName();
        }
        var implementsKeyword = this.eatOptional(TokenKind_1.TokenKind.Implements);
        var interfaces = null;
        if (implementsKeyword !== null) {
            interfaces = this.parseQualifiedNameList();
        }
        var code = openParen !== null
            ? ErrorCode_Generated_1.ErrorCode.ERR_IncompleteClassDeclaration
            : ErrorCode_Generated_1.ErrorCode.ERR_IncompleteAnonymousClassDeclaration;
        var openBrace = this.currentToken.kind !== TokenKind_1.TokenKind.OpenBrace && extendsKeyword === null && implementsKeyword === null
            ? this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenBrace, code)
            : this.eat(TokenKind_1.TokenKind.OpenBrace);
        var members = null;
        if (!openBrace.isMissing) {
            members = this.parseClassMembers(4096 /* ClassMembers */);
        }
        var closeBrace = openBrace.isMissing
            ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
            : this.eat(TokenKind_1.TokenKind.CloseBrace);
        return new Node_Generated_1.AnonymousClassNode(classKeyword, openParen, argumentList, closeParen, extendsKeyword, baseType, implementsKeyword, interfaces, openBrace, members, closeBrace);
    };
    /**
     * Parses a list of arguments in an anonymous class, invocation, or object
     * creation expression.
     *
     * Syntax: `( argument-list )`
     *
     * Where `argument-list` is:
     * - `argument-list , argument`
     * - `argument`
     *
     * Where `argument` is:
     * - `ELLIPSIS expr`
     * - `expr`
     */
    PhpParser.prototype.parseArgumentList = function () {
        var args = [];
        var hasUnpack = false;
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        if (!openParen.isMissing) {
            if (this.isArgumentStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
                var ellipsis = this.eatOptional(TokenKind_1.TokenKind.Ellipsis);
                var value = this.parseExpression();
                args.push(new Node_Generated_1.ArgumentNode(ellipsis, value));
                if (ellipsis !== null) {
                    hasUnpack = true;
                }
            }
            while (this.currentToken.kind !== TokenKind_1.TokenKind.CloseParen && this.currentToken.kind !== TokenKind_1.TokenKind.EOF) {
                if (this.isArgumentStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
                    var comma = this.eat(TokenKind_1.TokenKind.Comma);
                    if (!this.isArgumentStart(this.currentToken.kind)) {
                        if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_3)) {
                            comma = this.addError(comma, ErrorCode_Generated_1.ErrorCode.ERR_FeatureTrailingCommasInArgumentLists);
                        }
                        args.push(comma);
                        break;
                    }
                    args.push(comma);
                    var ellipsis = this.eatOptional(TokenKind_1.TokenKind.Ellipsis);
                    var value = this.parseExpression();
                    if (ellipsis === null && hasUnpack) {
                        value = this.addError(value, ErrorCode_Generated_1.ErrorCode.ERR_ArgumentAfterUnpack);
                    }
                    args.push(new Node_Generated_1.ArgumentNode(ellipsis, value));
                    if (ellipsis !== null) {
                        hasUnpack = true;
                    }
                    continue;
                }
                this.skipBadArgumentListTokens();
            }
        }
        var closeParen;
        if (openParen.isMissing) {
            closeParen = this.createMissingToken(TokenKind_1.TokenKind.CloseParen, this.currentToken.kind, false);
        }
        else if (this.currentToken.kind === TokenKind_1.TokenKind.CloseParen) {
            closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        }
        else {
            var code = void 0;
            if (args.length & 1) {
                // Odd: Ended in an argument.
                code = ErrorCode_Generated_1.ErrorCode.ERR_CommaOrCloseParenExpected;
            }
            else {
                // Even: Either there were no arguments or the list ended in a comma.
                code = hasUnpack ? ErrorCode_Generated_1.ErrorCode.ERR_EllipsisOrCloseParenExpected : ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrCloseParenExpected;
            }
            closeParen = this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, code);
        }
        // NOTE: It is not ideal to create these short-lived objects during a parse,
        // but it also allows the current node structure to remain, while also
        // standardizing how argument lists are parsed.
        return new InvocationArguments(openParen, args.length > 0 ? this.factory.createList(args) : null, closeParen);
    };
    /**
     * Parses an array initializer or list deconstruction.
     *
     * Syntax:
     * - `ARRAY ( array-elements )`
     * - `[ array-elements ]`
     */
    PhpParser.prototype.parseArray = function () {
        if (this.currentToken.kind === TokenKind_1.TokenKind.Array) {
            var arrayKeyword = this.eat(TokenKind_1.TokenKind.Array);
            var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
            var arrayList_1 = this.parseArrayElementList(TokenKind_1.TokenKind.CloseParen);
            var closeParen = void 0;
            // Suppress TS2365: Current token changed after previous method call.
            if (this.currentToken.kind === TokenKind_1.TokenKind.CloseParen) {
                closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
            }
            else {
                var code_3 = arrayList_1.length === 0 || (arrayList_1[arrayList_1.length - 1] instanceof TokenNode_1.TokenNode)
                    ? ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrCloseParenExpected
                    : ErrorCode_Generated_1.ErrorCode.ERR_CloseParenExpected;
                closeParen = this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, code_3);
            }
            return new Node_Generated_1.ArrayNode(arrayKeyword, openParen, arrayList_1.length > 0 ? this.factory.createList(arrayList_1) : null, closeParen);
        }
        var openBracket = this.eat(TokenKind_1.TokenKind.OpenBracket);
        var arrayList = this.parseArrayElementList(TokenKind_1.TokenKind.CloseBracket);
        var code = arrayList.length === 0 || (arrayList[arrayList.length - 1] instanceof TokenNode_1.TokenNode)
            ? ErrorCode_Generated_1.ErrorCode.ERR_IncompleteArrayOrDestructure
            : ErrorCode_Generated_1.ErrorCode.ERR_CloseBracketExpected;
        var closeBracket = this.currentToken.kind === TokenKind_1.TokenKind.CloseBracket
            ? this.eat(TokenKind_1.TokenKind.CloseBracket)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseBracket, code);
        return new Node_Generated_1.ArrayNode(null, openBracket, arrayList.length > 0 ? this.factory.createList(arrayList) : null, closeBracket);
    };
    /**
     * Parses a comma-separated list of array elements.
     *
     * @param {TokenKind} end
     *   The token used to terminate the array.
     */
    PhpParser.prototype.parseArrayElementList = function (end) {
        var pairs = [];
        if (this.isArrayElementStart(this.currentToken.kind)) {
            pairs.push(this.parseArrayElement());
        }
        while (this.currentToken.kind !== end && this.currentToken.kind !== TokenKind_1.TokenKind.EOF) {
            if (this.currentToken.kind === TokenKind_1.TokenKind.Comma || this.isArrayElementStart(this.currentToken.kind)) {
                pairs.push(this.eat(TokenKind_1.TokenKind.Comma));
                // A trailing comma is legal.
                if (this.isArrayElementStart(this.currentToken.kind)) {
                    pairs.push(this.parseArrayElement());
                }
                continue;
            }
            if (this.isTokenValidInContexts(this.currentToken.kind)) {
                break;
            }
            this.skipToken();
        }
        return pairs;
    };
    /**
     * Parses an element of an array initializer.
     *
     * Syntax:
     * - `expr`
     * - `expr => expr`
     * - `& expr`
     * - `expr => & expr`
     * - `... expr`
     */
    PhpParser.prototype.parseArrayElement = function () {
        var ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
        if (ampersand !== null) {
            var byRefValue = this.parseExpression(ExpressionType_1.ExpressionType.Explicit);
            return new Node_Generated_1.ArrayElementNode(null, null, ampersand, byRefValue);
        }
        var ellipsis = this.eatOptional(TokenKind_1.TokenKind.Ellipsis);
        if (ellipsis !== null) {
            if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_4)) {
                ellipsis = this.addError(ellipsis, ErrorCode_Generated_1.ErrorCode.ERR_FeatureSpreadOperatorInArrays);
            }
            var spreadValue = this.parseExpression();
            return new Node_Generated_1.ArrayElementNode(null, null, ellipsis, spreadValue);
        }
        var key = null;
        var doubleArrow = null;
        var value = this.parseExpression();
        if (this.currentToken.kind === TokenKind_1.TokenKind.DoubleArrow) {
            key = value;
            doubleArrow = this.eat(TokenKind_1.TokenKind.DoubleArrow);
            ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
            value = this.parseExpression(ampersand ? ExpressionType_1.ExpressionType.Explicit : ExpressionType_1.ExpressionType.Any);
        }
        return new Node_Generated_1.ArrayElementNode(key, doubleArrow, ampersand, value);
    };
    /**
     * @todo Document parseArrayOrDeconstruction().
     */
    PhpParser.prototype.parseArrayOrDeconstruction = function () {
        var arrayLiteral;
        if (this.currentToken.kind === TokenKind_1.TokenKind.Array) {
            arrayLiteral = this.parseArray();
        }
        else {
            // Short syntax.
            arrayLiteral = this.parseArray();
            if (this.currentToken.kind === TokenKind_1.TokenKind.Equal) {
                if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_1)) {
                    arrayLiteral = this.addError(arrayLiteral, ErrorCode_Generated_1.ErrorCode.ERR_FeatureListDeconstructionShortSyntax);
                }
                var operator = this.eat(TokenKind_1.TokenKind.Equal);
                var rhs = this.parseExpression(ExpressionType_1.ExpressionType.Any, Precedence_1.Precedence.Assignment);
                var assignment = new Node_Generated_1.DestructuringAssignmentNode(arrayLiteral, operator, rhs);
                return new Expression(assignment, ExpressionType_1.ExpressionType.Implicit);
            }
        }
        // An array is implicit if there is no dereference.
        var type = ExpressionType_1.ExpressionType.Implicit;
        // NOTE: While PHP does allow an object operator after an array, it always
        // leads to an error. Additionally, while arrays cannot normally be used
        // with an argument list there is one exception:
        //
        //   ['class_name', 'method_name']();
        //
        // In this scenario, the array must only contain two elements that can be
        // converted to a string, and then a static method call.
        if (this.isElementAccessStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
            type = ExpressionType_1.ExpressionType.Explicit;
        }
        return new Expression(arrayLiteral, type);
    };
    /**
     * Parses an anonymous function (closure) that returns an expression.
     *
     * Syntax:
     * - `FN & ( parameter-list ) return-type => expr`
     * - `STATIC FN & ( parameter-list ) return-type => expr`
     */
    PhpParser.prototype.parseArrowFunction = function (staticKeyword) {
        var fnKeyword = this.eat(TokenKind_1.TokenKind.Fn);
        var ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
        var openParen;
        var parameters;
        var closeParen;
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
            var parameterList = this.parseParameterList();
            openParen = parameterList.openParen;
            parameters = parameterList.parameterList;
            closeParen = parameterList.closeParen;
        }
        else {
            var code = ampersand !== null ? ErrorCode_Generated_1.ErrorCode.ERR_OpenParenExpected : ErrorCode_Generated_1.ErrorCode.ERR_IncompleteArrowFunction;
            openParen = this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenParen, code);
            parameters = null;
            closeParen = this.createMissingToken(TokenKind_1.TokenKind.CloseParen, this.currentToken.kind, false);
        }
        var colon = this.eatOptional(TokenKind_1.TokenKind.Colon);
        var returnType = colon !== null ? this.parseType() : null;
        var doubleArrow;
        if (this.currentToken.kind === TokenKind_1.TokenKind.DoubleArrow || colon !== null) {
            doubleArrow = this.eat(TokenKind_1.TokenKind.DoubleArrow);
        }
        else {
            doubleArrow = this.createMissingTokenWithError(TokenKind_1.TokenKind.DoubleArrow, ErrorCode_Generated_1.ErrorCode.ERR_ColonOrDoubleArrowExpected);
        }
        var expr = this.parseExpression();
        return new Node_Generated_1.ArrowFunctionNode(staticKeyword, fnKeyword, ampersand, openParen, parameters, closeParen, colon, returnType, doubleArrow, expr);
    };
    /**
     * Parses a reference to a class name.
     *
     * Syntax:
     * - `class-name`
     * - `class-reference`
     *
     * Where `class-name` is:
     * - `qualified-name`
     * - `STATIC`
     *
     * Where `class-reference` is:
     * - `simple-variable`
     * - `class-name :: simple-variable`
     * - `class-reference [ expr ]`
     * - `class-reference { expr }`
     * - `class-reference -> property-name`
     * - `class-reference :: simple-variable`
     */
    PhpParser.prototype.parseClassNameReference = function () {
        var reference;
        if (this.isNameStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Static) {
            // NOTE: TypeScript fails to perform actual type checking of this variable.
            var name_2;
            if (this.currentToken.kind === TokenKind_1.TokenKind.Static) {
                var staticKeyword = this.eat(TokenKind_1.TokenKind.Static);
                name_2 = new Node_Generated_1.PartiallyQualifiedNameNode(this.factory.createList([staticKeyword]));
            }
            else {
                name_2 = this.parseQualifiedName();
            }
            if (this.currentToken.kind !== TokenKind_1.TokenKind.DoubleColon) {
                return name_2;
            }
            // A static property that references a class name.
            var doubleColon = this.eat(TokenKind_1.TokenKind.DoubleColon);
            var variable = this.parseSimpleVariable();
            reference = new Node_Generated_1.StaticPropertyNode(name_2, doubleColon, variable);
        }
        else {
            reference = this.parseSimpleVariable();
        }
        // An "access" expression that references a class name.
        while (this.isClassNameReferenceExpressionStart(this.currentToken.kind)) {
            switch (this.currentToken.kind) {
                case TokenKind_1.TokenKind.DoubleColon:
                    var doubleColon = this.eat(TokenKind_1.TokenKind.DoubleColon);
                    var variable = this.parseSimpleVariable();
                    reference = new Node_Generated_1.StaticPropertyNode(reference, doubleColon, variable);
                    break;
                case TokenKind_1.TokenKind.ObjectOperator:
                    reference = this.parseMemberAccessOrInvocation(reference, false);
                    break;
                case TokenKind_1.TokenKind.OpenBrace:
                case TokenKind_1.TokenKind.OpenBracket:
                    // NOTE: While PHP currently parses an optional expression when
                    // using brackets, it always results in a "cannot use [] for reading"
                    // error, and is therefore required here.
                    var openKind = this.currentToken.kind;
                    var openBraceOrBracket = this.eat(openKind);
                    var index = this.parseExpression();
                    var closeBraceOrBracket = openKind === TokenKind_1.TokenKind.OpenBrace
                        ? this.eat(TokenKind_1.TokenKind.CloseBrace)
                        : this.eat(TokenKind_1.TokenKind.CloseBracket);
                    reference = new Node_Generated_1.ElementAccessNode(reference, openBraceOrBracket, index, closeBraceOrBracket);
                    break;
                default:
                    throw new Parser_1.ParserException('Unexpected token in class name reference expression');
            }
        }
        return reference;
    };
    /**
     * Parses a clone expression.
     *
     * Syntax: `CLONE expr`
     */
    PhpParser.prototype.parseClone = function () {
        var cloneKeyword = this.eat(TokenKind_1.TokenKind.Clone);
        var expr = this.parseExpression();
        return new Node_Generated_1.CloneNode(cloneKeyword, expr);
    };
    /**
     * Parses an anonymous function (closure).
     *
     * Syntax:
     * - `FUNCTION & ( parameter-list ) closure-use return-type statement-block`
     * - `STATIC FUNCTION & ( parameter-list ) closure-use return-type statement-block`
     */
    PhpParser.prototype.parseClosure = function (staticKeyword, functionKeyword, ampersand) {
        var openParen;
        var parameters;
        var closeParen;
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
            var parameterList = this.parseParameterList();
            openParen = parameterList.openParen;
            parameters = parameterList.parameterList;
            closeParen = parameterList.closeParen;
        }
        else {
            // If there is no open parenthesis, then the parser cannot determine if
            // the existing tokens are for a function declaration or a closure.
            var code_4 = ampersand !== null ? ErrorCode_Generated_1.ErrorCode.ERR_IdentifierOrOpenParenExpected : ErrorCode_Generated_1.ErrorCode.ERR_IncompleteFunctionDeclaration;
            openParen = this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenParen, code_4);
            parameters = null;
            closeParen = this.createMissingToken(TokenKind_1.TokenKind.CloseParen, this.currentToken.kind, false);
        }
        var useClause = null;
        if (this.currentToken.kind === TokenKind_1.TokenKind.Use) {
            useClause = this.parseClosureUseClause();
        }
        var colon = this.eatOptional(TokenKind_1.TokenKind.Colon);
        var returnType = colon !== null ? this.parseType() : null;
        var code = useClause === null && colon === null
            ? ErrorCode_Generated_1.ErrorCode.ERR_IncompleteClosure
            : ErrorCode_Generated_1.ErrorCode.ERR_OpenBraceOrColonExpected;
        var openBrace = this.currentToken.kind !== TokenKind_1.TokenKind.OpenBrace && colon === null
            ? this.createMissingTokenWithError(TokenKind_1.TokenKind.OpenBrace, code)
            : this.eat(TokenKind_1.TokenKind.OpenBrace);
        var statements = this.parseList(2 /* CompoundStatementElements */);
        var closeBrace = openBrace.isMissing
            ? this.createMissingToken(TokenKind_1.TokenKind.CloseBrace, this.currentToken.kind, false)
            : this.eat(TokenKind_1.TokenKind.CloseBrace);
        return new Node_Generated_1.AnonymousFunctionNode(staticKeyword, functionKeyword, ampersand, openParen, parameters, closeParen, useClause, colon, returnType, new Node_Generated_1.StatementBlockNode(openBrace, statements, closeBrace));
    };
    /**
     * Parses a closure use clause.
     *
     * Syntax: `USE ( lexical-variables )`
     *
     * Where `lexical-variables` is:
     * - `lexical-variables , lexical-variable`
     * - `lexical-variable`
     */
    PhpParser.prototype.parseClosureUseClause = function () {
        var useKeyword = this.eat(TokenKind_1.TokenKind.Use);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var vars = [];
        vars.push(this.parseLexicalVariable());
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            vars.push(this.eat(TokenKind_1.TokenKind.Comma));
            vars.push(this.parseLexicalVariable());
        }
        var closeParen = this.currentToken.kind === TokenKind_1.TokenKind.CloseParen
            ? this.eat(TokenKind_1.TokenKind.CloseParen)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, ErrorCode_Generated_1.ErrorCode.ERR_CommaOrCloseParenExpected);
        return new Node_Generated_1.ClosureUseNode(useKeyword, openParen, this.factory.createList(vars), closeParen);
    };
    /**
     * Parses a conditional (ternary) expression.
     *
     * Syntax:
     * - `expr ? expr : expr`
     * - `expr ? : expr`
     */
    PhpParser.prototype.parseConditionalExpression = function (condition, question) {
        // The "true expression" does not require a precedence parameter since
        // there is only one way to correctly parse the expression:
        //
        //   $a ? $b ? 1 : 2 : $c;
        //
        //   $a ? ($b ? 1 : 2) : $c;
        //
        var trueExpr = null;
        if (this.isExpressionStart(this.currentToken.kind)) {
            trueExpr = this.parseExpression();
        }
        var colon = this.currentToken.kind !== TokenKind_1.TokenKind.Colon && trueExpr === null
            ? this.createMissingTokenWithError(TokenKind_1.TokenKind.Colon, ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrColonExpected)
            : this.eat(TokenKind_1.TokenKind.Colon);
        var falseExpr = this.parseExpression(ExpressionType_1.ExpressionType.Any, Precedence_1.Precedence.Ternary);
        return new Node_Generated_1.ConditionalNode(condition, question, trueExpr, colon, falseExpr);
    };
    /**
     * Parses an element access (subscript) expression.
     *
     * Syntax:
     * - `dereferenceable [ expr ]`
     * - `dereferenceable { expr }`
     */
    PhpParser.prototype.parseElementAccess = function (dereferenceable) {
        // @todo Add (warning) diagnostic for deprecated syntax.
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace) {
            var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
            var index_1 = this.parseExpression();
            var closeBrace = this.eat(TokenKind_1.TokenKind.CloseBrace);
            return new Node_Generated_1.ElementAccessNode(dereferenceable, openBrace, index_1, closeBrace);
        }
        var openBracket = this.eat(TokenKind_1.TokenKind.OpenBracket);
        var index = null;
        if (this.isExpressionStart(this.currentToken.kind)) {
            index = this.parseExpression();
        }
        var closeBracket = this.eat(TokenKind_1.TokenKind.CloseBracket);
        return new Node_Generated_1.ElementAccessNode(dereferenceable, openBracket, index, closeBracket);
    };
    /**
     * Parses an empty intrinsic expression.
     *
     * Syntax: `EMPTY ( expr )`
     */
    PhpParser.prototype.parseEmpty = function () {
        var emptyKeyword = this.eat(TokenKind_1.TokenKind.Empty);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var expr = this.parseExpression();
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        return new Node_Generated_1.EmptyIntrinsicNode(emptyKeyword, openParen, expr, closeParen);
    };
    /**
     * Parses an error control expression.
     *
     * Syntax: `@ expr`
     */
    PhpParser.prototype.parseErrorControl = function () {
        var at = this.eat(TokenKind_1.TokenKind.At);
        var expr = this.parseExpression();
        return new Node_Generated_1.ErrorControlNode(at, expr);
    };
    /**
     * Parses an eval expression.
     *
     * Syntax: `EVAL ( expr )`
     */
    PhpParser.prototype.parseEval = function () {
        var evalKeyword = this.eat(TokenKind_1.TokenKind.Eval);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var expr = this.parseExpression();
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        return new Node_Generated_1.EvalIntrinsicNode(evalKeyword, openParen, expr, closeParen);
    };
    /**
     * Parses an exit intrinsic expression.
     *
     * Syntax:
     * - `EXIT`
     * - `EXIT ( )`
     * - `EXIT ( expr )`
     */
    PhpParser.prototype.parseExit = function () {
        // Only exit expressions should reach this point.
        php_common_1.Debug.assert(this.currentToken.kind === TokenKind_1.TokenKind.Die || this.currentToken.kind === TokenKind_1.TokenKind.Exit);
        var exitKeyword = this.eat(this.currentToken.kind);
        if (this.currentToken.kind !== TokenKind_1.TokenKind.OpenParen) {
            return new Node_Generated_1.ExitIntrinsicNode(exitKeyword, null, null, null);
        }
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var expr = this.isExpressionStart(this.currentToken.kind) ? this.parseExpression() : null;
        var closeParen;
        // Suppress TS2365: Current token changed after previous method call.
        if (this.currentToken.kind === TokenKind_1.TokenKind.CloseParen) {
            closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        }
        else {
            var code = expr !== null ? ErrorCode_Generated_1.ErrorCode.ERR_CloseParenExpected : ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrCloseParenExpected;
            closeParen = this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, code);
        }
        return new Node_Generated_1.ExitIntrinsicNode(exitKeyword, openParen, expr, closeParen);
    };
    /**
     * Parses an expression wrapped in parenthesis.
     *
     * Syntax: `( expr )`
     */
    PhpParser.prototype.parseExpressionGroup = function () {
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var expression = this.parseExpression();
        var closeParen = this.eat(TokenKind_1.TokenKind.CloseParen);
        var expr = new Node_Generated_1.ExpressionGroupNode(openParen, expression, closeParen);
        var type = ExpressionType_1.ExpressionType.Implicit;
        if (this.isDereferenceStart(this.currentToken.kind)) {
            type = ExpressionType_1.ExpressionType.Explicit;
        }
        return new Expression(expr, type);
    };
    /**
     * Parses a flexible heredoc template.
     *
     * Syntax:
     * - `HEREDOC_START flexdoc-element-list HEREDOC_END`
     */
    PhpParser.prototype.parseFlexdocTemplate = function () {
        var fullSpan = new TextSpan_1.TextSpan(this.currentToken.offset, this.currentToken.length);
        var fullText = this.lexer.sourceText.slice(fullSpan);
        var templateSpans = this.lexer.templateSpans;
        var template = this.eat(TokenKind_1.TokenKind.FlexdocTemplate);
        // Create a temporary lexer and parser.
        var lexer = new PhpLexer_1.PhpLexer(fullText);
        lexer.rescanInterpolatedFlexdoc(templateSpans);
        var parser = new PhpParser(lexer);
        parser.nextToken();
        var heredocStart = parser.eat(TokenKind_1.TokenKind.HeredocStart);
        heredocStart = heredocStart.withDiagnostics(template.diagnostics);
        heredocStart = heredocStart.withLeadingTrivia(template.leadingTrivia);
        var elements = parser.parseFlexdocTemplateElements();
        // If the end label was missing the lexer already added an error.
        var heredocEnd = parser.currentToken.kind === TokenKind_1.TokenKind.HeredocEnd
            ? parser.eat(TokenKind_1.TokenKind.HeredocEnd)
            : parser.createMissingToken(TokenKind_1.TokenKind.HeredocEnd, parser.currentToken.kind, false);
        return new Node_Generated_1.FlexibleHeredocTemplateNode(heredocStart, elements, heredocEnd);
    };
    /**
     * Parses a list of optional lines in a flexible heredoc template.
     *
     * Syntax: `flexdoc-element-list`
     *
     * Where `flexdoc-element-list` is:
     * - `flexdoc-element-list STRING_NEWLINE flexdoc-element`
     * - `flexdoc-element`
     */
    PhpParser.prototype.parseFlexdocTemplateElements = function () {
        var elements = [];
        if (this.isFlexdocTemplateLineStart(this.currentToken.kind)) {
            elements.push(this.parseFlexdocTemplateLine());
        }
        while (this.currentToken.kind !== TokenKind_1.TokenKind.EOF && this.currentToken.kind !== TokenKind_1.TokenKind.HeredocEnd) {
            if (this.currentToken.kind === TokenKind_1.TokenKind.StringLineBreak) {
                elements.push(new Node_Generated_1.LiteralNode(this.eat(TokenKind_1.TokenKind.StringLineBreak)));
                if (this.isFlexdocTemplateLineStart(this.currentToken.kind)) {
                    elements.push(this.parseFlexdocTemplateLine());
                }
                continue;
            }
            this.skipToken();
        }
        if (elements.length === 0) {
            // Unreachable. There should always be an indent before the end label.
            throw new Parser_1.ParserException('Flexible heredoc template cannot be empty');
        }
        return this.factory.createList(elements);
    };
    /**
     * Parses a line in a flexible heredoc template.
     *
     * Syntax:
     * - `STRING_INDENT`
     * - `STRING_INDENT STRING_TEMPLATE_LITERAL`
     * - `STRING_INDENT string-template-list`
     */
    PhpParser.prototype.parseFlexdocTemplateLine = function () {
        var indent = this.currentToken.kind === TokenKind_1.TokenKind.StringIndent
            ? this.eat(TokenKind_1.TokenKind.StringIndent)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.StringIndent, ErrorCode_Generated_1.ErrorCode.ERR_IndentExpected);
        if (this.currentToken.kind !== TokenKind_1.TokenKind.StringTemplateLiteral && !this.isStringTemplateElementStart(this.currentToken.kind)) {
            return new Node_Generated_1.FlexibleHeredocElementNode(indent, null);
        }
        var nodes = [];
        if (this.currentToken.kind === TokenKind_1.TokenKind.StringTemplateLiteral) {
            nodes.push(this.parseStringTemplateLiteral());
            if (!this.isStringTemplateElementStart(this.currentToken.kind)) {
                return new Node_Generated_1.FlexibleHeredocElementNode(indent, this.factory.createList(nodes));
            }
        }
        else {
            nodes.push(this.parseStringTemplateElement());
        }
        while (this.currentToken.kind !== TokenKind_1.TokenKind.EOF && this.currentToken.kind !== TokenKind_1.TokenKind.StringLineBreak) {
            if (this.currentToken.kind === TokenKind_1.TokenKind.StringTemplateLiteral) {
                nodes.push(this.parseStringTemplateLiteral());
                continue;
            }
            if (this.isStringTemplateElementStart(this.currentToken.kind)) {
                nodes.push(this.parseStringTemplateElement());
                continue;
            }
            // The parser can't be at the end of the heredoc until it has found the
            // indent before the end label, and an indent can't be found until a
            // the parser gets to an embedded line break (which would have been caught
            // by the while-condition), so the current token has to be something else.
            this.skipToken(); // @todo Use custom method?
        }
        return new Node_Generated_1.FlexibleHeredocElementNode(indent, this.factory.createList(nodes));
    };
    /**
     * @todo Document parseFunctionDeclarationOrClosure().
     */
    PhpParser.prototype.parseFunctionDeclarationOrClosure = function (isStatementExpected) {
        var functionKeyword = this.eat(TokenKind_1.TokenKind.Function);
        var ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
        if (isStatementExpected && this.isFunctionIdentifier(this.currentToken.kind)) {
            var funcDecl = this.parseFunctionDeclaration(functionKeyword, ampersand);
            return new Expression(funcDecl, ExpressionType_1.ExpressionType.Any);
        }
        var closure = this.parseClosure(null, functionKeyword, ampersand);
        return new Expression(closure, ExpressionType_1.ExpressionType.Implicit);
    };
    /**
     * Parses a function invocation expression.
     *
     * Syntax:
     * - `name ( argument-list )`
     * - `expression ( argument-list )`
     *
     * @see PhpParser.parseMemberAccessOrInvocation()
     * @see PhpParser.parseScopedAccessOrInvocation()
     */
    PhpParser.prototype.parseFunctionInvocation = function (reference) {
        var invocationArgs = this.parseArgumentList();
        return new Node_Generated_1.FunctionInvocationNode(reference, invocationArgs.openParen, invocationArgs.argumentList, invocationArgs.closeParen);
    };
    /**
     * Parses a heredoc (or nowdoc) template.
     *
     * Syntax:
     * - `HEREDOC_START HEREDOC_END`
     * - `HEREDOC_START STRING_TEMPLATE_LITERAL HEREDOC_END`
     * - `HEREDOC_START string-template-list HEREDOC_END`
     *
     * @see PhpParser.parseFlexdocTemplate()
     * @see PhpParser.parseShellCommandTemplate()
     * @see PhpParser.parseStringTemplate()
     */
    PhpParser.prototype.parseHeredocTemplate = function () {
        var fullSpan = new TextSpan_1.TextSpan(this.currentToken.offset, this.currentToken.length);
        var fullText = this.lexer.sourceText.slice(fullSpan);
        var templateSpans = this.lexer.templateSpans;
        var template = this.eat(TokenKind_1.TokenKind.HeredocTemplate);
        // Create a temporary lexer and parser.
        var lexer = new PhpLexer_1.PhpLexer(fullText);
        lexer.rescanInterpolatedHeredoc(templateSpans);
        var parser = new PhpParser(lexer);
        parser.nextToken();
        var heredocStart = parser.eat(TokenKind_1.TokenKind.HeredocStart);
        heredocStart = heredocStart.withDiagnostics(template.diagnostics);
        heredocStart = heredocStart.withLeadingTrivia(template.leadingTrivia);
        var nodes = null;
        if (parser.currentToken.kind === TokenKind_1.TokenKind.StringTemplateLiteral) {
            var stringLiteral = parser.parseStringTemplateLiteral();
            nodes = parser.isStringTemplateEnd(parser.currentToken.kind, TokenKind_1.TokenKind.HeredocEnd)
                ? parser.factory.createList([stringLiteral])
                : parser.parseStringTemplateElementList(stringLiteral, TokenKind_1.TokenKind.HeredocEnd);
        }
        else if (parser.isStringTemplateElementStart(parser.currentToken.kind)) {
            nodes = parser.parseStringTemplateElementList(null, TokenKind_1.TokenKind.HeredocEnd);
        }
        var heredocEnd;
        if (parser.currentToken.kind === TokenKind_1.TokenKind.HeredocEnd) {
            heredocEnd = parser.eat(TokenKind_1.TokenKind.HeredocEnd);
        }
        else {
            // The parser should always reach the end of a template.
            php_common_1.Debug.assert(parser.currentToken.kind === TokenKind_1.TokenKind.EOF);
            // If the end label was missing, the lexer already added an error.
            heredocEnd = parser.createMissingToken(TokenKind_1.TokenKind.HeredocEnd, parser.currentToken.kind, false);
            // Move any trailing trivia over to this parser.
            if (parser.leadingTrivia.length > 0) {
                this.leadingTrivia = this.leadingTrivia.concat(parser.leadingTrivia);
                this.leadingTriviaWidth += parser.leadingTriviaWidth;
            }
        }
        return new Node_Generated_1.HeredocTemplateNode(heredocStart, nodes, heredocEnd);
    };
    /**
     * Parses an instanceof expression
     *
     * Syntax: `expr INSTANCEOF class-name-reference`
     */
    PhpParser.prototype.parseInstanceOf = function (leftOperand, operator) {
        if (!this.isClassNameReferenceStart(this.currentToken.kind)) {
            var identifier = this.createMissingTokenWithError(TokenKind_1.TokenKind.Identifier, ErrorCode_Generated_1.ErrorCode.ERR_ClassNameOrReferenceExpected);
            var name_3 = new Node_Generated_1.PartiallyQualifiedNameNode(this.factory.createList([identifier]));
            return new Node_Generated_1.InstanceOfNode(leftOperand, operator, name_3);
        }
        var reference = this.parseClassNameReference();
        return new Node_Generated_1.InstanceOfNode(leftOperand, operator, reference);
    };
    /**
     * Parses an isset intrinsic expression.
     *
     * Syntax: `ISSET ( isset-list )`
     *
     * Where `isset-list` is:
     * - `isset-list , expr`
     * - `expr`
     */
    PhpParser.prototype.parseIsSet = function () {
        var isSetKeyword = this.eat(TokenKind_1.TokenKind.IsSet);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var expressions = [];
        expressions.push(this.parseExpression());
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            var comma = this.eat(TokenKind_1.TokenKind.Comma);
            if (!this.isExpressionStart(this.currentToken.kind)) {
                if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_3)) {
                    comma = this.addError(comma, ErrorCode_Generated_1.ErrorCode.ERR_FeatureTrailingCommasInArgumentLists);
                }
                expressions.push(comma);
                break;
            }
            else {
                expressions.push(comma);
                expressions.push(this.parseExpression());
            }
        }
        var closeParen = this.currentToken.kind === TokenKind_1.TokenKind.CloseParen
            ? this.eat(TokenKind_1.TokenKind.CloseParen)
            : expressions.length & 1
                ? this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, ErrorCode_Generated_1.ErrorCode.ERR_CommaOrCloseParenExpected)
                : this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrCloseParenExpected);
        return new Node_Generated_1.IsSetIntrinsicNode(isSetKeyword, openParen, this.factory.createList(expressions), closeParen);
    };
    /**
     * @todo Document parseLabelOrExpression().
     */
    PhpParser.prototype.parseLabelOrExpression = function (isStatementExpected) {
        // Fully qualified and relative names should not reach this method.
        php_common_1.Debug.assert(this.currentToken.kind === TokenKind_1.TokenKind.Identifier);
        var names = this.parseNamespaceName();
        if (isStatementExpected && names.length === 1 && this.currentToken.kind === TokenKind_1.TokenKind.Colon) {
            var colon = this.eat(TokenKind_1.TokenKind.Colon);
            var label = new Node_Generated_1.LabelNode(names[0], colon);
            return new Expression(label, ExpressionType_1.ExpressionType.Any);
        }
        var name = new Node_Generated_1.PartiallyQualifiedNameNode(this.factory.createList(names));
        return this.parseNamedExpression(name);
    };
    /**
     * Parses a lexical variable.
     *
     * Syntax:
     * - `VARIABLE`
     * - `& VARIABLE`
     */
    PhpParser.prototype.parseLexicalVariable = function () {
        var ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
        var variable = this.currentToken.kind === TokenKind_1.TokenKind.Variable
            ? this.eat(TokenKind_1.TokenKind.Variable)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Variable, ErrorCode_Generated_1.ErrorCode.ERR_VariableExpected);
        return new Node_Generated_1.LexicalVariableNode(ampersand, variable);
    };
    /**
     * Parses a deconstruction (list intrinsic).
     *
     * Syntax: `LIST ( list-variables )`
     *
     * Where `list-variables` is:
     * - `list-variables , list-element`
     * - `list-element`
     */
    PhpParser.prototype.parseListDestructure = function () {
        var listKeyword = this.eat(TokenKind_1.TokenKind.List);
        var openParen = this.eat(TokenKind_1.TokenKind.OpenParen);
        var isEmpty = true;
        var variables = [];
        if (this.isListIntrinsicElementStart(this.currentToken.kind)) {
            variables.push(this.parseListDestructureElement());
            isEmpty = false;
        }
        while (this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
            variables.push(this.eat(TokenKind_1.TokenKind.Comma));
            if (this.isListIntrinsicElementStart(this.currentToken.kind)) {
                variables.push(this.parseListDestructureElement());
                isEmpty = false;
            }
        }
        if (variables.length === 0 || isEmpty) {
            var variable = this.createMissingTokenWithError(TokenKind_1.TokenKind.Variable, ErrorCode_Generated_1.ErrorCode.ERR_DeconstructVariableMissing);
            var value = new Node_Generated_1.LocalVariableNode(variable);
            var element = new Node_Generated_1.ListDestructureElementNode(null, null, null, value);
            variables.push(element);
        }
        var code = variables[variables.length - 1] instanceof TokenNode_1.TokenNode
            ? ErrorCode_Generated_1.ErrorCode.ERR_ExpressionOrCloseParenExpected
            : ErrorCode_Generated_1.ErrorCode.ERR_CommaOrCloseParenExpected;
        var closeParen = this.currentToken.kind === TokenKind_1.TokenKind.CloseParen
            ? this.eat(TokenKind_1.TokenKind.CloseParen)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.CloseParen, code);
        // Technically, if the variable list is empty, then a missing element
        // should be appended instead.
        return new Node_Generated_1.ListDestructureNode(listKeyword, openParen, variables.length > 0 ? this.factory.createList(variables) : null, closeParen);
    };
    /**
     * Parses an element of a deconstruction (list intrinsic).
     *
     * Syntax:
     * - `expr`
     * - `expr => expr`
     * - `list-destructure`
     * - `expr => list-destructure`
     */
    PhpParser.prototype.parseListDestructureElement = function () {
        if (this.currentToken.kind === TokenKind_1.TokenKind.List) {
            var list = this.parseListDestructure();
            return new Node_Generated_1.ListDestructureElementNode(null, null, null, list);
        }
        var ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
        if (ampersand !== null) {
            if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_3)) {
                ampersand = this.addError(ampersand, ErrorCode_Generated_1.ErrorCode.ERR_FeatureListDeconstructionByRef);
            }
            var byRefValue = this.parseExpression(ExpressionType_1.ExpressionType.Explicit);
            return new Node_Generated_1.ListDestructureElementNode(null, null, ampersand, byRefValue);
        }
        // The expected expression type can only be determined after parsing it, so
        // the expression needs to be parsed manually and possibly have an error
        // added later.
        var expr = this.parseExpressionTree();
        php_common_1.Debug.assert(expr.node instanceof Node_Generated_1.ExpressionNode);
        if (this.currentToken.kind !== TokenKind_1.TokenKind.DoubleArrow) {
            // This is a value expression, which must be "explicit".
            var variable = expr.node;
            if (!variable.containsDiagnostics && expr.type === ExpressionType_1.ExpressionType.Implicit) {
                variable = this.addError(variable, ErrorCode_Generated_1.ErrorCode.ERR_ExpressionNotAddressable);
            }
            return new Node_Generated_1.ListDestructureElementNode(null, null, null, variable);
        }
        var key = expr.node;
        var doubleArrow = this.eat(TokenKind_1.TokenKind.DoubleArrow);
        if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_1)) {
            // The parser considers '=> $v' to be invalid, but it would also be
            // acceptable to place this error on the key, since the logical solution
            // is to remove '$k =>' instead.
            doubleArrow = this.addError(doubleArrow, ErrorCode_Generated_1.ErrorCode.ERR_FeatureListDeconstructionKeys);
        }
        ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
        if (ampersand !== null) {
            if (!this.isSupportedVersion(PhpVersion_1.PhpVersion.PHP7_3)) {
                ampersand = this.addError(ampersand, ErrorCode_Generated_1.ErrorCode.ERR_FeatureListDeconstructionByRef);
            }
            var byRefValue = this.parseExpression(ExpressionType_1.ExpressionType.Explicit);
            return new Node_Generated_1.ListDestructureElementNode(key, doubleArrow, ampersand, byRefValue);
        }
        // Suppress TS2365: Current token changed after previous method call.
        var value = this.currentToken.kind === TokenKind_1.TokenKind.List
            ? this.parseListDestructure()
            : this.parseExpression(ExpressionType_1.ExpressionType.Explicit);
        return new Node_Generated_1.ListDestructureElementNode(key, doubleArrow, ampersand, value);
    };
    /**
     * Parses a member access expression.
     *
     * Syntax:
     * - `dereferenceable -> property-name`
     * - `dereferenceable -> property-name ( argument-list )`
     *
     * Where `property-name` is:
     * - `member-name`
     * - `simple-variable`
     * - `{ expr }`
     *
     * @param {ExpressionNode} dereferenceable
     *   An addressable expression.
     * @param {boolean} allowInvocation
     *   If `true`, parse an invocation expression when possible.
     */
    PhpParser.prototype.parseMemberAccessOrInvocation = function (dereferenceable, allowInvocation) {
        var objOperator = this.eat(TokenKind_1.TokenKind.ObjectOperator);
        var memberName = null;
        var openBrace = null;
        var memberReference = null;
        var closeBrace = null;
        // NOTE: PHP's lexer converts any text after an object operator into an
        // identifier. The lexer used by this parser does not do that, and as
        // such requires a slight modification to allow keywords.
        if (this.isClassMemberIdentifier(this.currentToken.kind)) {
            memberName = this.eat(this.currentToken.kind);
        }
        else if (this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace) {
            openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
            memberReference = this.parseExpression();
            closeBrace = this.eat(TokenKind_1.TokenKind.CloseBrace);
        }
        else if (this.currentToken.kind === TokenKind_1.TokenKind.Dollar || this.currentToken.kind === TokenKind_1.TokenKind.Variable) {
            memberReference = this.parseSimpleVariable();
        }
        else {
            // @todo ERR_ObjectMemberExpected "Identifier, variable, or '{' expected"  ...in member access expression
            //   See also: ERR_StaticMemberExpected
            memberName = this.createMissingToken(TokenKind_1.TokenKind.Identifier, this.currentToken.kind, true);
        }
        if (allowInvocation && this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
            var invocationArgs = this.parseArgumentList();
            if (memberReference !== null) {
                return new Node_Generated_1.IndirectMethodInvocationNode(dereferenceable, objOperator, openBrace, memberReference, closeBrace, invocationArgs.openParen, invocationArgs.argumentList, invocationArgs.closeParen);
            }
            if (memberName !== null) {
                return new Node_Generated_1.NamedMethodInvocationNode(dereferenceable, objOperator, memberName, invocationArgs.openParen, invocationArgs.argumentList, invocationArgs.closeParen);
            }
            throw new Parser_1.ParserException('Invalid object member'); // Unreachable.
        }
        if (memberReference !== null) {
            return new Node_Generated_1.IndirectMemberAccessNode(dereferenceable, objOperator, openBrace, memberReference, closeBrace);
        }
        if (memberName !== null) {
            return new Node_Generated_1.NamedMemberAccessNode(dereferenceable, objOperator, memberName);
        }
        throw new Parser_1.ParserException('Invalid object member'); // Unreachable.
    };
    /**
     * @todo Document parseNamedExpression().
     */
    PhpParser.prototype.parseNamedExpression = function (name) {
        if (this.currentToken.kind === TokenKind_1.TokenKind.DoubleColon) {
            var doubleColon = this.eat(TokenKind_1.TokenKind.DoubleColon);
            return this.parseScopedAccessOrInvocation(name, doubleColon);
        }
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
            var invocation = this.parseFunctionInvocation(name);
            return new Expression(invocation, ExpressionType_1.ExpressionType.Explicit);
        }
        var type = this.currentToken.kind === TokenKind_1.TokenKind.OpenBracket
            ? ExpressionType_1.ExpressionType.Explicit
            : ExpressionType_1.ExpressionType.Implicit;
        var constant = new Node_Generated_1.ConstantNode(name);
        return new Expression(constant, type);
    };
    /**
     * @todo Document parseNamespaceDeclarationOrExpression().
     */
    PhpParser.prototype.parseNamespaceDeclarationOrExpression = function (isStatementExpected) {
        // Namespace declarations should only be expected as a top-level statement.
        php_common_1.Debug.assert(isStatementExpected && (this.isInContext(0 /* SourceElements */) || this.isInContext(4 /* NamespaceElements */)));
        var namespaceKeyword = this.eat(TokenKind_1.TokenKind.Namespace);
        // Even if the parser is in a top-statement context, a declaration should
        // not be parsed unless it is also expected:
        //
        //   if (namespace| A
        //                ^-- cursor here
        //
        if (isStatementExpected && (this.currentToken.kind === TokenKind_1.TokenKind.Identifier || this.currentToken.kind === TokenKind_1.TokenKind.OpenBrace)) {
            var namespace = this.parseNamespaceDeclaration(namespaceKeyword);
            if (this.isInContext(4 /* NamespaceElements */)) {
                // Since a diagnostic on the node would overlap with diagnostics on
                // child statements, this error is customized to only cover the
                // namespace keyword and name (if present).
                var width = namespaceKeyword.width + (namespace.name !== null ? namespace.name.fullWidth : 0);
                var diagnostic = this.createDiagnostic(namespaceKeyword.leadingTriviaWidth, width, ErrorCode_Generated_1.ErrorCode.ERR_NamespaceIsNested);
                namespace = namespace.withDiagnostics(namespace.diagnostics.concat([diagnostic]));
            }
            return new Expression(namespace, ExpressionType_1.ExpressionType.Any);
        }
        var relativeName;
        if (this.currentToken.kind === TokenKind_1.TokenKind.Backslash || !isStatementExpected) {
            var leadingBackslash = this.eat(TokenKind_1.TokenKind.Backslash);
            var names = this.parseNamespaceName();
            relativeName = new Node_Generated_1.RelativeNameNode(namespaceKeyword, leadingBackslash, this.factory.createList(names));
        }
        else {
            // At this point the next token is not a backslash (relative name),
            // identifier, or opening brace (namespace declaration). To recover, a
            // nameless constant is used instead of a namespace declaration since
            // that would probably make name resolution harder.
            var leadingBackslash = this.createMissingTokenWithError(TokenKind_1.TokenKind.Backslash, ErrorCode_Generated_1.ErrorCode.ERR_IncompleteNamespace);
            var identifier = this.createMissingToken(TokenKind_1.TokenKind.Identifier, this.currentToken.kind, false);
            relativeName = new Node_Generated_1.RelativeNameNode(namespaceKeyword, leadingBackslash, this.factory.createList([identifier]));
        }
        var constant;
        switch (this.currentToken.kind) {
            case TokenKind_1.TokenKind.DoubleColon:
                var doubleColon = this.eat(TokenKind_1.TokenKind.DoubleColon);
                return this.parseScopedAccessOrInvocation(relativeName, doubleColon);
            case TokenKind_1.TokenKind.OpenBracket:
                // The element access part of this will get parsed later.
                constant = new Node_Generated_1.ConstantNode(relativeName);
                return new Expression(constant, ExpressionType_1.ExpressionType.Explicit);
            case TokenKind_1.TokenKind.OpenParen:
                var invocation = this.parseFunctionInvocation(relativeName);
                return new Expression(invocation, ExpressionType_1.ExpressionType.Explicit);
            default:
                constant = new Node_Generated_1.ConstantNode(relativeName);
                return new Expression(constant, ExpressionType_1.ExpressionType.Implicit);
        }
    };
    /**
     * Parses an object creation (new) expression.
     *
     * Syntax:
     * - `NEW anonymous-class-declaration`
     * - `NEW class-name-reference`
     * - `NEW class-name-reference ( argument-list )`
     */
    PhpParser.prototype.parseObjectCreationExpression = function () {
        var newKeyword = this.eat(TokenKind_1.TokenKind.New);
        if (this.currentToken.kind === TokenKind_1.TokenKind.Class) {
            var declaration = this.parseAnonymousClass();
            return new Node_Generated_1.AnonymousObjectCreationNode(newKeyword, declaration);
        }
        else if (!this.isClassNameReferenceStart(this.currentToken.kind)) {
            var identifier = this.createMissingTokenWithError(TokenKind_1.TokenKind.Identifier, ErrorCode_Generated_1.ErrorCode.ERR_ClassNameOrReferenceExpected);
            var name_4 = new Node_Generated_1.PartiallyQualifiedNameNode(this.factory.createList([identifier]));
            return new Node_Generated_1.NamedObjectCreationNode(newKeyword, name_4, null, null, null);
        }
        var reference = this.parseClassNameReference();
        var openParen = null;
        var argumentList = null;
        var closeParen = null;
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
            var invocationArgs = this.parseArgumentList();
            openParen = invocationArgs.openParen;
            argumentList = invocationArgs.argumentList;
            closeParen = invocationArgs.closeParen;
        }
        return reference instanceof Node_Generated_1.NameNode
            ? new Node_Generated_1.NamedObjectCreationNode(newKeyword, reference, openParen, argumentList, closeParen)
            : new Node_Generated_1.IndirectObjectCreationNode(newKeyword, reference, openParen, argumentList, closeParen);
    };
    /**
     * Parses a print intrinsic expression.
     *
     * Syntax: `PRINT expr`
     */
    PhpParser.prototype.parsePrint = function () {
        var printKeyword = this.eat(TokenKind_1.TokenKind.Print);
        var expr = this.parseExpression();
        return new Node_Generated_1.PrintIntrinsicNode(printKeyword, expr);
    };
    /**
     * @todo Document parseScopedAccessOrInvocation().
     */
    PhpParser.prototype.parseScopedAccessOrInvocation = function (qualifier, doubleColon) {
        var kind = this.currentToken.kind;
        if (this.isClassMemberIdentifier(kind)) {
            var member = this.eat(this.currentToken.kind);
            if (this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
                var invocationArgs = this.parseArgumentList();
                var invocation = new Node_Generated_1.NamedScopedInvocationNode(qualifier, doubleColon, member, invocationArgs.openParen, invocationArgs.argumentList, invocationArgs.closeParen);
                return new Expression(invocation, ExpressionType_1.ExpressionType.Explicit);
            }
            // If this is a class constant that is being dereferenced, then it is
            // being used as an explicit variable in part of an expression (the
            // actual element access will get parsed later).
            var type = this.currentToken.kind === TokenKind_1.TokenKind.OpenBracket
                ? ExpressionType_1.ExpressionType.Explicit : ExpressionType_1.ExpressionType.Implicit;
            var constant = new Node_Generated_1.ClassConstantNode(qualifier, doubleColon, member);
            return new Expression(constant, type);
        }
        else if (kind === TokenKind_1.TokenKind.Dollar || kind === TokenKind_1.TokenKind.Variable) {
            var variable = this.parseSimpleVariable();
            // Suppress TS2365: Current token changed after previous method call.
            if (this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
                var invocationArgs = this.parseArgumentList();
                var invocation = new Node_Generated_1.IndirectScopedInvocationNode(qualifier, doubleColon, null, variable, null, invocationArgs.openParen, invocationArgs.argumentList, invocationArgs.closeParen);
                return new Expression(invocation, ExpressionType_1.ExpressionType.Explicit);
            }
            var property = new Node_Generated_1.StaticPropertyNode(qualifier, doubleColon, variable);
            return new Expression(property, ExpressionType_1.ExpressionType.Explicit);
        }
        else if (kind === TokenKind_1.TokenKind.OpenBrace) {
            var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
            var member = this.parseExpression();
            var closeBrace = this.eat(TokenKind_1.TokenKind.CloseBrace);
            var invocationArgs = this.parseArgumentList();
            var invocation = new Node_Generated_1.IndirectScopedInvocationNode(qualifier, doubleColon, openBrace, member, closeBrace, invocationArgs.openParen, invocationArgs.argumentList, invocationArgs.closeParen);
            return new Expression(invocation, ExpressionType_1.ExpressionType.Explicit);
        }
        else {
            var identifier = this.createMissingTokenWithError(TokenKind_1.TokenKind.Identifier, ErrorCode_Generated_1.ErrorCode.ERR_StaticMemberExpected);
            var constant = new Node_Generated_1.ClassConstantNode(qualifier, doubleColon, identifier);
            return new Expression(constant, ExpressionType_1.ExpressionType.Implicit);
        }
    };
    /**
     * Parses an import or require expression.
     *
     * Syntax: `inclusion-keyword expr`
     *
     * Where `inclusion-keyword` is:
     * - `INCLUDE`
     * - `INCLUDE_ONCE`
     * - `REQUIRE`
     * - `REQUIRE_ONCE`
     */
    PhpParser.prototype.parseScriptInclusion = function () {
        var keyword = this.eat(this.currentToken.kind);
        var expr = this.parseExpression();
        return new Node_Generated_1.ScriptInclusionNode(keyword, expr);
    };
    /**
     * Parses a shell command (backquote) template.
     *
     * Syntax:
     * - `BACKQUOTE BACKQUOTE`
     * - `BACKQUOTE STRING_TEMPLATE_LITERAL BACKQUOTE`
     * - `BACKQUOTE string-template-list BACKQUOTE`
     */
    PhpParser.prototype.parseShellCommandTemplate = function () {
        var fullSpan = new TextSpan_1.TextSpan(this.currentToken.offset, this.currentToken.length);
        var fullText = this.lexer.sourceText.slice(fullSpan);
        var templateSpans = this.lexer.templateSpans;
        var template = this.eat(TokenKind_1.TokenKind.ShellCommandTemplate);
        // Create a temporary lexer and parser.
        var lexer = new PhpLexer_1.PhpLexer(fullText);
        lexer.rescanInterpolatedShellCommand(templateSpans);
        var parser = new PhpParser(lexer);
        parser.nextToken();
        var openBackQuote = parser.eat(TokenKind_1.TokenKind.BackQuote);
        openBackQuote = openBackQuote.withDiagnostics(template.diagnostics);
        openBackQuote = openBackQuote.withLeadingTrivia(template.leadingTrivia);
        var nodes = null;
        if (parser.currentToken.kind === TokenKind_1.TokenKind.StringTemplateLiteral) {
            var stringLiteral = parser.parseStringTemplateLiteral();
            nodes = parser.isStringTemplateEnd(parser.currentToken.kind, TokenKind_1.TokenKind.BackQuote)
                ? parser.factory.createList([stringLiteral])
                : parser.parseStringTemplateElementList(stringLiteral, TokenKind_1.TokenKind.BackQuote);
        }
        else if (parser.isStringTemplateElementStart(parser.currentToken.kind)) {
            nodes = parser.parseStringTemplateElementList(null, TokenKind_1.TokenKind.BackQuote);
        }
        var closeBackQuote;
        if (parser.currentToken.kind === TokenKind_1.TokenKind.BackQuote) {
            closeBackQuote = parser.eat(TokenKind_1.TokenKind.BackQuote);
        }
        else {
            // The parser should always reach the end of a template.
            php_common_1.Debug.assert(parser.currentToken.kind === TokenKind_1.TokenKind.EOF);
            // If the closing backquote was missing the lexer already added an error.
            closeBackQuote = parser.createMissingToken(TokenKind_1.TokenKind.BackQuote, parser.currentToken.kind, false);
            // Move any trailing trivia over to this parser.
            if (parser.leadingTrivia.length > 0) {
                this.leadingTrivia = this.leadingTrivia.concat(parser.leadingTrivia);
                this.leadingTriviaWidth += parser.leadingTriviaWidth;
            }
        }
        return new Node_Generated_1.ShellCommandTemplateNode(openBackQuote, nodes, closeBackQuote);
    };
    /**
     * Parses a simple variable.
     *
     * Syntax:
     * - `VARIABLE`
     * - `$ { expression }`
     * - `$ simple-variable`
     */
    PhpParser.prototype.parseSimpleVariable = function () {
        if (this.currentToken.kind === TokenKind_1.TokenKind.Dollar) {
            var dollar = this.eat(TokenKind_1.TokenKind.Dollar);
            // Suppress TS2365: Current token changed after previous method call.
            var kind = this.currentToken.kind;
            if (kind === TokenKind_1.TokenKind.Variable || kind === TokenKind_1.TokenKind.Dollar) {
                var variable_1 = this.parseSimpleVariable();
                return new Node_Generated_1.IndirectVariableNode(dollar, null, variable_1, null);
            }
            else if (kind === TokenKind_1.TokenKind.OpenBrace) {
                var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
                var expression = this.parseExpression();
                var closeBrace = this.eat(TokenKind_1.TokenKind.CloseBrace);
                return new Node_Generated_1.IndirectVariableNode(dollar, openBrace, expression, closeBrace);
            }
            else {
                // A '$' followed by nothing is usually an incomplete local variable.
                dollar = this.addError(dollar, ErrorCode_Generated_1.ErrorCode.ERR_IncompleteVariable);
                return new Node_Generated_1.LocalVariableNode(dollar);
            }
        }
        var variable = this.currentToken.kind === TokenKind_1.TokenKind.Variable
            ? this.eat(TokenKind_1.TokenKind.Variable)
            : this.createMissingTokenWithError(TokenKind_1.TokenKind.Variable, ErrorCode_Generated_1.ErrorCode.ERR_VariableExpected);
        return new Node_Generated_1.LocalVariableNode(variable);
    };
    /**
     * @todo Document parseStaticDeclartionOrExpression().
     */
    PhpParser.prototype.parseStaticDeclarationOrExpression = function (isStatementExpected) {
        var staticKeyword = this.eat(TokenKind_1.TokenKind.Static);
        if (isStatementExpected && (this.currentToken.kind === TokenKind_1.TokenKind.Dollar || this.currentToken.kind === TokenKind_1.TokenKind.Variable)) {
            var decl = this.parseStatic(staticKeyword);
            return new Expression(decl, ExpressionType_1.ExpressionType.Any);
        }
        if (this.currentToken.kind === TokenKind_1.TokenKind.Function) {
            var functionKeyword = this.eat(TokenKind_1.TokenKind.Function);
            var ampersand = this.eatOptional(TokenKind_1.TokenKind.Ampersand);
            var closure = this.parseClosure(staticKeyword, functionKeyword, ampersand);
            return new Expression(closure, ExpressionType_1.ExpressionType.Implicit);
        }
        if (this.currentToken.kind === TokenKind_1.TokenKind.Fn) {
            var arrowFunction = this.parseArrowFunction(staticKeyword);
            return new Expression(arrowFunction, ExpressionType_1.ExpressionType.Implicit);
        }
        // The qualifier of scoped access nodes cannot be a token.
        var name = new Node_Generated_1.PartiallyQualifiedNameNode(this.factory.createList([staticKeyword]));
        if (this.currentToken.kind === TokenKind_1.TokenKind.DoubleColon) {
            var doubleColon_1 = this.eat(TokenKind_1.TokenKind.DoubleColon);
            return this.parseScopedAccessOrInvocation(name, doubleColon_1);
        }
        var doubleColon = this.createMissingTokenWithError(TokenKind_1.TokenKind.DoubleColon, ErrorCode_Generated_1.ErrorCode.ERR_StaticExpressionExpected);
        var identifier = this.createMissingToken(TokenKind_1.TokenKind.Identifier, this.currentToken.kind, false);
        var constant = new Node_Generated_1.ClassConstantNode(name, doubleColon, identifier);
        return new Expression(constant, ExpressionType_1.ExpressionType.Implicit);
    };
    /**
     * Parses a single-quoted string.
     */
    PhpParser.prototype.parseStringLiteral = function () {
        var literal = new Node_Generated_1.LiteralNode(this.eat(TokenKind_1.TokenKind.StringLiteral));
        var type = ExpressionType_1.ExpressionType.Implicit;
        if (this.isElementAccessStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.DoubleColon || this.currentToken.kind === TokenKind_1.TokenKind.OpenParen) {
            type = ExpressionType_1.ExpressionType.Explicit;
        }
        return new Expression(literal, type);
    };
    /**
     * Parses a double-quoted template.
     *
     * Syntax: `" string-template-list "`
     */
    PhpParser.prototype.parseStringTemplate = function () {
        var fullSpan = new TextSpan_1.TextSpan(this.currentToken.offset, this.currentToken.length);
        var fullText = this.lexer.sourceText.slice(fullSpan);
        var templateSpans = this.lexer.templateSpans;
        var template = this.eat(TokenKind_1.TokenKind.StringTemplate);
        // Create a temporary lexer and parser.
        var lexer = new PhpLexer_1.PhpLexer(fullText);
        lexer.rescanInterpolatedString(templateSpans);
        var parser = new PhpParser(lexer);
        parser.nextToken();
        var openQuote = parser.eat(TokenKind_1.TokenKind.DoubleQuote);
        openQuote = openQuote.withDiagnostics(template.diagnostics);
        openQuote = openQuote.withLeadingTrivia(template.leadingTrivia);
        var nodes = null;
        if (parser.currentToken.kind === TokenKind_1.TokenKind.StringTemplateLiteral) {
            var stringLiteral = parser.parseStringTemplateLiteral();
            // Unlike heredoc and shell command templates, if there is not at least
            // one interpolation, the lexer will not create a string template token.
            php_common_1.Debug.assert(parser.isStringTemplateElementStart(parser.currentToken.kind));
            nodes = parser.parseStringTemplateElementList(stringLiteral, TokenKind_1.TokenKind.DoubleQuote);
        }
        else {
            nodes = parser.parseStringTemplateElementList(null, TokenKind_1.TokenKind.DoubleQuote);
        }
        var closeQuote;
        if (parser.currentToken.kind === TokenKind_1.TokenKind.DoubleQuote) {
            closeQuote = parser.eat(TokenKind_1.TokenKind.DoubleQuote);
        }
        else {
            // The parser should always reach the end of a template.
            php_common_1.Debug.assert(parser.currentToken.kind === TokenKind_1.TokenKind.EOF);
            // If the closing quote was missing, the lexer already added an error.
            closeQuote = parser.createMissingToken(TokenKind_1.TokenKind.DoubleQuote, parser.currentToken.kind, false);
            // Move any trailing trivia over to this parser.
            if (parser.leadingTrivia.length > 0) {
                this.leadingTrivia = this.leadingTrivia.concat(parser.leadingTrivia);
                this.leadingTriviaWidth += parser.leadingTriviaWidth;
            }
        }
        return new Node_Generated_1.StringTemplateNode(openQuote, nodes, closeQuote);
    };
    /**
     * Parses an interpolation in a string template.
     *
     * Syntax:
     * - `string-indirection`
     * - `string-variable`
     * - `{ expr }`
     */
    PhpParser.prototype.parseStringTemplateElement = function () {
        switch (this.currentToken.kind) {
            case TokenKind_1.TokenKind.Variable:
                return this.parseStringTemplateVariable();
            case TokenKind_1.TokenKind.DollarOpenBrace:
                return this.parseStringTemplateIndirection();
            case TokenKind_1.TokenKind.OpenBrace:
                // NOTE: To get this token the lexer must have scanned a `{$`.
                var openBrace = this.eat(TokenKind_1.TokenKind.OpenBrace);
                var expression = this.parseExpression(ExpressionType_1.ExpressionType.Explicit);
                var closeBrace = this.eat(TokenKind_1.TokenKind.CloseBrace);
                return new Node_Generated_1.StringExpressionNode(openBrace, expression, closeBrace);
            default:
                // This should only be reached under two conditions:
                // 1) There is a missing call to `isStringTemplateElement()`.
                // 2) The lexer failed to return a `StringTemplateLiteral` when it should have.
                throw new Parser_1.ParserException('Expected template variable not found');
        }
    };
    /**
     * Parses a list of literal strings and interpolations within a string template.
     *
     * Syntax: `string-template-list`
     *
     * Where `string-template-list` is:
     * - `string-template-list string-template-element`
     * - `string-template-list STRING_TEMPLATE_LITERAL`
     * - `string-template-element`
     * - `STRING_TEMPLATE_LITERAL string-template-element`
     *
     * @param {LiteralNode|null} templateLiteral
     *   The first literal within a string template.
     * @param {TokenKind} terminator
     *   The token used to terminate the string template.
     */
    PhpParser.prototype.parseStringTemplateElementList = function (templateLiteral, terminator) {
        var nodes = [];
        if (templateLiteral !== null) {
            nodes.push(templateLiteral);
            nodes.push(this.parseStringTemplateElement());
        }
        else {
            nodes.push(this.parseStringTemplateElement());
        }
        while (this.currentToken.kind !== TokenKind_1.TokenKind.EOF && this.currentToken.kind !== terminator) {
            if (this.currentToken.kind === TokenKind_1.TokenKind.StringTemplateLiteral) {
                nodes.push(this.parseStringTemplateLiteral());
            }
            else if (this.isStringTemplateElementStart(this.currentToken.kind)) {
                nodes.push(this.parseStringTemplateElement());
            }
            else {
                // An interpolation can cause the lexer to remain in the "in script"
                // state which will cause it to return unexpected tokens.
                this.skipBadStringTemplateTokens(terminator);
            }
        }
        return this.factory.createList(nodes);
    };
    /**
     * Parses an expression that is used to determine a variable name within a
     * string template.
     *
     * Syntax:
     * - `${ expr }`
     * - `${ STRING_IDENTIFIER }`
     * - `${ STRING_IDENTIFIER [ expr ] }`
     */
    PhpParser.prototype.parseStringTemplateIndirection = function () {
        var dollarOpenBrace = this.eat(TokenKind_1.TokenKind.DollarOpenBrace);
        if (this.currentToken.kind !== TokenKind_1.TokenKind.StringIdentifier) {
            var expr = void 0;
            if (this.isExpressionStart(this.currentToken.kind)) {
                expr = this.parseExpression();
            }
            else {
                var identifier = this.createMissingTokenWithError(TokenKind_1.TokenKind.StringIdentifier, ErrorCode_Generated_1.ErrorCode.ERR_StringVariableNameExpected);
                expr = new Node_Generated_1.StringVariableNode(identifier);
            }
            var closeBrace_1 = this.eat(TokenKind_1.TokenKind.CloseBrace);
            return new Node_Generated_1.IndirectStringVariableNode(dollarOpenBrace, expr, closeBrace_1);
        }
        var variable = new Node_Generated_1.StringVariableNode(this.eat(TokenKind_1.TokenKind.StringIdentifier));
        // Suppress TS2365: Current token changed after previous method call.
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenBracket) {
            var openBracket = this.eat(TokenKind_1.TokenKind.OpenBracket);
            var index = this.parseExpression();
            var closeBracket = this.eat(TokenKind_1.TokenKind.CloseBracket);
            var reference = new Node_Generated_1.ElementAccessNode(variable, openBracket, index, closeBracket);
            var closeBrace_2 = this.eat(TokenKind_1.TokenKind.CloseBrace);
            return new Node_Generated_1.IndirectStringVariableNode(dollarOpenBrace, reference, closeBrace_2);
        }
        var closeBrace = this.eat(TokenKind_1.TokenKind.CloseBrace);
        return new Node_Generated_1.IndirectStringVariableNode(dollarOpenBrace, variable, closeBrace);
    };
    /**
     * Parses the text within a string template.
     */
    PhpParser.prototype.parseStringTemplateLiteral = function () {
        return new Node_Generated_1.LiteralNode(this.eat(TokenKind_1.TokenKind.StringTemplateLiteral));
    };
    /**
     * Parses a variable within a string template.
     *
     * Syntax:
     * - `VARIABLE`
     * - `VARIABLE [ string-offset ]`
     * - `VARIABLE -> member-name`
     *
     * Where `string-offset` is:
     * - `IDENTIFIER`
     * - `STRING_NUMBER`
     * - `- STRING_NUMBER`
     * - `VARIABLE`
     */
    PhpParser.prototype.parseStringTemplateVariable = function () {
        var variable = this.eat(TokenKind_1.TokenKind.Variable);
        if (this.currentToken.kind === TokenKind_1.TokenKind.OpenBracket) {
            var openBracket = this.eat(TokenKind_1.TokenKind.OpenBracket);
            var minus = null;
            var offset = void 0;
            if (this.isStringTemplateVariableOffset(this.currentToken.kind)) {
                offset = this.eat(this.currentToken.kind);
            }
            // Suppress TS2365: Current token changed after previous method call.
            else if (this.currentToken.kind === TokenKind_1.TokenKind.Minus) {
                minus = this.eat(TokenKind_1.TokenKind.Minus);
                // Suppress TS2365: Current token changed after previous method call.
                offset = this.currentToken.kind === TokenKind_1.TokenKind.StringNumber
                    ? this.eat(TokenKind_1.TokenKind.StringNumber)
                    : this.createMissingTokenWithError(TokenKind_1.TokenKind.StringNumber, ErrorCode_Generated_1.ErrorCode.ERR_StringOffsetNumberExpected);
            }
            else {
                offset = this.createMissingTokenWithError(TokenKind_1.TokenKind.Variable, ErrorCode_Generated_1.ErrorCode.ERR_StringOffsetExpected);
            }
            var closeBracket = this.eat(TokenKind_1.TokenKind.CloseBracket);
            return new Node_Generated_1.StringElementAccessNode(variable, openBracket, minus, offset, closeBracket);
        }
        else if (this.currentToken.kind === TokenKind_1.TokenKind.ObjectOperator) {
            var dereferenceable = new Node_Generated_1.LocalVariableNode(variable);
            var objOperator = this.eat(TokenKind_1.TokenKind.ObjectOperator);
            var identifier = this.isClassMemberIdentifier(this.currentToken.kind)
                ? this.eat(this.currentToken.kind)
                : this.createMissingToken(TokenKind_1.TokenKind.Identifier, this.currentToken.kind, true);
            return new Node_Generated_1.NamedMemberAccessNode(dereferenceable, objOperator, identifier);
        }
        else {
            return new Node_Generated_1.LocalVariableNode(variable);
        }
    };
    /**
     * Parses a yield expression.
     *
     * Syntax:
     * - `YIELD`
     * - `YIELD expr`
     * - `YIELD expr => expr`
     */
    PhpParser.prototype.parseYield = function () {
        var yieldKeyword = this.eat(TokenKind_1.TokenKind.Yield);
        if (!this.isExpressionStart(this.currentToken.kind)) {
            return new Node_Generated_1.YieldNode(yieldKeyword, null, null, null);
        }
        var expr = this.parseExpression();
        if (this.currentToken.kind === TokenKind_1.TokenKind.DoubleArrow) {
            var doubleArrow = this.eat(TokenKind_1.TokenKind.DoubleArrow);
            var valueExpr = this.parseExpression();
            return new Node_Generated_1.YieldNode(yieldKeyword, expr, doubleArrow, valueExpr);
        }
        return new Node_Generated_1.YieldNode(yieldKeyword, null, null, expr);
    };
    /**
     * Parses a yield from expression.
     *
     * Syntax: `YIELD FROM expr`
     */
    PhpParser.prototype.parseYieldFrom = function () {
        var yieldFromKeyword = this.eat(TokenKind_1.TokenKind.YieldFrom);
        var expr = this.parseExpression();
        return new Node_Generated_1.YieldFromNode(yieldFromKeyword, expr);
    };
    // --------------------------------------------------------------------------
    // Utility and error recovery methods
    // --------------------------------------------------------------------------
    /**
     * Gets a `ModifierFlag` for modifier keywords.
     */
    PhpParser.prototype.getModifierFlag = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.Abstract:
                return ModifierFlags_1.ModifierFlags.Abstract;
            case TokenKind_1.TokenKind.Final:
                return ModifierFlags_1.ModifierFlags.Final;
            case TokenKind_1.TokenKind.Private:
                return ModifierFlags_1.ModifierFlags.Private;
            case TokenKind_1.TokenKind.Protected:
                return ModifierFlags_1.ModifierFlags.Protected;
            case TokenKind_1.TokenKind.Public:
                return ModifierFlags_1.ModifierFlags.Public;
            case TokenKind_1.TokenKind.Static:
                return ModifierFlags_1.ModifierFlags.Static;
            default:
                return ModifierFlags_1.ModifierFlags.None;
        }
    };
    /**
     * Gets the precedence of a specified *binary* operator.
     *
     * @param {TokenKind} kind
     *   An expression operator.
     *
     * @return {Precedence}
     *   The operator's precedence or `Precedence.None` if the token is not
     *   a known operator.
     */
    PhpParser.prototype.getPrecedence = function (kind) {
        switch (kind) {
            case TokenKind_1.TokenKind.LogicalOr:
                return Precedence_1.Precedence.LogicalOr;
            case TokenKind_1.TokenKind.LogicalXor:
                return Precedence_1.Precedence.LogicalXor;
            case TokenKind_1.TokenKind.LogicalAnd:
                return Precedence_1.Precedence.LogicalAnd;
            case TokenKind_1.TokenKind.AndEqual:
            case TokenKind_1.TokenKind.CoalesceEqual:
            case TokenKind_1.TokenKind.ConcatEqual:
            case TokenKind_1.TokenKind.DivideEqual:
            case TokenKind_1.TokenKind.Equal:
            case TokenKind_1.TokenKind.MinusEqual:
            case TokenKind_1.TokenKind.ModEqual:
            case TokenKind_1.TokenKind.MultiplyEqual:
            case TokenKind_1.TokenKind.OrEqual:
            case TokenKind_1.TokenKind.PlusEqual:
            case TokenKind_1.TokenKind.PowEqual:
            case TokenKind_1.TokenKind.ShiftLeftEqual:
            case TokenKind_1.TokenKind.ShiftRightEqual:
            case TokenKind_1.TokenKind.XorEqual:
                return Precedence_1.Precedence.Assignment;
            case TokenKind_1.TokenKind.Question:
                return Precedence_1.Precedence.Ternary;
            case TokenKind_1.TokenKind.Coalesce:
                return Precedence_1.Precedence.Coalesce;
            case TokenKind_1.TokenKind.BooleanOr:
                return Precedence_1.Precedence.BooleanOr;
            case TokenKind_1.TokenKind.BooleanAnd:
                return Precedence_1.Precedence.BooleanAnd;
            case TokenKind_1.TokenKind.VerticalBar:
                return Precedence_1.Precedence.BitwiseOr;
            case TokenKind_1.TokenKind.Caret:
                return Precedence_1.Precedence.BitwiseXor;
            case TokenKind_1.TokenKind.Ampersand:
                return Precedence_1.Precedence.BitwiseAnd;
            case TokenKind_1.TokenKind.Inequality:
            case TokenKind_1.TokenKind.IsEqual:
            case TokenKind_1.TokenKind.IsIdentical:
            case TokenKind_1.TokenKind.IsNotEqual:
            case TokenKind_1.TokenKind.IsNotIdentical:
            case TokenKind_1.TokenKind.Spaceship:
                return Precedence_1.Precedence.Equality;
            case TokenKind_1.TokenKind.GreaterThan:
            case TokenKind_1.TokenKind.IsGreaterThanOrEqual:
            case TokenKind_1.TokenKind.IsLessThanOrEqual:
            case TokenKind_1.TokenKind.LessThan:
                return Precedence_1.Precedence.Relational;
            case TokenKind_1.TokenKind.ShiftLeft:
            case TokenKind_1.TokenKind.ShiftRight:
                return Precedence_1.Precedence.Shift;
            case TokenKind_1.TokenKind.Minus:
            case TokenKind_1.TokenKind.Period:
            case TokenKind_1.TokenKind.Plus:
                return Precedence_1.Precedence.Add;
            case TokenKind_1.TokenKind.Asterisk:
            case TokenKind_1.TokenKind.Percent:
            case TokenKind_1.TokenKind.Slash:
                return Precedence_1.Precedence.Multiply;
            case TokenKind_1.TokenKind.InstanceOf:
                return Precedence_1.Precedence.InstanceOf;
            case TokenKind_1.TokenKind.Pow:
                return Precedence_1.Precedence.Pow;
            default:
                return Precedence_1.Precedence.None;
        }
    };
    /**
     * Determines if the given modifier would make the declaration abstract
     * and private.
     */
    PhpParser.prototype.isAbstractAndPrivate = function (currentFlags, modifier) {
        // This method should not be reached if the modifier is a duplicate.
        php_common_1.Debug.assert((currentFlags & modifier) === 0);
        if (currentFlags & ModifierFlags_1.ModifierFlags.Abstract) {
            return ((currentFlags | modifier) & ModifierFlags_1.ModifierFlags.Private) !== 0;
        }
        if (currentFlags & ModifierFlags_1.ModifierFlags.Private) {
            return ((currentFlags | modifier) & ModifierFlags_1.ModifierFlags.Abstract) !== 0;
        }
        return false;
    };
    /**
     * Determines if the specified binary operator is expected given the expression
     * type that has been parsed.
     *
     * @param {TokenKind} operator
     *   A binary operator.
     * @param {ExpressionType} type
     *   The expression type of the left operand.
     */
    PhpParser.prototype.isBinaryOperatorExpected = function (operator, type) {
        // Assignment operators require an explicit LHS, and may "override"
        // precedence rules to create a valid expression.
        if (type === ExpressionType_1.ExpressionType.Explicit && this.isAssignmentOperator(operator)) {
            return true;
        }
        return false;
    };
    /**
     * Determines if a parameter is entirely missing.
     */
    PhpParser.prototype.isParameterMissing = function (parameter) {
        return parameter.ampersand === null && parameter.ellipsis === null && parameter.variable.isMissing;
    };
    /**
     * Determines if the next token may start a member declaration and is on a
     * different line.
     */
    PhpParser.prototype.isPossibleMemberDeclarationStart = function () {
        if (this.leadingTrivia.length === 0) {
            return false;
        }
        // @todo Ideally this would check for a line break anywhere in the trivia,
        //   and then check the next TWO tokens. However, since the parser does not
        //   have a "peek" method (yet?), settle for a strict check of an immediate
        //   line break.
        if (this.leadingTrivia[0].kind !== TokenKind_1.TokenKind.LineBreak) {
            return false;
        }
        switch (this.currentToken.kind) {
            case TokenKind_1.TokenKind.Const:
            case TokenKind_1.TokenKind.Function:
                return true;
            default:
                return this.getModifierFlag(this.currentToken.kind) !== ModifierFlags_1.ModifierFlags.None;
        }
    };
    /**
     * Determines if the specified unary operator is expected given the expression
     * type that should be parsed.
     *
     * @param {TokenKind} operator
     *   A unary operator.
     * @param {ExpressionType} type
     *   The expected expression type.
     */
    PhpParser.prototype.isUnaryOperatorExpected = function (operator, type) {
        // If the expected type is `Explicit` then this is the operand of a prefix-
        // decrement or prefix-increment expression (all other unary expressions
        // expect `Any`). In that case, the next operator cannot be '--' or '++' as
        // that would make the operand `Implicit`.
        if (type === ExpressionType_1.ExpressionType.Explicit && (operator === TokenKind_1.TokenKind.Decrement || operator === TokenKind_1.TokenKind.Increment)) {
            return false;
        }
        return true;
    };
    /**
     * @todo Document skipBadArgumentListTokens().
     */
    PhpParser.prototype.skipBadArgumentListTokens = function () {
        this.skipToken(); // @todo Invalid token '%s' in argument list
        while (this.currentToken.kind !== TokenKind_1.TokenKind.EOF) {
            if (this.isArgumentStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
                break; // @todo continue
            }
            if (this.currentToken.kind === TokenKind_1.TokenKind.CloseParen) {
                break; // @todo abort
            }
            this.skipToken();
        }
    };
    /**
     * @todo Document skipBadForExpressionListTokens().
     */
    PhpParser.prototype.skipBadForExpressionListTokens = function (terminator) {
        this.skipToken(); // @todo Invalid token '%s' in for expression
        var kind = this.currentToken.kind;
        while (kind !== TokenKind_1.TokenKind.EOF) {
            if (this.isExpressionStart(kind) || kind === TokenKind_1.TokenKind.Comma) {
                break; // @todo continue
            }
            if (kind === TokenKind_1.TokenKind.CloseParen || kind === terminator) {
                break; // @todo abort
            }
            this.skipToken();
            kind = this.currentToken.kind;
        }
    };
    /**
     * A custom recovery strategy that matches opening and closing braces.
     */
    PhpParser.prototype.skipBadMemberTokens = function () {
        var braceCount = 0;
        // Always consume at least one token.
        this.skipTokenWithError(ErrorCode_Generated_1.ErrorCode.ERR_InvalidMemberDeclaration, TokenKind_1.TokenKindInfo.getText(this.currentToken.kind));
        var kind = this.currentToken.kind;
        while (kind !== TokenKind_1.TokenKind.EOF) {
            if (this.isClassMemberStart(kind)) {
                break;
            }
            if (kind === TokenKind_1.TokenKind.OpenBrace) {
                braceCount++;
            }
            else if (kind === TokenKind_1.TokenKind.CloseBrace) {
                if (braceCount === 0) {
                    break;
                }
                braceCount--;
            }
            this.skipToken();
            kind = this.currentToken.kind;
        }
    };
    /**
     * @todo Document skipBadParameterListTokens().
     */
    PhpParser.prototype.skipBadParameterListTokens = function () {
        this.skipToken(); // @todo Invalid token '%s' in parameter list
        while (this.currentToken.kind !== TokenKind_1.TokenKind.EOF) {
            if (this.isParameterStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.Comma) {
                break; // @todo continue
            }
            if (this.currentToken.kind === TokenKind_1.TokenKind.CloseParen) {
                break; // @todo abort
            }
            this.skipToken();
        }
    };
    /**
     * @todo Document skipBadStringTemplateTokens().
     */
    PhpParser.prototype.skipBadStringTemplateTokens = function (terminator) {
        this.skipToken(); // @todo Invalid token '%s' in string template
        while (this.currentToken.kind !== TokenKind_1.TokenKind.EOF) {
            if (this.isStringTemplateElementStart(this.currentToken.kind) || this.currentToken.kind === TokenKind_1.TokenKind.StringTemplateLiteral) {
                break; // @todo continue
            }
            if (this.currentToken.kind === terminator) {
                break; // @todo abort
            }
            this.skipToken();
        }
    };
    /**
     * @todo Document skipBadTraitUseTokens().
     */
    PhpParser.prototype.skipBadTraitUseTokens = function () {
        this.skipToken(); // @todo Invalid token '%s' in trait adaptation
        while (this.currentToken.kind !== TokenKind_1.TokenKind.EOF) {
            if (this.isTraitAdaptationStart(this.currentToken.kind)) {
                break; // @todo continue
            }
            if (this.currentToken.kind === TokenKind_1.TokenKind.CloseBrace) {
                break; // @todo abort
            }
            this.skipToken();
        }
    };
    return PhpParser;
}());
exports.PhpParser = PhpParser;
