/**
 * Copyright 2017 Matt Acosta
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyntaxToken = void 0;
var php_common_1 = require("../../../php-common");
var NodeExtensions_1 = require("../node/NodeExtensions");
var SyntaxNodeExtensions_1 = require("./SyntaxNodeExtensions");
var SyntaxTriviaList_1 = require("./SyntaxTriviaList");
var TextSpan_1 = require("../../text/TextSpan");
var TokenKind_1 = require("../TokenKind");
/**
 * Represents a terminal node in a syntax tree.
 */
var SyntaxToken = /** @class */ (function () {
    /**
     * Constructs a `SyntaxToken` object.
     */
    function SyntaxToken(node, parent, offset, index) {
        php_common_1.Debug.assert(node === null || node.isToken);
        this.node = node;
        this.parent = parent;
        this.offset = offset;
        this.index = index;
    }
    Object.defineProperty(SyntaxToken.prototype, "endOffset", {
        /**
         * @todo Unused.
         */
        get: function () {
            return this.node !== null ? this.offset + this.node.fullWidth : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxToken.prototype, "containsDiagnostics", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this.node !== null ? this.node.containsDiagnostics : false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxToken.prototype, "fullSpan", {
        /**
         * @inheritDoc
         */
        get: function () {
            return new TextSpan_1.TextSpan(this.offset, this.node !== null ? this.node.fullWidth : 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxToken.prototype, "isMissing", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this.node !== null ? this.node.isMissing : false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxToken.prototype, "isToken", {
        /**
         * @inheritDoc
         */
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxToken.prototype, "leadingTrivia", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this.node !== null ? new SyntaxTriviaList_1.SyntaxTriviaList(this.node.leadingTrivia, this, this.offset) : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxToken.prototype, "kind", {
        /**
         * @inheritDoc
         */
        get: function () {
            // @todo This is cheating.
            return this.node !== null ? this.node.kind : TokenKind_1.TokenKind.Unknown;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SyntaxToken.prototype, "span", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this.node !== null
                ? new TextSpan_1.TextSpan(this.offset + this.node.leadingTriviaWidth, this.node.width)
                : new TextSpan_1.TextSpan(this.offset, 0);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Determines if the token has a width (not including trivia).
     */
    SyntaxToken.hasWidth = function (token) {
        var span = token.span;
        var width = span ? span.length : 0;
        return width > 0;
    };
    /**
     * Gets the text of a token.
     *
     * @param {ISyntaxToken} token
     *   A token in a syntax tree.
     * @param {ISourceText} text
     *   The text of the syntax tree that contains the token.
     */
    SyntaxToken.getText = function (token, text) {
        if (token.span.end > text.length) {
            throw new php_common_1.ArgumentException('Token is not in source text');
        }
        if (token.span.isEmpty) {
            return '';
        }
        return text.substring(token.span.start, token.span.length);
    };
    /**
     * Attempts to get the first token matching the given filter(s).
     *
     * @param {ISyntaxToken} token
     *   The token to search.
     * @param {SyntaxTokenFilter=} tokenFilter
     *   A callback used to limit what tokens are returned. This filter is
     *   applied to the current token and tokens found within structured
     *   trivia, if any. If not provided, any token will match.
     * @param {SyntaxTriviaFilter=} triviaFilter
     *   A callback used to limit what structured trivia nodes are searched.
     *   If not provided, trivia is not searched.
     */
    SyntaxToken.tryGetFirstToken = function (token, tokenFilter, triviaFilter) {
        var leadingTrivia = token.leadingTrivia;
        if (leadingTrivia !== null && triviaFilter !== undefined) {
            var structuredToken = SyntaxTriviaList_1.SyntaxTriviaList.tryGetFirstToken(leadingTrivia, triviaFilter, tokenFilter);
            if (structuredToken !== null) {
                return structuredToken;
            }
        }
        if (tokenFilter === undefined || tokenFilter(token)) {
            return token;
        }
        return null;
    };
    /**
     * Attempts to get the last token matching the given filter(s).
     *
     * @param {ISyntaxToken} token
     *   The token to search.
     * @param {SyntaxTokenFilter=} tokenFilter
     *   A callback used to limit what tokens are returned. This filter is
     *   applied to the current token and tokens found within structured
     *   trivia, if any. If not provided, any token will match.
     * @param {SyntaxTriviaFilter=} triviaFilter
     *   A callback used to limit what structured trivia nodes are searched.
     *   If not provided, trivia is not searched.
     */
    SyntaxToken.tryGetLastToken = function (token, tokenFilter, triviaFilter) {
        if (tokenFilter === undefined || tokenFilter(token)) {
            return token;
        }
        var leadingTrivia = token.leadingTrivia;
        if (leadingTrivia !== null && triviaFilter !== undefined) {
            var structuredToken = SyntaxTriviaList_1.SyntaxTriviaList.tryGetLastToken(leadingTrivia, triviaFilter, tokenFilter);
            if (structuredToken !== null) {
                return structuredToken;
            }
        }
        return null;
    };
    /**
     * Attempts to get the next token matching the given filter(s).
     *
     * @param {ISyntaxToken} token
     *   The token to search.
     * @param {SyntaxTokenFilter=} tokenFilter
     *   A callback used to limit what tokens are returned. This filter is
     *   applied to the current token and tokens found within structured
     *   trivia, if any. If not provided, any token will match.
     * @param {SyntaxTriviaFilter=} triviaFilter
     *   A callback used to limit what structured trivia nodes are searched.
     *   If not provided, trivia is not searched.
     */
    SyntaxToken.tryGetNextToken = function (token, tokenFilter, triviaFilter) {
        // @todo Instead of changing this method signature, add another method
        //   that also searches the leading trivia of a token.
        var e_1, _a;
        var found = false;
        try {
            for (var _b = __values(token.parent.getAllChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (found) {
                    if (child.isToken) {
                        var result = SyntaxToken.tryGetFirstToken(child, tokenFilter /*, triviaFilter */);
                        if (result !== null) {
                            return result;
                        }
                    }
                    else {
                        var result = SyntaxNodeExtensions_1.SyntaxNodeExtensions.tryGetFirstToken(child, tokenFilter /*, triviaFilter */);
                        if (result !== null) {
                            return result;
                        }
                    }
                }
                else if (child.isToken && token.equals(child)) {
                    // Found the current token, so any remaining tokens should be searched.
                    found = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Not found in parent, check the grandparent.
        return SyntaxNodeExtensions_1.SyntaxNodeExtensions.tryGetNextToken(token.parent, tokenFilter);
    };
    /**
     * Attempts to get the previous token matching the given filter(s).
     *
     * @param {ISyntaxToken} token
     *   The token to search.
     * @param {SyntaxTokenFilter=} tokenFilter
     *   A callback used to limit what tokens are returned. This filter is
     *   applied to the current token and tokens found within structured
     *   trivia, if any. If not provided, any token will match.
     * @param {SyntaxTriviaFilter=} triviaFilter
     *   A callback used to limit what structured trivia nodes are searched.
     *   If not provided, trivia is not searched.
     */
    SyntaxToken.tryGetPreviousToken = function (token, tokenFilter, triviaFilter) {
        // @todo Instead of changing this method signature, add another method
        //   that also searches the leading trivia of a token.
        var e_2, _a;
        var found = false;
        try {
            for (var _b = __values(token.parent.getAllChildrenReversed()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (found) {
                    if (child.isToken) {
                        var result = SyntaxToken.tryGetLastToken(child, tokenFilter /*, triviaFilter */);
                        if (result !== null) {
                            return result;
                        }
                    }
                    else {
                        var result = SyntaxNodeExtensions_1.SyntaxNodeExtensions.tryGetLastToken(child, tokenFilter /*, triviaFilter */);
                        if (result !== null) {
                            return result;
                        }
                    }
                }
                else if (child.isToken && token.equals(child)) {
                    // Found the current token, so any remaining tokens should be searched.
                    found = true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // Not found in parent, check the grandparent.
        return SyntaxNodeExtensions_1.SyntaxNodeExtensions.tryGetPreviousToken(token.parent, tokenFilter);
    };
    /**
     * @inheritDoc
     */
    SyntaxToken.prototype.equals = function (value) {
        if (this === value) {
            return true;
        }
        if (this.offset === value.offset && this.index === value.index && this.parent.equals(value.parent)) {
            return NodeExtensions_1.NodeExtensions.equals(this.node, value.node);
        }
        return false;
    };
    /**
     * @inheritDoc
     */
    SyntaxToken.prototype.nextToken = function (includeZeroWidth) {
        if (includeZeroWidth === void 0) { includeZeroWidth = false; }
        if (this.node === null) {
            return null;
        }
        if (!includeZeroWidth) {
            return SyntaxToken.tryGetNextToken(this, SyntaxToken.hasWidth);
        }
        return SyntaxToken.tryGetNextToken(this);
    };
    /**
     * @inheritDoc
     */
    SyntaxToken.prototype.previousToken = function (includeZeroWidth) {
        if (includeZeroWidth === void 0) { includeZeroWidth = false; }
        if (this.node === null) {
            return null;
        }
        if (!includeZeroWidth) {
            return SyntaxToken.tryGetPreviousToken(this, SyntaxToken.hasWidth);
        }
        return SyntaxToken.tryGetPreviousToken(this);
    };
    return SyntaxToken;
}());
exports.SyntaxToken = SyntaxToken;
