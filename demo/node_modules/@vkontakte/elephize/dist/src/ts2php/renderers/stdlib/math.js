"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.supportedMathMethods = exports.math = void 0;
var ts = require("typescript");
var ast_1 = require("../../utils/ast");
var renderNodes_1 = require("../../components/codegen/renderNodes");
/**
 * Math.* methods and constants
 *
 * @param node
 * @param context
 */
var math = function (node, context) {
    var toCheck = node.expression.kind === ts.SyntaxKind.PropertyAccessExpression &&
        node.expression.expression.getText() === 'Math';
    if (!toCheck) {
        return undefined;
    }
    var operation = node.expression.name.escapedText.toString();
    switch (operation) {
        case 'abs':
        case 'round':
        case 'floor':
        case 'ceil':
        case 'sin':
        case 'cos':
        case 'tan':
        case 'asin':
        case 'acos':
        case 'atan':
        case 'exp':
        case 'log':
        case 'sqrt':
            var varName = renderNodes_1.renderNode(ast_1.getCallExpressionArg(node), context);
            return operation + "(" + varName + ")";
        case 'random':
            return '(mt_rand(0, PHP_INT_MAX) / (float)PHP_INT_MAX)';
        case 'pow':
        case 'max':
        case 'min':
            var nodes = renderNodes_1.renderNodes(__spreadArray([], __read(node.arguments)), context);
            return operation + "(" + nodes.join(', ') + ")";
        case 'log2':
            return "log(" + renderNodes_1.renderNode(ast_1.getCallExpressionArg(node), context) + ", 2)";
        case 'log10':
            return "log(" + renderNodes_1.renderNode(ast_1.getCallExpressionArg(node), context) + ", 10)";
        default:
            context.log.error('Math: unsupported method (%s)', [operation], context.log.ctx(node));
            return 'null';
    }
};
exports.math = math;
exports.supportedMathMethods = [
    'abs',
    'round',
    'floor',
    'ceil',
    'sin',
    'cos',
    'tan',
    'asin',
    'acos',
    'atan',
    'exp',
    'log',
    'sqrt',
    'random',
    'pow',
    'max',
    'min',
    'log2',
    'log10',
];
