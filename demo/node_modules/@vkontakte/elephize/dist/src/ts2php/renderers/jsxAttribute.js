"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tJsxAttribute = void 0;
var ts = require("typescript");
var intrinsicElements_1 = require("../internalConfig/intrinsicElements");
var callbackAttrs = require("../../../data/domattrs.json");
var renderNodes_1 = require("../components/codegen/renderNodes");
var basicTypes_1 = require("../components/typeInference/basicTypes");
var escapeString_1 = require("../utils/escapeString");
function tJsxAttribute(node, context) {
    var _a;
    if (node.name.getText() === 'dangerouslySetInnerHTML') {
        var expr_1 = (_a = node === null || node === void 0 ? void 0 : node.initializer) === null || _a === void 0 ? void 0 : _a.expression;
        var _b = __read(expr_1 === null || expr_1 === void 0 ? void 0 : expr_1.properties, 1), prop = _b[0];
        if (!(prop === null || prop === void 0 ? void 0 : prop.name) || (prop === null || prop === void 0 ? void 0 : prop.name.getText()) !== '__html') {
            context.log.error('Wrong use of dangerouslySetInnerHtml: __html property not found', [], context.log.ctx(node));
            return '';
        }
        var value = prop.initializer;
        var renderedValue = renderNodes_1.renderNode(value, context);
        var parentJsxElement = node.parent.parent;
        context.nodeFlagsStore.upsert(parentJsxElement, { prerenderedData: [renderedValue] });
        return '';
    }
    if (node.name.getText() === 'ref') { // We don't support react refs on server side
        return '';
    }
    if (!node.initializer) { // react boolean attribute
        return "\"" + node.name.getText() + "\" => true";
    }
    var jsxel = node.parent.parent; // opening jsx / self-closing jsx
    if (intrinsicElements_1.intrinsicElements[jsxel.tagName.getText()] && node.name.getText() !== 'style' && !callbackAttrs.includes(node.name.getText())) {
        // validate intrinsic attributes: now we support only strings, with exception of 'object' for 'style' attr
        var attrInitializer = node.initializer.expression || node.initializer; // 1st for attr={'test'}, 2nd for attr="test"
        var attrType = basicTypes_1.getPhpPrimitiveType(attrInitializer, context.checker, context.log);
        if (attrType.includes('[]') || attrType.includes('mixed')) {
            context.log.error('Unsupported type of attribute %s: inferred type is %s, but only scalars are supported', [jsxel.tagName.getText() + '::' + node.getText(), attrType], context.log.ctx(node));
        }
    }
    if (ts.isStringLiteral(node.initializer)) { // should print escaped text in this one
        return "\"" + node.name.getText() + "\" => " + escapeString_1.escapeTextLiteral(node.initializer.text);
    }
    var expr = renderNodes_1.renderNode(node.initializer, context);
    return "\"" + node.name.getText() + "\" => " + expr;
}
exports.tJsxAttribute = tJsxAttribute;
