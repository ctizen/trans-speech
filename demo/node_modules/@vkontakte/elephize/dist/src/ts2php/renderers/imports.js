"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tNamedImports = exports.tImportClause = exports.tImportDeclaration = void 0;
var ts = require("typescript");
var ast_1 = require("../utils/ast");
var path = require("path");
var reactHooks_1 = require("../components/react/reactHooks");
var pathsAndNames_1 = require("../utils/pathsAndNames");
var renderNodes_1 = require("../components/codegen/renderNodes");
function tImportDeclaration(node, context) {
    var e_1, _a;
    var _b, _c, _d;
    var moduleSpec = node.moduleSpecifier.text;
    if (moduleSpec === 'react') {
        if (!reactHooks_1.initReact(node, context)) {
            context.log.error('Importing react with dereferencing is not supported. Use `import * as React from \'react\' instead.', [], context.log.ctx(node));
            return '';
        }
    }
    else if (moduleSpec) {
        var currentFilePath = node.getSourceFile().fileName;
        var sourceFilename = pathsAndNames_1.resolveAliasesAndPaths(context.log, moduleSpec, path.dirname(currentFilePath), context.baseDir, context.compilerOptions.paths || {}, context.registry._aliases);
        if (sourceFilename === null) {
            if (moduleSpec.includes('/')) {
                context.log.error('Module not found: tried to find %s', [moduleSpec], context.log.ctx(node));
            }
            else {
                context.log.error('Importing arbitrary node modules is not supported. Only "react" module is allowed at the moment.' +
                    ' Also you may want to import specific file from module - this is supported.', [], context.log.ctx(node));
            }
            return '';
        }
        renderNodes_1.renderNodes([node.importClause, node.moduleSpecifier], context);
        var importBindings = (_b = node.importClause) === null || _b === void 0 ? void 0 : _b.namedBindings;
        if ((importBindings === null || importBindings === void 0 ? void 0 : importBindings.kind) === ts.SyntaxKind.NamespaceImport) {
            var decl = context.scope.addDeclaration(importBindings.name.getText(), [], { terminateGlobally: ast_1.isExportedVar(importBindings.name), dryRun: context.dryRun });
            if (decl) {
                decl.data.flags = { External: true };
                decl.data.targetModulePath = context.registry.toTargetPath(sourceFilename);
                decl.data.propName = '*';
            }
        }
        else if ((importBindings === null || importBindings === void 0 ? void 0 : importBindings.kind) === ts.SyntaxKind.NamedImports) {
            try {
                for (var _e = __values(importBindings.elements), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var imp = _f.value;
                    var searchForComponent = context.registry.isDerivedComponent(sourceFilename, imp.name.escapedText.toString()) ?
                        imp.name.escapedText.toString() :
                        undefined;
                    var decl = context.scope.addDeclaration(imp.name.getText(), [], { terminateGlobally: ast_1.isExportedVar(imp.name), dryRun: context.dryRun });
                    var originalMethodName = (decl === null || decl === void 0 ? void 0 : decl.data.propName) || imp.name.getText();
                    context.moduleDescriptor.registerImport(sourceFilename, originalMethodName);
                    if (imp.kind === ts.SyntaxKind.ImportSpecifier) {
                        // "import { foo as bar }" handle;
                        originalMethodName = ((_c = imp.getChildren().find(function (child) { return child.kind === ts.SyntaxKind.Identifier; })) === null || _c === void 0 ? void 0 : _c.getText()) || originalMethodName;
                    }
                    var originalModule = context.registry.getModuleMethodSource(context.moduleDescriptor, originalMethodName);
                    var impSourceFileName = (originalModule === null || originalModule === void 0 ? void 0 : originalModule.sourceFileName) || sourceFilename;
                    if (decl) {
                        decl.data.flags = { DereferencedImport: true };
                        decl.data.targetModulePath = context.registry.toTargetPath(impSourceFileName, searchForComponent);
                        decl.data.propName = ((_d = imp.propertyName) === null || _d === void 0 ? void 0 : _d.getText()) || imp.name.getText();
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    return '';
}
exports.tImportDeclaration = tImportDeclaration;
var tImportClause = function (node, context) { return renderNodes_1.renderNodes([node.name, node.namedBindings], context).join(''); };
exports.tImportClause = tImportClause;
var tNamedImports = function (node, context) { return renderNodes_1.renderNodes(__spreadArray([], __read(node.elements)), context).join(''); };
exports.tNamedImports = tNamedImports;
