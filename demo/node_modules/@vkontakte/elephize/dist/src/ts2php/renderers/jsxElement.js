"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tJsxElement = void 0;
var ts = require("typescript");
var intrinsicElements_1 = require("../internalConfig/intrinsicElements");
var renderNodes_1 = require("../components/codegen/renderNodes");
function tJsxElement(node, context) {
    var _a;
    // opening element
    var attrs = renderNodes_1.renderNode(node.openingElement.attributes, context);
    // support for dangerouslySetInnerHtml; don't render children if we have some prerendered data for node
    var innerhtml = (_a = context.nodeFlagsStore.get(node.openingElement)) === null || _a === void 0 ? void 0 : _a.prerenderedData;
    context.jsxPush(node.openingElement.tagName.getText());
    // child nodes
    var childrenRendered = innerhtml ?
        innerhtml :
        renderNodes_1.renderNodes(__spreadArray([], __read(node.children)), context);
    context.jsxPop(node.openingElement.tagName.getText());
    var children = childrenRendered && childrenRendered.length ?
        '[' + childrenRendered.join(', ') + ']' :
        '[]';
    if (node.openingElement.tagName.kind !== ts.SyntaxKind.Identifier) {
        context.log.error('Non-identifiers are not supported as jsx elements', [], context.log.ctx(node));
        return 'null';
    }
    if (intrinsicElements_1.intrinsicElements[node.openingElement.tagName.getText()]) {
        return "\\" + context.namespaces.builtins + "\\IntrinsicElement::get(\"" + node.openingElement.tagName.getText().toLowerCase() + "\")->render(" + (attrs || '[]') + ", " + (children || '[]') + ")";
    }
    else {
        var declData = context.scope.findByIdent(node.openingElement.tagName.getText());
        if (!declData) {
            context.log.error('Component identifier not declared: %s', [node.openingElement.tagName.getText()], context.log.ctx(node));
            return 'null';
        }
        var _b = __read(declData, 1), declaration = _b[0];
        var component = void 0;
        if (declaration.flags.External || declaration.flags.DereferencedImport) {
            component = context.registry.getExportedComponent(context.moduleDescriptor, declaration.targetModulePath, node.openingElement.tagName.getText());
        }
        else {
            component = context.registry.getLocalComponent(context.moduleDescriptor, node.openingElement.tagName.getText());
        }
        if (!component) {
            context.log.error('Component not found neither in exports, nor in local scope: %s', [node.openingElement.tagName.getText()], context.log.ctx(node));
            return '';
        }
        return component + "->render(" + (attrs || '[]') + ", " + (children || '[]') + ")";
    }
}
exports.tJsxElement = tJsxElement;
