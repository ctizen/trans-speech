"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tCallExpression = void 0;
var ts = require("typescript");
var stdlib_1 = require("./stdlib");
var ast_1 = require("../utils/ast");
var reactHooks_1 = require("../components/react/reactHooks");
var nodeData_1 = require("../components/unusedCodeElimination/usageGraph/nodeData");
var usageGraph_1 = require("../components/unusedCodeElimination/usageGraph");
var varsUsage_1 = require("../components/unusedCodeElimination/varsUsage");
var node_1 = require("../components/unusedCodeElimination/usageGraph/node");
var renderNodes_1 = require("../components/codegen/renderNodes");
function encloseOptional(expression, node, context) {
    var _a;
    var optionalCondition = (_a = context.nodeFlagsStore.get(node)) === null || _a === void 0 ? void 0 : _a.optionalGuard;
    if (optionalCondition) {
        return optionalCondition + " ? " + expression + " : null";
    }
    return expression;
}
function tCallExpression(node, context) {
    // Support js stdlib objects methods, see stdlibSupport for details
    var hookResult = stdlib_1.hookStdlib(node, context);
    if (hookResult !== undefined) {
        return encloseOptional(hookResult, node, context);
    }
    var reactHooks = reactHooks_1.reactHooksSupport(context, node);
    if (reactHooks) {
        if (reactHooks === '!null') {
            return ''; // drop current statement in this special case
        }
        return reactHooks;
    }
    var ident = renderNodes_1.renderNode(node.expression, context);
    var args;
    var usedVars = new Set();
    var onUsage = function (ident) { return usedVars.add(ident); };
    context.scope.addEventListener(usageGraph_1.Scope.EV_USAGE, onUsage);
    args = renderNodes_1.renderNodes(__spreadArray([], __read(node.arguments)), context);
    context.scope.removeEventListener(usageGraph_1.Scope.EV_USAGE, onUsage);
    // Check for spread in the middle
    var callChildren = node.arguments.slice();
    var spread = callChildren.findIndex(function (v) { return v.kind === ts.SyntaxKind.SpreadElement; });
    if (spread !== -1) {
        if (spread !== callChildren.length - 1) {
            // specific situation: php does not allow spreads in middle of argument list.
            // So we use array_merge + spread. Kphp will not be really happy with it though.
            context.log.warn('Using array_merge to create parameters array for function, it may fail type inference', [], context.log.ctx(node));
            args = ["..." + makeCallArgs(callChildren, args)];
        }
        else {
            // ok, it's last one, so just add ... to spread element.
            args[args.length - 1] = '...' + args[args.length - 1];
        }
    }
    var lExp = ast_1.getLeftExpr(node.expression);
    if (!lExp) {
        context.log.error('Calls of non-identifier expressions are not supported', [], context.log.ctx(node));
        return 'null';
    }
    var _a = __read(context.scope.findByIdent(lExp.getText()) || [], 3), decl = _a[0], declScope = _a[1], declNode = _a[2];
    if (!context.dryRun) {
        if (!decl || (declNode && !node_1.isBound(declNode))) {
            context.log.error('Call of undeclared or dropped identifier: %s', [lExp.getText()], context.log.ctx(node));
        }
    }
    varsUsage_1.markUsedVars(node, lExp, usedVars, context);
    // Similar logic for similar cases, but with slight differences >_<
    if (decl && decl.flags.External) {
        var prop = node.expression.name.getText();
        return context.registry.callExportedCallable(context.moduleDescriptor, decl.targetModulePath, prop, args);
    }
    else if ((decl && decl.flags.DereferencedImport) ||
        (decl && (decl.flags.Local && (nodeData_1.insideComponent(context.scope) || (declScope === null || declScope === void 0 ? void 0 : declScope.isRoot()))))) {
        return context.registry.callExportedCallable(context.moduleDescriptor, decl.targetModulePath, decl.propName, args);
    }
    return encloseOptional(ident + "(" + args.join(', ') + ")", node, context);
}
exports.tCallExpression = tCallExpression;
function makeCallArgs(nodes, args) {
    var toRender = [];
    var synList = [];
    for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].kind === ts.SyntaxKind.SpreadElement) {
            synList = synList.concat('[' + toRender.join(', ') + ']');
            toRender = [];
            synList.push(args[i]);
        }
        else {
            toRender.push(args[i]);
        }
    }
    synList = synList.concat('[' + toRender.join(', ') + ']');
    return "array_merge(" + synList.join(', ') + ")";
}
