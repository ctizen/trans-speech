"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tObjectBindingPattern = exports.renderElements = void 0;
var ts = require("typescript");
var ast_1 = require("../utils/ast");
var isTopLevel_1 = require("../utils/isTopLevel");
var nodeData_1 = require("../components/unusedCodeElimination/usageGraph/nodeData");
var usageGraph_1 = require("../components/unusedCodeElimination/usageGraph");
var renderBindingPatterns_1 = require("../utils/renderBindingPatterns");
var renderNodes_1 = require("../components/codegen/renderNodes");
var basicTypes_1 = require("../components/typeInference/basicTypes");
function renderBindingElement(el, index, destructured, context) {
    if (el.kind === ts.SyntaxKind.OmittedExpression) {
        return null;
    }
    if (!el.dotDotDotToken) {
        destructured.add((el.propertyName || el.name).getText());
    }
    if (!context.dryRun && !context.scope.checkUsage(el.name.getText())) {
        // Remove unused vars declarations
        context.log.info('Dropped unused var $%s from [out]/%s', [el.name.getText(), context.moduleDescriptor.targetFileName]);
        return null;
    }
    if (el.name.kind !== ts.SyntaxKind.Identifier) {
        context.log.error('Nested bindings are not supported: %s', [el.name.getText()], context.log.ctx(el));
        return null;
    }
    if (el.dotDotDotToken) {
        return {
            identifier: el.name,
            defaultValue: '',
            initializer: "Stdlib::objectOmit(%placeholder%, [" + Array.from(destructured.values()).map(function (el) { return "\"" + el + "\""; }).join(', ') + "])",
        };
    }
    else {
        if (el.name.getText() === 'children' && nodeData_1.insideComponent(context.scope)) {
            // We should add declaration to usage graph
            context.scope.addDeclaration('children', [], { dryRun: context.dryRun });
            // But children are passed explicitly as argument to ->render at server, so we don't render them.
            return null;
        }
        return {
            identifier: el.name,
            defaultValue: el.initializer ? ' ?? ' + renderNodes_1.renderNode(el.initializer, context) : '',
            initializer: basicTypes_1.getPossibleCastingType(el.name, context.checker, context.log) + "%placeholder%[\"" + (el.propertyName || el.name).getText() + "\"]",
        };
    }
}
function renderElements(node, placeholder, context) {
    var destructured = new Set();
    var identList = [];
    var els = node.elements.map(function (el, index) { return renderBindingElement(el, index, destructured, context); });
    var renderedString = renderBindingPatterns_1.renderPattern(placeholder, node, els, identList, context);
    return { renderedString: renderedString, identList: identList };
}
exports.renderElements = renderElements;
function tObjectBindingPattern(node, context) {
    var _a, _b;
    var varDecl = node.parent;
    if (varDecl.kind === ts.SyntaxKind.VariableDeclaration) {
        if (((_a = varDecl.initializer) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.Identifier) {
            // Simple identifier, ok
            var init = (_b = varDecl.initializer) === null || _b === void 0 ? void 0 : _b.getText();
            if (init) {
                var _c = __read(context.scope.findByIdent(init) || [], 1), decl = _c[0];
                if (decl && decl.flags.HoistedToModule) {
                    init = 'this->' + init;
                }
            }
            var _d = renderElements(node, init || '[compilation error!]', context), renderedString = _d.renderedString, identList = _d.identList;
            identList.forEach(function (ident) {
                var _a;
                var boundNode = context.scope.addDeclaration(ident.getText(), [(_a = varDecl.initializer) === null || _a === void 0 ? void 0 : _a.getText()], { terminateGlobally: ast_1.isExportedVar(ident), dryRun: context.dryRun });
                if (boundNode) {
                    boundNode.data.flags = isTopLevel_1.isTopLevel(ident, context) ? { HoistedToModule: true } : {};
                }
            });
            return renderedString;
        }
        else {
            // Expression, make dummy var
            var derefIdent_1 = nodeData_1.identifyAnonymousNode(node.parent.initializer);
            var expr = varDecl.initializer;
            var usedIdents_1 = new Set();
            var addIdent = function (ident) { return usedIdents_1.add(ident); };
            context.scope.addEventListener(usageGraph_1.Scope.EV_USAGE, addIdent);
            var assignment = "$" + derefIdent_1 + " = " + renderNodes_1.renderNodes([expr], context) + ";";
            context.scope.removeEventListener(usageGraph_1.Scope.EV_USAGE, addIdent);
            context.scope.addDeclaration(derefIdent_1, Array.from(usedIdents_1), { dryRun: context.dryRun });
            if (isTopLevel_1.isTopLevel(node, context)) {
                // Must add assignment to descriptor before rendering elements to preserve dereferencing order
                context.moduleDescriptor.addStatement(assignment);
            }
            var _e = renderElements(node, derefIdent_1, context), renderedString = _e.renderedString, identList = _e.identList;
            identList.forEach(function (ident) {
                var boundNode = context.scope.addDeclaration(ident.getText(), [derefIdent_1], { terminateGlobally: ast_1.isExportedVar(ident), dryRun: context.dryRun });
                if (boundNode) {
                    boundNode.data.flags = isTopLevel_1.isTopLevel(ident, context) ? { HoistedToModule: true } : {};
                }
            });
            if (isTopLevel_1.isTopLevel(node, context)) {
                return 'null';
            }
            else {
                return assignment + '\n' + renderedString;
            }
        }
    }
    return '';
}
exports.tObjectBindingPattern = tObjectBindingPattern;
