"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tPropertyAccessExpression = void 0;
var ts = require("typescript");
var ast_1 = require("../utils/ast");
var nodeData_1 = require("../components/unusedCodeElimination/usageGraph/nodeData");
var math_1 = require("./stdlib/math");
var renderNodes_1 = require("../components/codegen/renderNodes");
var jsBuiltins_1 = require("../internalConfig/jsBuiltins");
var enumAccess_1 = require("../utils/enumAccess");
function tPropertyAccessExpression(node, context) {
    var _a = __read(renderNodes_1.renderNodes([node.expression, node.name], context), 2), ident = _a[0], accessor = _a[1];
    if (ident === '$exports' && !context.scope.getClosure().has('exports')) {
        context.log.error('You should use `export` instead of `module.exports = `', [], context.log.ctx(node));
        return '';
    }
    var enumAccess = enumAccess_1.handleEnumMemberAccess(node, context);
    if (enumAccess) {
        if (enumAccess === true) { // error: message logged inside access func
            return '';
        }
        return enumAccess; // output handled by access func
    }
    var lExp = ast_1.getLeftExpr(node.expression);
    if (lExp) {
        var _b = __read(context.scope.findByIdent(lExp.getText()) || [], 1), decl = _b[0];
        if (decl && decl.flags.External) {
            return context.registry.getExportedIdentifier(context.moduleDescriptor, decl.targetModulePath, node.name.text);
        }
    }
    if (accessor === 'length' && node.parent.kind !== ts.SyntaxKind.PropertyAccessExpression) {
        var type = context.checker.getTypeAtLocation(node.expression);
        if (type.isStringLiteral() ||
            context.checker.typeToString(type, node.expression, ts.TypeFormatFlags.None) === 'string') {
            if (context.encoding === 'utf-8' || context.encoding === 'UTF-8') {
                return "mb_strlen(" + ident + ", 'UTF-8')";
            }
            else {
                return "strlen(" + ident + ")";
            }
        }
        return "count(" + ident + ")";
    }
    if (ident === '$Math') {
        switch (accessor) {
            case 'E':
            case 'LN2':
            case 'LN10':
            case 'LOG2E':
            case 'LOG10E':
            case 'PI':
            case 'SQRT1_2':
            case 'SQRT2':
                return 'M_' + accessor;
            default:
                if (!math_1.supportedMathMethods.includes(accessor)) {
                    context.log.error('Math: unsupported property (%s)', [accessor], context.log.ctx(node));
                }
                return 'null';
        }
    }
    var isBuiltin = jsBuiltins_1.builtins.has(node.expression.getText());
    if (isBuiltin) {
        return ident + "::" + accessor;
    }
    if (accessor === 'children' && nodeData_1.insideComponent(context.scope)) {
        return '$children';
    }
    var isDirectPropAccess = node.parent.kind !== ts.SyntaxKind.PropertyAccessExpression;
    var isPropCallAccess = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression && node.parent.parent.kind === ts.SyntaxKind.CallExpression) || node.parent.kind === ts.SyntaxKind.CallExpression;
    if (isDirectPropAccess || isPropCallAccess) { // check for optional chaining in top-level expr
        var hasOptionalChaining = false;
        var exprNode = node;
        while (exprNode.kind === ts.SyntaxKind.PropertyAccessExpression) {
            if (exprNode.questionDotToken) {
                hasOptionalChaining = true;
                break;
            }
            exprNode = exprNode.expression;
        }
        if (hasOptionalChaining) {
            if (isPropCallAccess) {
                context.nodeFlagsStore.upsert(node.parent.parent, {
                    optionalGuard: "isset(" + ident + "[\"" + accessor + "\"])",
                });
                return ident + "[\"" + accessor + "\"]";
            }
            return "(isset(" + ident + "[\"" + accessor + "\"]) ? " + ident + "[\"" + accessor + "\"] : null)";
        }
    }
    if (ident === '$this' || context.scope.isClassInstance(node.expression.getText())) {
        return ident + "->" + accessor;
    }
    // Special case for static constants access
    if (node.expression.getText() + 'Class' === context.moduleDescriptor.className) {
        return context.moduleDescriptor.className + "::" + accessor;
    }
    var _c = __read(context.moduleDescriptor.findImportedIdentifier(node.expression.getText()) || [], 2), file = _c[0], classIdent = _c[1];
    if (file && classIdent && context.registry.isPlainClass(file, classIdent)) {
        return context.registry.getPlainClassName(file, classIdent) + "::" + accessor;
    }
    return ident + "[\"" + accessor + "\"]";
}
exports.tPropertyAccessExpression = tPropertyAccessExpression;
