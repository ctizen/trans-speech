"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tVariableDeclaration = void 0;
var ts = require("typescript");
var reactHooks_1 = require("../components/react/reactHooks");
var ast_1 = require("../utils/ast");
var isTopLevel_1 = require("../utils/isTopLevel");
var functionScope_1 = require("../components/functionScope");
var usageGraph_1 = require("../components/unusedCodeElimination/usageGraph");
var pathsAndNames_1 = require("../utils/pathsAndNames");
var renderNodes_1 = require("../components/codegen/renderNodes");
var basicTypes_1 = require("../components/typeInference/basicTypes");
function tVariableDeclaration(node, context) {
    var _a, _b;
    var identifierNode = node.name;
    var initializerNode = node.initializer;
    if (reactHooks_1.checkReactAssignment(node, context)) {
        return '';
    }
    // TODO: don't support `export const { ... } = {}` for now, but maybe later...
    if (node.name.kind === ts.SyntaxKind.ArrayBindingPattern || node.name.kind === ts.SyntaxKind.ObjectBindingPattern) {
        return renderNodes_1.renderNodes([identifierNode], context)[0]; // render only binding form, it will take all names from parent
    }
    var _c = __read(renderNodes_1.renderNodes([identifierNode], context), 1), identifier = _c[0];
    var parentStatement = ast_1.getClosestParentOfType(node, ts.SyntaxKind.VariableStatement);
    var isTop = isTopLevel_1.isTopLevel(node, context);
    var isFuncDeclaration = [ts.SyntaxKind.FunctionExpression, ts.SyntaxKind.ArrowFunction].includes(((_a = node.initializer) === null || _a === void 0 ? void 0 : _a.kind) || 1);
    var usedIdents = new Set();
    var addIdent = function (ident) { return usedIdents.add(ident); };
    context.scope.addEventListener(usageGraph_1.Scope.EV_USAGE, addIdent);
    // Register local vars for use inside non-closure usages, like class methods
    if (parentStatement && isTop) {
        return topStatements(node, initializerNode, addIdent, usedIdents, !!isFuncDeclaration, context);
    }
    // Declaration-only
    if (!node.initializer) { // Single var declaration without initialization
        var decl_1 = context.scope.addDeclaration(node.name.getText(), [], { terminateGlobally: ast_1.isExportedVar(node.name), dryRun: context.dryRun });
        if (decl_1) {
            decl_1.data.targetModulePath = context.moduleDescriptor.targetFileName;
        }
        return "" + identifier;
    }
    // If we reach here, we have full declaration with initializer that's not in top scope.
    var initializer = renderNodes_1.renderNode(initializerNode, context);
    context.scope.removeEventListener(usageGraph_1.Scope.EV_USAGE, addIdent);
    var flags = context.nodeFlagsStore.get(node);
    if (flags === null || flags === void 0 ? void 0 : flags.drop) {
        return (flags === null || flags === void 0 ? void 0 : flags.dropReplacement) || '';
    }
    var decl = null;
    if (!isFuncDeclaration) {
        if (ast_1.isExportedVar(node.name)) {
            context.moduleDescriptor.registerExport(context.moduleDescriptor.sourceFileName, node.name.getText());
        }
        decl = context.scope.addDeclaration(node.name.getText(), [], { terminateGlobally: ast_1.isExportedVar(node.name), dryRun: context.dryRun });
    }
    else {
        var _d = __read(context.scope.findByIdent(node.name.getText()) || [], 2), declScope = _d[1];
        if (declScope) {
            decl = declScope.declarations.get(node.name.getText());
        }
    }
    if (decl) {
        if (isFuncDeclaration) {
            decl.data.flags = __assign(__assign({}, decl.data.flags), { Callable: true });
        }
        decl.data.targetModulePath = context.moduleDescriptor.targetFileName;
    }
    if (!isFuncDeclaration) {
        context.scope.addUsage(node.name.getText(), Array.from(usedIdents), { dryRun: context.dryRun });
    }
    if (!isFuncDeclaration) {
        context.scope.addUsage(node.name.getText(), Array.from(usedIdents), { dryRun: context.dryRun });
    }
    if ((_b = context.nodeFlagsStore.get(node)) === null || _b === void 0 ? void 0 : _b.boundClassInstance) {
        context.scope.addClassInstance(node.name.getText());
    }
    return identifier + " = " + initializer;
}
exports.tVariableDeclaration = tVariableDeclaration;
function topStatements(node, initializerNode, addIdent, usedIdents, isFuncDeclaration, context) {
    var _a, _b;
    if (!node.initializer) {
        context.scope.removeEventListener(usageGraph_1.Scope.EV_USAGE, addIdent);
        context.log.error('Module scope variables should have initializers to ensure proper type detection', [], context.log.ctx(node));
        return 'null';
    }
    // Declaration of arrow func / func expression, NOT CALL
    if (isFuncDeclaration) {
        var expr = node.initializer;
        if (expr) {
            var els = functionScope_1.generateFunctionElements({
                expr: node.initializer,
                nodeIdent: node.name.getText(),
                context: context,
                origDecl: node,
                origStatement: node.initializer,
            });
            // Previous call sets isComponent flag, so it's required for this check to be exactly after generate..()
            if (isTopLevel_1.isTopLevelComponent(expr, context.nodeFlagsStore) || !els) {
                context.scope.removeEventListener(usageGraph_1.Scope.EV_USAGE, addIdent);
                // Don't render component function in current module
                return '';
            }
            var syntaxList = els.syntaxList, block = els.block;
            var flags_1 = context.nodeFlagsStore.get(node);
            var isExportedFuncExp = !!(node.name.kind === ts.SyntaxKind.Identifier && ast_1.isExportedVar(node.name));
            if (!context.dryRun && (context.scope.checkUsage(node.name.getText()) || isExportedFuncExp) && !(flags_1 === null || flags_1 === void 0 ? void 0 : flags_1.drop)) {
                context.moduleDescriptor.addMethod(node.name.getText(), block, syntaxList.join(', '), basicTypes_1.getPhpPrimitiveTypeForFunc(node.initializer, syntaxList, context.checker, context.log), 'public');
            }
        }
    }
    else {
        var _c = __read(renderNodes_1.renderNodes([initializerNode], context), 1), initializer = _c[0];
        var nameIdent = node.name;
        // We expect plain identifier as name here
        if (nameIdent.kind !== ts.SyntaxKind.Identifier) {
            context.log.error('Top-level variable identifier should not be a binding expression', [], context.log.ctx(node));
            context.scope.removeEventListener(usageGraph_1.Scope.EV_USAGE, addIdent);
            return '';
        }
        var ident = pathsAndNames_1.snakify(nameIdent.getText());
        var flags_2 = context.nodeFlagsStore.get(node);
        if (!context.dryRun && context.scope.checkUsage(nameIdent.getText()) && !(flags_2 === null || flags_2 === void 0 ? void 0 : flags_2.drop)) {
            context.moduleDescriptor.addStatement("$this->" + ident + " = " + initializer + ";");
            if ((_a = context.nodeFlagsStore.get(node)) === null || _a === void 0 ? void 0 : _a.boundClassInstance) {
                context.moduleDescriptor.addProperty('$' + ident, ((_b = context.nodeFlagsStore.get(node)) === null || _b === void 0 ? void 0 : _b.boundClassInstance) || 'mixed', 'public');
                context.scope.addClassInstance(nameIdent.getText());
            }
            else {
                context.moduleDescriptor.addProperty('$' + ident, basicTypes_1.getPhpPrimitiveType(nameIdent, context.checker, context.log), 'public');
            }
        }
    }
    var flags = context.nodeFlagsStore.get(node);
    if (flags === null || flags === void 0 ? void 0 : flags.drop) {
        context.scope.removeEventListener(usageGraph_1.Scope.EV_USAGE, addIdent);
        return (flags === null || flags === void 0 ? void 0 : flags.dropReplacement) || '';
    }
    var boundNode = null;
    if (!isFuncDeclaration) {
        boundNode = context.scope.addDeclaration(node.name.getText(), [], { terminateGlobally: ast_1.isExportedVar(node.name), dryRun: context.dryRun });
    }
    else {
        var _d = __read(context.scope.findByIdent(node.name.getText()) || [], 2), declScope = _d[1];
        if (declScope) {
            boundNode = declScope.declarations.get(node.name.getText());
        }
    }
    if (boundNode) {
        if (isFuncDeclaration) {
            boundNode.data.flags = __assign(__assign({}, boundNode.data.flags), { Callable: true });
        }
        boundNode.data.flags = __assign(__assign({}, boundNode.data.flags), { HoistedToModule: true });
        boundNode.data.targetModulePath = context.moduleDescriptor.targetFileName;
        if (ast_1.isExportedVar(node.name)) {
            context.scope.terminateCall(node.name.getText(), { dryRun: context.dryRun });
        }
    }
    context.scope.removeEventListener(usageGraph_1.Scope.EV_USAGE, addIdent);
    if (!isFuncDeclaration) {
        context.scope.addUsage(node.name.getText(), Array.from(usedIdents), { dryRun: context.dryRun });
    }
    return '';
}
