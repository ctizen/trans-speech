"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tBinaryExpression = void 0;
var ts = require("typescript");
var ast_1 = require("../utils/ast");
var usageGraph_1 = require("../components/unusedCodeElimination/usageGraph");
var renderNodes_1 = require("../components/codegen/renderNodes");
var functionScope_1 = require("../components/functionScope");
function tBinaryExpression(node, context) {
    var _a, _b, _c, _d, _e, _f;
    // Support for modification of vars inside closure
    if (node.left.kind === ts.SyntaxKind.Identifier && [
        ts.SyntaxKind.EqualsToken,
        ts.SyntaxKind.PlusEqualsToken,
        ts.SyntaxKind.MinusEqualsToken,
        ts.SyntaxKind.AsteriskEqualsToken,
        ts.SyntaxKind.SlashEqualsToken,
        ts.SyntaxKind.PercentEqualsToken,
        ts.SyntaxKind.BarEqualsToken,
        ts.SyntaxKind.AmpersandEqualsToken,
    ].includes(node.operatorToken.kind)) {
        functionScope_1.checkModificationInNestedScope(node.left, context);
    }
    // Support for modification of properties inside closure
    if ((node.left.kind === ts.SyntaxKind.PropertyAccessExpression || node.left.kind === ts.SyntaxKind.ElementAccessExpression) && [
        ts.SyntaxKind.EqualsToken,
        ts.SyntaxKind.PlusEqualsToken,
        ts.SyntaxKind.MinusEqualsToken,
        ts.SyntaxKind.AsteriskEqualsToken,
        ts.SyntaxKind.SlashEqualsToken,
        ts.SyntaxKind.PercentEqualsToken,
        ts.SyntaxKind.BarEqualsToken,
        ts.SyntaxKind.AmpersandEqualsToken,
    ].includes(node.operatorToken.kind)) {
        functionScope_1.checkModificationInNestedScope(ast_1.getLeftExpr(node.left), context);
    }
    var replaceLiteral = null;
    if (node.operatorToken.kind === ts.SyntaxKind.PlusToken) {
        // php needs . for concatenation so we should check inferred types.
        var typeLeft = context.checker.getTypeAtLocation(node.left);
        var typeRight = context.checker.getTypeAtLocation(node.right);
        if (typeLeft.isStringLiteral() ||
            typeRight.isStringLiteral() ||
            context.checker.typeToString(typeLeft, node.left, ts.TypeFormatFlags.None) === 'string' ||
            context.checker.typeToString(typeRight, node.right, ts.TypeFormatFlags.None) === 'string') {
            replaceLiteral = '.';
        }
    }
    else if (node.operatorToken.kind === ts.SyntaxKind.PlusEqualsToken) {
        // php needs .= for concatenation so we should check inferred types.
        var typeLeft = context.checker.getTypeAtLocation(node.left);
        var typeRight = context.checker.getTypeAtLocation(node.right);
        if (typeLeft.isStringLiteral() ||
            typeRight.isStringLiteral() ||
            context.checker.typeToString(typeLeft, node.left, ts.TypeFormatFlags.None) === 'string' ||
            context.checker.typeToString(typeRight, node.right, ts.TypeFormatFlags.None) === 'string') {
            replaceLiteral = '.=';
        }
    }
    // Support for 'default operator' for simple expressions
    if (node.operatorToken.kind === ts.SyntaxKind.BarBarToken) {
        var typeRight = context.checker.getTypeAtLocation(node.right);
        if (context.checker.typeToString(typeRight, node.right, ts.TypeFormatFlags.None) !== 'boolean') {
            var kind = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.kind;
            if (kind === ts.SyntaxKind.SyntaxList) {
                kind = (_c = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.kind;
            }
            if (kind) {
                var parentIsBinaryExpression = kind === ts.SyntaxKind.BinaryExpression && (node.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken || // const a = b || 'test';
                    node.parent.operatorToken.kind === ts.SyntaxKind.BarBarToken // const a = b || c || d;
                );
                var parentIsOtherSupportedExpressions = [
                    ts.SyntaxKind.VariableDeclaration,
                    ts.SyntaxKind.ParenthesizedExpression,
                    ts.SyntaxKind.JsxExpression,
                    ts.SyntaxKind.CallExpression,
                ].includes(kind);
                if (parentIsBinaryExpression || parentIsOtherSupportedExpressions) {
                    var leftExpr_1 = renderLeftExpr(node, context);
                    var rightExpr_1 = renderRightExpr(node, context);
                    return leftExpr_1 + " ?: " + rightExpr_1;
                }
            }
        }
        // TODO: more specific cases?
        // TODO: describe these cases in documentation
    }
    // Make ternary expression from && operator
    if (node.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {
        var typeRight = context.checker.getTypeAtLocation(node.right);
        if (context.checker.typeToString(typeRight, node.right, ts.TypeFormatFlags.None) !== 'boolean') {
            var kind = (_d = node.parent) === null || _d === void 0 ? void 0 : _d.kind;
            if (kind === ts.SyntaxKind.SyntaxList) {
                kind = (_f = (_e = node.parent) === null || _e === void 0 ? void 0 : _e.parent) === null || _f === void 0 ? void 0 : _f.kind;
            }
            if (kind) {
                if (kind === ts.SyntaxKind.BinaryExpression && node.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken ||
                    [
                        ts.SyntaxKind.VariableDeclaration,
                        ts.SyntaxKind.ParenthesizedExpression,
                        ts.SyntaxKind.JsxExpression,
                        ts.SyntaxKind.CallExpression,
                    ].includes(kind)) {
                    var leftExpr_2 = renderLeftExpr(node, context);
                    var rightExpr_2 = renderRightExpr(node, context);
                    return leftExpr_2 + " ? " + rightExpr_2 + " : " + leftExpr_2;
                }
            }
        }
        // TODO: more specific cases?
        // TODO: describe these cases in documentation
    }
    if (node.operatorToken.kind === ts.SyntaxKind.InKeyword) {
        var leftExpr_3 = renderLeftExpr(node, context);
        var rightExpr_3 = renderRightExpr(node, context);
        return "isset(" + rightExpr_3 + "[" + leftExpr_3 + "])";
    }
    var leftExpr = renderLeftExpr(node, context);
    var operator = renderNodes_1.renderNode(node.operatorToken, context);
    var rightExpr = renderRightExpr(node, context);
    if (replaceLiteral) { // replace + with . for string-based operations
        operator = replaceLiteral;
    }
    var flags = context.nodeFlagsStore.get(node);
    if ((flags === null || flags === void 0 ? void 0 : flags.forceType) && node.left.kind === ts.SyntaxKind.Identifier) {
        var _g = __read(context.scope.findByIdent(node.left.getText()) || [], 1), decl = _g[0];
        if (decl) {
            decl.forcedType = flags.forceType;
        }
    }
    return leftExpr + " " + operator + " " + rightExpr;
}
exports.tBinaryExpression = tBinaryExpression;
function startVarsCollecting(context) {
    var usedVars = new Set();
    var onUsage = function (ident) { return usedVars.add(ident); };
    context.scope.addEventListener(usageGraph_1.Scope.EV_USAGE, onUsage);
    return [usedVars, onUsage];
}
function markVarsUsage(origExpr, usedVars, onUsage, context) {
    var e_1, _a;
    context.scope.removeEventListener(usageGraph_1.Scope.EV_USAGE, onUsage);
    var leftVal = ast_1.getLeftExpr(origExpr.left);
    if (leftVal) {
        try {
            // also connect all used vars to varname node as side-effect usage
            for (var _b = __values(Array.from(usedVars)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ident = _c.value;
                context.scope.terminateCall(ident, { traceSourceIdent: leftVal.getText(), dryRun: context.dryRun });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
}
function renderLeftExpr(origExpr, context) {
    var _a = __read(startVarsCollecting(context), 2), usedVarsLeft = _a[0], onUsageLeft = _a[1];
    var leftExpr = renderNodes_1.renderNode(origExpr.left, context);
    var leftVal = ast_1.getLeftExpr(origExpr.left);
    if (leftVal) {
        usedVarsLeft.delete(leftVal.getText());
    }
    else {
        usedVarsLeft = new Set(); // not identifier-based case; generally unsupported
    }
    markVarsUsage(origExpr, usedVarsLeft, onUsageLeft, context);
    return leftExpr;
}
function renderRightExpr(origExpr, context) {
    var _a = __read(startVarsCollecting(context), 2), usedVarsRight = _a[0], onUsageRight = _a[1];
    var rightExpr = renderNodes_1.renderNode(origExpr.right, context);
    markVarsUsage(origExpr, usedVarsRight, onUsageRight, context);
    return rightExpr;
}
