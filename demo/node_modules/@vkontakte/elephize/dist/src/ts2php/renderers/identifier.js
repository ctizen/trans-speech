"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tIdentifier = void 0;
var ts = require("typescript");
var jsBuiltins_1 = require("../internalConfig/jsBuiltins");
var ast_1 = require("../utils/ast");
var pathsAndNames_1 = require("../utils/pathsAndNames");
var nodeData_1 = require("../components/unusedCodeElimination/usageGraph/nodeData");
var basicTypes_1 = require("../components/typeInference/basicTypes");
function tIdentifier(node, context) {
    var _a;
    var builtin = node.escapedText && jsBuiltins_1.builtins.has(node.escapedText.toString());
    var isCallableIdent = node.parent.kind === ts.SyntaxKind.CallExpression && node.parent.expression === node;
    if (builtin) {
        if (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression && node.parent.expression === node ||
            isCallableIdent) {
            if (node.escapedText === 'console') {
                return "\\" + context.namespaces.builtins + "\\Console"; // to make more consistent classes on server side
            }
            return "\\" + context.namespaces.builtins + "\\" + node.escapedText;
        }
    }
    // Warn user for wrong usage of special variable
    if (context.dryRun && node.escapedText === 'window' && node.parent.getText() === 'window._elephizeIsServer') {
        context.log.error('Special variable \'window._elephizeIsServer\' should be used in ternary conditions only!', [], context.log.ctx(node));
    }
    var _b = __read(context.scope.findByIdent(node.escapedText.toString()) || [], 1), decl = _b[0];
    if (decl && decl.flags.DereferencedImport) {
        if (!decl.targetModulePath) {
            // This condition is to prevent errors while importing types from external modules.
            // It's fine to import type/interface identifiers without any checks, if they're used only in type expressions.
            // It might be difficult to debug import failures, though, we consider it typescript compiler/checker business.
            return 'null';
        }
        return basicTypes_1.typeCast(node) + context.registry.getExportedIdentifier(context.moduleDescriptor, decl.targetModulePath, decl.propName || node.escapedText.toString(), !isCallableIdent);
    }
    if (node.escapedText.toString() === 'undefined' || node.escapedText.toString() === 'null') {
        return 'null';
    }
    // Mark require expressions to process them in CallExpression visitor
    if (node.escapedText.toString() === 'require') {
        context.log.error('You should use `import` instead of `require`', [], context.log.ctx(node));
        return 'null';
    }
    if ( // assignment inside object literal
    node.parent.kind === ts.SyntaxKind.PropertyAssignment && node.parent.name === node) {
        return node.escapedText.toString();
    }
    if ( // shorthand assignment inside object literal; should append usage case!
    node.parent.kind === ts.SyntaxKind.ShorthandPropertyAssignment && node.parent.name === node) {
        context.scope.addUsage(node.getText(), [], { dryRun: context.dryRun });
        return node.escapedText.toString();
    }
    if (decl && decl.flags.HoistedToModule) {
        if (nodeData_1.insideComponent(context.scope)) {
            context.scope.addUsage(decl.propName || node.escapedText.toString(), [], { dryRun: context.dryRun });
            return context.registry.getExportedIdentifier(context.moduleDescriptor, ((_a = context.moduleDescriptor.ancestorModule) === null || _a === void 0 ? void 0 : _a.targetFileName) || context.moduleDescriptor.targetFileName, decl.propName || node.escapedText.toString(), !isCallableIdent);
        }
        if (isCallableIdent) {
            return basicTypes_1.typeCast(node) + ("$this->" + (decl.propName || node.escapedText.toString()));
        }
        var varName = decl.propName || node.escapedText.toString();
        context.scope.addUsage(node.getText(), [], { dryRun: context.dryRun });
        return basicTypes_1.typeCast(node) + ("$this->" + pathsAndNames_1.snakify(varName));
    }
    if (isCallableIdent || // called func name
        node.parent.kind === ts.SyntaxKind.FunctionDeclaration // declared func name
    ) {
        // if it's function call, don't add to closure and just return the identifier
        return basicTypes_1.typeCast(node) + ("$" + pathsAndNames_1.snakify((decl === null || decl === void 0 ? void 0 : decl.propName) || node.escapedText.toString()));
    }
    if (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression) {
        if (node.parent.expression !== node) {
            // For all other parts of property access expression we don't add contexts and don't add $ in beginning.
            return node.escapedText.toString();
        }
    }
    var isDeclaration = node.parent.kind === ts.SyntaxKind.VariableDeclaration && node.parent.name === node;
    if (!context.dryRun && isDeclaration && !context.scope.checkUsage(node.getText())) {
        // Remove unused vars declarations
        context.log.info('Dropped unused var $%s from [out]/%s', [node.escapedText.toString(), context.moduleDescriptor.targetFileName], context.log.ctx(node));
        ast_1.flagParentOfType(node, [ts.SyntaxKind.VariableDeclaration], { drop: true }, context.nodeFlagsStore);
    }
    if (!isDeclaration) {
        context.scope.addUsage(node.getText(), [], { dryRun: context.dryRun });
    }
    return basicTypes_1.typeCast(node) + ("$" + pathsAndNames_1.snakify(node.escapedText.toString()));
}
exports.tIdentifier = tIdentifier;
