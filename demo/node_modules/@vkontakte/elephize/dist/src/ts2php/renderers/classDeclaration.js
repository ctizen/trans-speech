"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tClassDeclaration = void 0;
var ts = require("typescript");
var renderNodes_1 = require("../components/codegen/renderNodes");
var pathsAndNames_1 = require("../utils/pathsAndNames");
var basicTypes_1 = require("../components/typeInference/basicTypes");
var tClassDeclaration = function (node, context) {
    var _a;
    var name = (_a = node.name) === null || _a === void 0 ? void 0 : _a.escapedText.toString();
    if (!name) {
        throw new Error();
    }
    context.scope.addDeclaration(name, [], { dryRun: context.dryRun });
    var descriptor = context.registry.derivePlainClass(name, context.moduleDescriptor);
    if (!descriptor) {
        return '';
    }
    node.members.forEach(function (member) {
        var e_1, _a, e_2, _b;
        if (ts.isPropertyDeclaration(member)) {
            var mod = 'public';
            var isStatic = false;
            var isReadonly = false;
            try {
                for (var _c = __values(member.modifiers || []), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var i = _d.value;
                    if (i.kind === ts.SyntaxKind.PrivateKeyword) {
                        mod = 'private';
                    }
                    else if (i.kind === ts.SyntaxKind.ProtectedKeyword) {
                        mod = 'protected';
                    }
                    else if (i.kind === ts.SyntaxKind.StaticKeyword) {
                        isStatic = true;
                    }
                    else if (i.kind === ts.SyntaxKind.ReadonlyKeyword) {
                        isReadonly = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (isStatic !== isReadonly) {
                throw new Error('Only static AND readonly fields are supported');
            }
            if (isStatic && isReadonly) {
                descriptor === null || descriptor === void 0 ? void 0 : descriptor.addStaticConst(member.name.getText(), renderNodes_1.renderNode(member.initializer, context), basicTypes_1.getPhpPrimitiveType(member.initializer, context.checker, context.log));
            }
            else {
                descriptor === null || descriptor === void 0 ? void 0 : descriptor.addProperty(renderNodes_1.renderNode(member.name, context), basicTypes_1.getPhpPrimitiveType(member.initializer, context.checker, context.log), mod);
            }
        }
        if (ts.isMethodDeclaration(member)) {
            var mod = 'public';
            try {
                for (var _e = __values(member.modifiers || []), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var i = _f.value;
                    if (i.kind === ts.SyntaxKind.PrivateKeyword) {
                        mod = 'private';
                    }
                    else if (i.kind === ts.SyntaxKind.ProtectedKeyword) {
                        mod = 'protected';
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var previousDescriptor = context.moduleDescriptor;
            context.moduleDescriptor = descriptor;
            var expr = renderNodes_1.renderNode(member.body, context);
            var args = renderNodes_1.renderNodes(member.parameters.slice(), context);
            context.moduleDescriptor = previousDescriptor;
            descriptor === null || descriptor === void 0 ? void 0 : descriptor.addMethod(pathsAndNames_1.snakify(member.name.getText()), expr, args.join(', '), basicTypes_1.getPhpPrimitiveTypeForFunc(member, args, context.checker, context.log), mod);
        }
    });
    return '';
};
exports.tClassDeclaration = tClassDeclaration;
