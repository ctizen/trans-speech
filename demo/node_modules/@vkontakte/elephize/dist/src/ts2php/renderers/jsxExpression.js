"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tJsxExpression = void 0;
var ts = require("typescript");
var renderNodes_1 = require("../components/codegen/renderNodes");
var escapeString_1 = require("../utils/escapeString");
var ast_1 = require("../utils/ast");
var intrinsicElements_1 = require("../internalConfig/intrinsicElements");
var basicTypes_1 = require("../components/typeInference/basicTypes");
var tJsxExpression = function (node, context) {
    var _a;
    // We should add forced escaping only in intrinsic elements attributes and direct children
    var tag = ast_1.getClosestParentOfAnyType(node, [ts.SyntaxKind.JsxSelfClosingElement, ts.SyntaxKind.JsxOpeningElement]);
    var tagName = (tag === null || tag === void 0 ? void 0 : tag.tagName.getText()) || context.jsxPeak(); // Don't do toLowerCase here, or custom module names may interfere with intrinsic tag names.
    if (tagName && intrinsicElements_1.intrinsicElements[tagName]) {
        if (node.parent.kind === ts.SyntaxKind.JsxAttribute && ((_a = node.expression) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.StringLiteral) {
            return "\\" + context.namespaces.builtins + "\\IntrinsicElement::escape(" + escapeString_1.escapeExprLiteral(node.expression.text) + ')';
        }
        if (shouldEscape(node.expression, context)) {
            return "\\" + context.namespaces.builtins + "\\IntrinsicElement::escape(" + renderNodes_1.renderNode(node.expression, context) + ')';
        }
    }
    // Just render nodes for all other components
    return renderNodes_1.renderNode(node.expression, context);
};
exports.tJsxExpression = tJsxExpression;
// Check if jsx expression should be html-escaped while rendering on server side
function shouldEscape(node, context) {
    if (!node) {
        return false;
    }
    if (ts.isLiteralExpression(node) || ts.isNumericLiteral(node) || ts.isStringLiteral(node)) {
        return false;
    }
    if (node.kind === ts.SyntaxKind.TrueKeyword || node.kind === ts.SyntaxKind.FalseKeyword) {
        return false;
    }
    if (node.kind === ts.SyntaxKind.CallExpression) {
        var sig = context.checker.getResolvedSignature(node);
        if (sig) {
            var retType = context.checker.getReturnTypeOfSignature(sig);
            if (!checkExprType(retType, context.checker)) {
                return false;
            }
        }
    }
    // Don't escape style or allowed listeners attributes, it's safety should be checked by client
    if (node.parent.parent.kind === ts.SyntaxKind.JsxAttribute) {
        var jsxAttrName = node.parent.parent.name.getText();
        if (jsxAttrName === 'style') {
            return false;
        }
        if (jsxAttrName.startsWith('on')) {
            return false;
        }
    }
    // Workaround. Escape children only it's a string or a string array. TODO: Add more precise check somehow
    if (node.getText() === 'children') {
        if (basicTypes_1.hasType(node, context.checker, 'string') || basicTypes_1.hasType(node, context.checker, 'string[]')) {
            return true;
        }
    }
    // Finally, check expressions and identifiers
    var nodeType = context.checker.getTypeAtLocation(node);
    if (!checkExprType(nodeType, context.checker)) {
        return false;
    }
    return true;
}
function checkExprType(type, checker) {
    var _a, _b, _c;
    var typeSymbol;
    if (((_a = type === null || type === void 0 ? void 0 : type.getSymbol()) === null || _a === void 0 ? void 0 : _a.escapedName) === 'Array') {
        var typeArg = checker.getTypeArguments(type /* <- may be incorrect! */)[0];
        typeSymbol = typeArg.getSymbol() || typeArg.aliasSymbol;
    }
    else {
        typeSymbol = (type === null || type === void 0 ? void 0 : type.getSymbol()) || (type === null || type === void 0 ? void 0 : type.aliasSymbol);
        if (!typeSymbol && type) { // try getting apparent type
            typeSymbol = (_b = checker.getApparentType(type)) === null || _b === void 0 ? void 0 : _b.getSymbol();
        }
    }
    if ((typeSymbol === null || typeSymbol === void 0 ? void 0 : typeSymbol.escapedName) === 'Number' || (typeSymbol === null || typeSymbol === void 0 ? void 0 : typeSymbol.escapedName) === 'Boolean') {
        return false; // Do not escape simple types
    }
    if (!typeSymbol && type && checker.typeToString(type) === 'any') {
        return false; // Do not escape any type: component can pass here
    }
    var parentSymbol = (_c = typeSymbol) === null || _c === void 0 ? void 0 : _c.parent;
    if ((parentSymbol === null || parentSymbol === void 0 ? void 0 : parentSymbol.escapedName) === 'JSX' && (typeSymbol === null || typeSymbol === void 0 ? void 0 : typeSymbol.escapedName) === 'Element') {
        return false; // Do not escape components and intrinsic tags
    }
    if ((parentSymbol === null || parentSymbol === void 0 ? void 0 : parentSymbol.escapedName) === 'React' && ((typeSymbol === null || typeSymbol === void 0 ? void 0 : typeSymbol.escapedName) === 'ReactNode' || (typeSymbol === null || typeSymbol === void 0 ? void 0 : typeSymbol.escapedName) === 'ReactElement')) {
        return false;
    }
    return true;
}
