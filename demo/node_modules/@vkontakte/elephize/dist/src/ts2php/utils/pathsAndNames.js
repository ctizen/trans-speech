"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAliasesAndPaths = exports.classNameFromPath = exports.capitalize = exports.normalizeBasePath = exports.escapeKeyword = exports.normalizeFileExt = exports.normalizeVarName = exports.snakify = exports.camelize = void 0;
var nodePath = require("path");
var fs = require("fs");
var PHP_KEYWORDS = [
    '__halt_compiler', 'abstract', 'and', 'array', 'as', 'break', 'callable', 'case', 'catch', 'class',
    'clone', 'const', 'continue', 'declare', 'default', 'die', 'do', 'echo', 'else', 'elseif', 'empty',
    'enddeclare', 'endfor', 'endforeach', 'endif', 'endswitch', 'endwhile', 'eval', 'exit', 'extends',
    'final', 'for', 'foreach', 'function', 'global', 'goto', 'if', 'implements', 'include', 'include_once',
    'instanceof', 'insteadof', 'interface', 'isset', 'list', 'namespace', 'new', 'or', 'print', 'private',
    'protected', 'public', 'require', 'require_once', 'return', 'static', 'switch', 'throw', 'trait', 'try',
    'unset', 'use', 'var', 'while', 'xor',
];
function camelize(ident) {
    return ident.replace(/([a-z])_([a-z])/g, function (substring, let1, let2) { return "" + let1 + let2.toUpperCase(); });
}
exports.camelize = camelize;
function snakify(ident) {
    return ident.replace(/([a-z])([A-Z])/g, function (substring, let1, let2) { return let1 + "_" + let2.toLowerCase(); });
}
exports.snakify = snakify;
function normalizeVarName(ident) {
    return ident.startsWith('$') ? camelize(ident.substr(1)) : ident;
}
exports.normalizeVarName = normalizeVarName;
function normalizeFileExt(filename, replaceWith) {
    if (replaceWith === void 0) { replaceWith = '.php'; }
    return filename.replace(/(\.php)?\.(ts|tsx|js|jsx)$/g, replaceWith);
}
exports.normalizeFileExt = normalizeFileExt;
function escapeKeyword(s) {
    var keywordIndex = PHP_KEYWORDS.indexOf(s.toLowerCase());
    if (keywordIndex === -1) {
        return s;
    }
    return "elephize_" + s;
}
exports.escapeKeyword = escapeKeyword;
/**
 * Output: no leading slash!
 *
 * @param filename
 * @param baseDir
 * @param aliases
 */
function normalizeBasePath(filename, baseDir, aliases) {
    var nrm = filename
        .replace(new RegExp('^' + baseDir), '')
        .replace(/^\/+/, '');
    if (aliases) {
        for (var path in aliases) {
            if (!aliases.hasOwnProperty(path)) {
                continue;
            }
            var alias = aliases[path];
            path = path.replace(/^\/+/, '');
            if (nrm.startsWith(path)) {
                return nrm.replace(path, alias.replace(/^\/+/, ''));
            }
        }
    }
    return nrm;
}
exports.normalizeBasePath = normalizeBasePath;
function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}
exports.capitalize = capitalize;
function classNameFromPath(normalizedPath, external) {
    var _a;
    if (external === void 0) { external = false; }
    var pieces = normalizedPath.split('/');
    var fn = capitalize(((_a = pieces.pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0]) || '');
    if (fn === 'Index') {
        fn = capitalize(pieces.pop() || fn);
    }
    return fn.replace(/\./g, '_') + (external ? 'CjsWrapper' : 'Module');
}
exports.classNameFromPath = classNameFromPath;
function resolveAliasesAndPaths(log, originalSourcePath, currentDir, baseDir, tsPaths, outputAliases, skipOutputAliases) {
    originalSourcePath = originalSourcePath.replace(/\.[jt]sx?$/, '');
    var _loop_1 = function (pathOrig) {
        if (!tsPaths.hasOwnProperty(pathOrig)) {
            return "continue";
        }
        if (pathOrig === '*') {
            throw new Error('Asterisk-only aliases are not supported');
        }
        var pathToTry = pathOrig.replace(/\*$/g, '');
        if (originalSourcePath.startsWith(pathToTry)) {
            log.info('Trying paths for location: %s', [pathToTry]);
            return { value: applyOutputAliases(tsPaths[pathOrig].reduce(function (acc, name) {
                    if (acc) {
                        return acc;
                    }
                    var target = originalSourcePath.replace(pathToTry, name.replace(/\*$/g, ''));
                    var tPath = target.startsWith('/') ?
                        target : // absolute path, no need to resolve
                        nodePath.resolve(baseDir, target);
                    log.info('Trying to locate file: %s', [tPath]);
                    var fn = lookupFile(tPath);
                    if (fs.existsSync(tPath) && fs.lstatSync(tPath).isDirectory) {
                        var tIndexPath = nodePath.join(tPath, 'index');
                        log.info('Trying to locate index file: %s', [tIndexPath]);
                        var fnIndex = lookupFile(tIndexPath);
                        if (fnIndex) {
                            if (fn) {
                                log.warn('Found both directory and file with the same basename. It may cause problems: %s', [fnIndex]);
                            }
                            return fnIndex;
                        }
                    }
                    if (fn) {
                        return fn;
                    }
                    return undefined;
                }, undefined), baseDir, outputAliases, skipOutputAliases) };
        }
    };
    for (var pathOrig in tsPaths) {
        var state_1 = _loop_1(pathOrig);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    var tPath = nodePath.resolve(currentDir, originalSourcePath);
    log.info('Trying non-aliased path: %s', [tPath.replace(baseDir, '[base]')]);
    var fn = lookupFile(tPath);
    if (fs.existsSync(tPath) && fs.lstatSync(tPath).isDirectory) {
        var tIndexPath = nodePath.join(tPath, 'index');
        log.info('Trying non-aliased index path: %s', [tIndexPath]);
        var fnIndex = lookupFile(tIndexPath);
        if (fnIndex) {
            if (fn) {
                log.warn('Found both directory and file with the same basename. It may cause problems: %s', [fnIndex]);
            }
            return applyOutputAliases(fnIndex, baseDir, outputAliases, skipOutputAliases);
        }
    }
    return applyOutputAliases(fn, baseDir, outputAliases, skipOutputAliases);
}
exports.resolveAliasesAndPaths = resolveAliasesAndPaths;
function applyOutputAliases(path, baseDir, outputAliases, skip) {
    if (path === void 0) { path = ''; }
    if (!path) {
        return '';
    }
    if (skip) {
        return path;
    }
    return baseDir + Object.keys(outputAliases).reduce(function (acc, aliasKey) {
        if (acc.startsWith(aliasKey)) {
            return acc.replace(aliasKey, outputAliases[aliasKey]);
        }
        return acc;
    }, path.replace(baseDir, ''));
}
function lookupFile(path) {
    return [
        path + '.js',
        path + '.jsx',
        path + '.ts',
        path + '.tsx',
    ].reduce(function (acc, name) {
        if (acc) {
            return acc;
        }
        if (fs.existsSync(name)) {
            return name;
        }
        return undefined;
    }, undefined);
}
