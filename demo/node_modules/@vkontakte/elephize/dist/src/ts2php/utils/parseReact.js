"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var fs = require("fs");
var path = require("path");
function generateDocumentation(fileNames, options) {
    var e_1, _a;
    // Build a program using the set of root file names in fileNames
    var program = ts.createProgram(fileNames, options);
    // Get the checker, we will use it to find more about classes
    var checker = program.getTypeChecker();
    var result = {
        tags: [],
        attrs: [],
    };
    try {
        // Visit every sourceFile in the program
        for (var _b = __values(program.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var sourceFile = _c.value;
            if (sourceFile.isDeclarationFile) {
                ts.forEachChild(sourceFile, visit);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // print out the doc
    fs.writeFileSync(path.resolve(__dirname, '..', '..', '..', 'data', 'intrinsicElements.json'), JSON.stringify(result.tags, undefined, 4));
    fs.writeFileSync(path.resolve(__dirname, '..', '..', '..', 'data', 'domattrs.json'), JSON.stringify(result.attrs, undefined, 4));
    return;
    function visit(node) {
        if (ts.isModuleDeclaration(node)) {
            var symbol = checker.getSymbolAtLocation(node.name);
            if (symbol) {
                if (symbol.getName() === 'React') {
                    ts.forEachChild(node, visit);
                }
            }
        }
        else if (ts.isInterfaceDeclaration(node) && node.name) {
            // This is a top level class, get its symbol
            var symbol = checker.getSymbolAtLocation(node.name);
            if (symbol) {
                if (symbol.getName() === 'ReactDOM') { // Found root element for internal html elements!
                    result.tags = getElements(checker.getTypeAtLocation(node), checker);
                }
                if (symbol.getName() === 'DOMAttributes') { // Found root element for internal html elements!
                    result.attrs = getCallbackAttrs(checker.getTypeAtLocation(node));
                }
            }
        }
        else {
            ts.forEachChild(node, visit);
        }
    }
}
function getCallbackAttrs(interfaceType) {
    var attrs = interfaceType.getApparentProperties();
    return attrs.map(function (symbol) { return symbol.getName(); }).filter(function (name) { return name.startsWith('on'); });
}
function getElements(interfaceType, checker) {
    var intrinsicTags = interfaceType.getApparentProperties();
    return intrinsicTags.map(function (symbol) {
        var symType = checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
        var memberProps = [];
        var inheritedProps = [];
        if (symType.resolvedTypeArguments && symType.resolvedTypeArguments[0]) {
            // member props
            symType.resolvedTypeArguments[0].symbol.members.forEach(function (val) { return memberProps.push(val); });
            // inferred props
            var attrsSym = symType.resolvedTypeArguments[0].symbol;
            var attrSymDecl = attrsSym.declarations[0].heritageClauses[0].types[0].expression;
            inheritedProps = checker.getTypeAtLocation(attrSymDecl).getApparentProperties();
        }
        return {
            'tagName': symbol.escapedName,
            'props': __spreadArray(__spreadArray(__spreadArray([], __read(inheritedProps)), __read(memberProps)), __read(symType.getApparentProperties())).map(function (s) { return s.escapedName; }).sort(),
        };
    });
}
generateDocumentation(['./node_modules/@types/react/index.d.ts'], {
    target: ts.ScriptTarget.ES5,
    module: ts.ModuleKind.CommonJS,
});
