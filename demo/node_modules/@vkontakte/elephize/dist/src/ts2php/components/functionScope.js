"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkModificationInNestedScope = exports.functionExpressionGen = exports.unwrapArrowBody = exports.prependDefaultParams = exports.prependDestructuredParams = exports.genClosure = exports.generateFunctionElements = exports.getRenderedBlock = void 0;
var ts = require("typescript");
var ast_1 = require("../utils/ast");
var reactComponents_1 = require("./react/reactComponents");
var renderNodes_1 = require("./codegen/renderNodes");
var nodeData_1 = require("./unusedCodeElimination/usageGraph/nodeData");
var hrtime_1 = require("../utils/hrtime");
var pathsAndNames_1 = require("../utils/pathsAndNames");
function getRenderedBlock(context, nodeIdent, realParent, argSynList, bodyBlock // can be many types in arrow func
) {
    var node;
    var _a = __read(context.scope.findByIdent(nodeIdent) || [], 2), declScope = _a[1];
    if (declScope) {
        node = declScope.declarations.get(nodeIdent);
    }
    if (!node) {
        context.scope.addDeclaration(nodeIdent, [], { dryRun: context.dryRun });
    }
    var stackCtr = hrtime_1.getTimeMarker();
    context.pushScope("function__" + stackCtr, nodeIdent);
    // Declare all parameters
    argSynList.map(ast_1.fetchAllBindingIdents)
        .reduce(function (acc, val) { return acc.concat(val); }, []) // flatten;
        .forEach(function (ident) {
        context.scope.addDeclaration(ident.getText(), [], { terminateLocally: true, dryRun: context.dryRun });
    });
    if (realParent) {
        context.nodeFlagsStore.upsert(realParent, { destructuringInfo: { vars: '' } });
    }
    var _b = __read(renderNodes_1.renderNodes(__spreadArray([], __read(argSynList)), context, false)), syntaxList = _b.slice(0);
    var block = renderNodes_1.renderNode(bodyBlock, context);
    var idMap = new Map();
    context.scope.getClosure().forEach(function (decl, ident) {
        if ((decl.flags.External) && decl.propName === '*') {
            return; // imported vars should not get into closure
        }
        if (!!(decl.flags.HoistedToModule)) {
            return; // module scope vars also should not get into closure
        }
        idMap.set(ident, !!(decl.flags.ModifiedInLowerScope));
    });
    context.popScope("function__" + stackCtr, bodyBlock === null || bodyBlock === void 0 ? void 0 : bodyBlock.getLastToken());
    return { syntaxList: syntaxList, block: block, idMap: idMap };
}
exports.getRenderedBlock = getRenderedBlock;
function generateFunctionElements(_a) {
    var expr = _a.expr, nodeIdent = _a.nodeIdent, context = _a.context, origDecl = _a.origDecl, origStatement = _a.origStatement;
    if (origDecl && origStatement) {
        var parentStmt = ast_1.getClosestOrigParentOfType(origDecl, ts.SyntaxKind.VariableStatement);
        if (parentStmt) {
            var handledContent = reactComponents_1.handleComponent(context, origStatement);
            if (handledContent) {
                return null; // component is written to different file, so we should not output anything here
            }
        }
    }
    var params = expr.parameters;
    var blockNode = expr.body;
    var _b = getRenderedBlock(context, nodeIdent, origStatement, params, blockNode), syntaxList = _b.syntaxList, block = _b.block;
    block = unwrapArrowBody(block, blockNode);
    block = prependDestructuredParams(block, expr, context);
    block = prependDefaultParams(block, expr, context);
    return { syntaxList: syntaxList, block: block };
}
exports.generateFunctionElements = generateFunctionElements;
function genClosure(idMap, context, node) {
    var closureUse = [];
    idMap.forEach(function (modifiedInClosure, varName) {
        if (modifiedInClosure) {
            context.log.error('Closure-scoped variable %s has been modified inside closure, this will not work on server side', [varName], context.log.ctx(node));
            closureUse.push("/* !! MODIFIED INSIDE !! */$" + pathsAndNames_1.snakify(varName));
        }
        else {
            closureUse.push("$" + pathsAndNames_1.snakify(varName));
        }
        // Reset closure modification flag for all closure vars: they can be used in next closures without modification, and it's ok
        var _a = __read(context.scope.findByIdent(varName) || [], 1), decl = _a[0];
        if (decl) {
            decl.flags = __assign(__assign({}, decl.flags), { ModifiedInLowerScope: false });
        }
    });
    var closureExpr = closureUse.length > 0 ?
        " use (" + closureUse.join(', ') + ")" :
        '';
    return { closureExpr: closureExpr };
}
exports.genClosure = genClosure;
function prependDestructuredParams(block, func, context) {
    var _a;
    var flags = context.nodeFlagsStore.get(func);
    if (!((_a = flags === null || flags === void 0 ? void 0 : flags.destructuringInfo) === null || _a === void 0 ? void 0 : _a.vars)) {
        return block;
    }
    return block.replace(/^{/, '{\n' + flags.destructuringInfo.vars);
}
exports.prependDestructuredParams = prependDestructuredParams;
function prependDefaultParams(block, func, context) {
    var flags = context.nodeFlagsStore.get(func);
    if (!(flags === null || flags === void 0 ? void 0 : flags.optionalParamsWithDefaults)) {
        return block;
    }
    return block.replace(/^{/, '{\n' + flags.optionalParamsWithDefaults.join('\n'));
}
exports.prependDefaultParams = prependDefaultParams;
function unwrapArrowBody(block, blockNode, noReturn) {
    if (noReturn === void 0) { noReturn = false; }
    if ((blockNode === null || blockNode === void 0 ? void 0 : blockNode.kind) !== ts.SyntaxKind.Block) {
        return noReturn ? "{\n" + block + ";\n}" : "{\nreturn " + block + ";\n}";
    }
    return block;
}
exports.unwrapArrowBody = unwrapArrowBody;
var functionExpressionGen = function (node, ident) { return function (opts, context) {
    var _a = getRenderedBlock(context, ident, node, opts.synList, opts.blockNode), syntaxList = _a.syntaxList, block = _a.block, idMap = _a.idMap;
    block = unwrapArrowBody(block, opts.blockNode);
    block = prependDestructuredParams(block, node, context);
    block = prependDefaultParams(block, node, context);
    var closureExpr = genClosure(idMap, context, node).closureExpr;
    return "/* " + ident + " */ function (" + syntaxList + ")" + closureExpr + " " + block;
}; };
exports.functionExpressionGen = functionExpressionGen;
/**
 * If node value looks like modified in current context, add declaration flag.
 * Return declaration.
 * @param node
 * @param context
 * @return Declaration
 */
function checkModificationInNestedScope(node, context) {
    if (!node) {
        return null;
    }
    var nodeText = node.escapedText.toString();
    var _a = __read(context.scope.findByIdent(nodeText) || [], 2), decl = _a[0], declScope = _a[1];
    if (decl && declScope) {
        var modifiedInLowerScope = nodeData_1.usedInNestedScope(decl, declScope, context.scope);
        if (modifiedInLowerScope && decl) {
            decl.flags = __assign(__assign({}, decl.flags), { ModifiedInLowerScope: true });
        }
        return decl;
    }
    return null;
}
exports.checkModificationInNestedScope = checkModificationInNestedScope;
