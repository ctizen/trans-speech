"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
var Context = /** @class */ (function () {
    function Context(_scope, checker, nodeFlagsStore, compilerOptions, moduleDescriptor, dryRun, baseDir, namespaces, encoding, registry, log, builtinsNs, jsxPreferences, nodeHooks) {
        if (nodeHooks === void 0) { nodeHooks = {}; }
        this._scope = _scope;
        this.checker = checker;
        this.nodeFlagsStore = nodeFlagsStore;
        this.compilerOptions = compilerOptions;
        this.moduleDescriptor = moduleDescriptor;
        this.dryRun = dryRun;
        this.baseDir = baseDir;
        this.namespaces = namespaces;
        this.encoding = encoding;
        this.registry = registry;
        this.log = log;
        this.builtinsNs = builtinsNs;
        this.jsxPreferences = jsxPreferences;
        this.nodeHooks = nodeHooks;
        this._jsxTagStack = [];
        this._uniqIdStack = [];
    }
    Object.defineProperty(Context.prototype, "scope", {
        get: function () {
            return this._scope;
        },
        enumerable: false,
        configurable: true
    });
    Context.prototype.jsxPush = function (tag) {
        this._jsxTagStack.push(tag);
    };
    Context.prototype.jsxPop = function (tag) {
        var popped = this._jsxTagStack.pop();
        if (popped !== tag) {
            this.log.warn('Tried to pop %s out of jsx tag stack, but found %s. This is probably error in compiler.', [tag, popped || '""']);
        }
    };
    Context.prototype.jsxPeak = function () {
        return this._jsxTagStack[this._jsxTagStack.length - 1] || null;
    };
    Context.prototype.pushScope = function (uniqid, ownerIdent) {
        // log.INFO('Push scope w/' + ownerIdent + ' / ' + uniqid)
        this._uniqIdStack.push(uniqid);
        var node = this._scope.declarations.get(ownerIdent);
        if (node && node.ownedScope && this.dryRun) {
            this.log.error('Reassignment of functional scopes is not supported: %s', [ownerIdent], this.log.shortCtx(this.moduleDescriptor.sourceFileName));
        }
        if (!node || node.homeScope !== this._scope) {
            this.log.warn('Failed to push scope into stack, this may lead to errors; (%s / %s)', [ownerIdent, uniqid]);
            return;
        }
        this._scope = node.spawnScope(this.moduleDescriptor.sourceFileName, this.dryRun);
    };
    Context.prototype.popScope = function (uniqid, context) {
        // log.INFO('Pop scope / ' + uniqid)
        if (uniqid !== this._uniqIdStack[this._uniqIdStack.length - 1]) {
            throw new Error('Attempt to pop frame that is not on top of stack: this should not happen and probably is a bug in transpiler \n' + this.log.ctx(context));
        }
        this._uniqIdStack.pop();
        if (!this._scope.parentScope) {
            throw new Error('Call stack got out of bounds: this should not happen and probably is a bug in transpiler \n' + this.log.ctx(context));
        }
        this._scope = this._scope.parentScope;
    };
    return Context;
}());
exports.Context = Context;
