"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scope = void 0;
var node_1 = require("./node");
var log_1 = require("../../../utils/log");
var Scope = /** @class */ (function () {
    function Scope(
    /**
     * Path to processed source file (mainly for logging and debug purposes)
     */
    sourceFile, 
    /**
     * Default custom data for declarations (aka graph nodes)
     */
    nodeDefaultData, 
    /**
     * Logger object
     */
    log, 
    /**
     * Parent scope, if any. Root scope (module scope) should not have parent.
     */
    parentScope, 
    /**
     * Node which spawned current scope. May be undefined for root scope.
     */
    ownerNode) {
        var _this = this;
        this.sourceFile = sourceFile;
        this.nodeDefaultData = nodeDefaultData;
        this.log = log;
        this.parentScope = parentScope;
        this.ownerNode = ownerNode;
        /**
         * Declarations map containing all identifiers declared in current scope.
         * Identifier -> Node
         */
        this.declarations = new Map();
        /**
         * List of child scopes spawned by functional identifiers.
         */
        this.childScopes = new Set();
        /**
         * Usage data of every ident. Needed to determine all vars that should be passed in closure
         */
        this.identsUsed = new Set();
        /**
         * User hooks to collect more precise usage data in upper scopes
         */
        this.listeners = new Map();
        /**
         * List of variables containing class instances
         */
        this.classInstances = new Set();
        /**
         * Find declaration in current scope or in any of parent scopes
         * @param ident
         * @private
         */
        this._findOrInsertNode = function (ident) {
            var _a = __read(_this._findNode(ident) || [], 1), foundNode = _a[0];
            if (foundNode) {
                return foundNode;
            }
            var node = new node_1.BindPendingNode(ident, _this, _this.nodeDefaultData, _this.log);
            _this.declarations.set(ident, node);
            _this._callListeners(Scope.EV_UNBOUND_CREATED, ident);
            return node;
        };
    }
    Object.defineProperty(Scope.prototype, "tNodeLocal", {
        get: function () {
            return this._termNodeLocalName;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Static: create new root scope with new terminal node in it.
     * Typically, you should create new scope for every module (file) being processed.
     *
     * @param nodeDefaultData  Default custom data for declarations (aka graph nodes)
     * @param sourceFile       Path to processed source file
     * @param log              Logger instance
     * @param globalsList      Global vars that should be terminated to global scope
     */
    Scope.newRootScope = function (nodeDefaultData, sourceFile, log, globalsList) {
        if (globalsList === void 0) { globalsList = []; }
        var scope = new Scope(sourceFile, nodeDefaultData, log);
        scope._termNodeLocalName = Scope.tNode; // For root scope, local and global termination nodes are the same node.
        var terminalNode = new node_1.BoundNode(Scope.tNode, scope, nodeDefaultData, log);
        scope.declarations.set(Scope.tNode, terminalNode);
        // Don't set dryRun here, because newRootScope is expected to be called only once before any runs
        globalsList.forEach(function (ident) { return scope.addDeclaration(ident, [], { terminateGlobally: true, dryRun: true }); });
        return scope;
    };
    Scope.prototype.addEventListener = function (event, cb) {
        var _a;
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.add(cb);
    };
    Scope.prototype.removeEventListener = function (event, cb) {
        var _a;
        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.delete(cb);
    };
    Scope.prototype._callListeners = function (event, ident) {
        var listeners = this.listeners.get(event);
        if (!listeners) {
            return;
        }
        listeners.forEach(function (cb) { return cb(ident); });
    };
    Scope.prototype.isRoot = function () {
        return this.localTerminalNode === this.terminalNode;
    };
    Scope.prototype.findByIdent = function (ident) {
        var _a = __read(this._findNode(ident) || [], 2), foundNode = _a[0], scope = _a[1];
        if (foundNode && scope) {
            return [foundNode.data, scope, foundNode];
        }
        return null;
    };
    Scope.prototype.getClosure = function () {
        var _this = this;
        var idents = new Map();
        var currentScope = this.parentScope; // Start with parent scope - because we don't need vars declared in current scope.
        while (currentScope) {
            this.identsUsed.forEach(function (node) {
                if (node.homeScope !== _this) {
                    idents.set(node.ident, node.data);
                }
            });
            currentScope = currentScope.parentScope;
        }
        return idents;
    };
    Scope.prototype._findNode = function (ident) {
        var scope = this;
        while (scope) {
            if (scope.declarations.has(ident)) {
                return [scope.declarations.get(ident), scope];
            }
            scope = scope.parentScope;
        }
        return null;
    };
    /**
     * Create new child scope and return it.
     * Should not be used by hand, use Node.spawnScope() instead.
     */
    Scope.prototype._addChildScope = function (sourceFile, ownerNode) {
        var child = new Scope(sourceFile, this.nodeDefaultData, this.log, this, ownerNode);
        child._termNodeLocalName = '__#retval@' + ownerNode.ident; // internal value for tNodeLocal
        var terminalNode = new node_1.BoundNode(child.tNodeLocal, child, this.nodeDefaultData, this.log);
        child.declarations.set(Scope.tNode, this.terminalNode); // assign global terminal node by ref
        child.declarations.set(child.tNodeLocal, terminalNode); // assign local terminal node
        this.childScopes.add(child);
        return child;
    };
    Scope.prototype._logAction = function (action, traceSourceIdent, dryRun, traceTargetIdents, terminateLocally, terminateGlobally) {
        if (!(this.log.verbosity & log_1.LogVerbosity.WITH_ELIMINATION_HINTS)) {
            return;
        }
        var tgtIdents = traceTargetIdents.filter(function (id) { return !!id; });
        if (terminateGlobally) {
            tgtIdents.push(Scope.tNode);
        }
        if (terminateLocally) {
            tgtIdents.push(this.tNodeLocal);
        }
        this.log.info('[%s] %s: %s -> [%s]', [dryRun ? 'D' : ' ', action, traceSourceIdent, tgtIdents.join(', ')]);
    };
    Scope.prototype.collectPendingNodes = function (scope, ident) {
        var collectedNodes = [];
        function collect(scopeC) {
            var pendingNode = scopeC.declarations.get(ident);
            if (pendingNode && node_1.isPending(pendingNode)) {
                collectedNodes.push(pendingNode);
            }
            scopeC.childScopes.forEach(collect);
        }
        collect(scope);
        return collectedNodes;
    };
    Scope.prototype.addClassInstance = function (ident) {
        this.classInstances.add(ident);
    };
    Scope.prototype.isClassInstance = function (ident) {
        var _a;
        return this.classInstances.has(ident) || (((_a = this.parentScope) === null || _a === void 0 ? void 0 : _a.isClassInstance(ident)) || false);
    };
    /**
     * Add declaration of identifier to current scope
     *
     * @param traceSourceIdent  Identifier: variable or function name
     * @param traceTargetIdents  What other identifiers are used to compute value.
     *                        All identifiers in expressions, all function args should be here.
     * @param terminateGlobally  Set this to true if variable or function is used in library methods or is exported
     * @param terminateLocally  Set this to true if variable or result of function call is returned as result.
     * @param dryRun  First pass of codegen?
     */
    Scope.prototype.addDeclaration = function (traceSourceIdent, traceTargetIdents, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.terminateGlobally, terminateGlobally = _c === void 0 ? false : _c, _d = _b.terminateLocally, terminateLocally = _d === void 0 ? false : _d, _e = _b.dryRun, dryRun = _e === void 0 ? false : _e;
        var node;
        // To make sure we're creating a new node and not binding lately-bound one, we should check every child
        // scope (recursively) for existence of node with current identifier.
        var pendingNodes = this.collectPendingNodes(this, traceSourceIdent);
        var nodeDeclaredInCurrentScope = this.declarations.get(traceSourceIdent);
        // We don't declare anything in second run, just check and bail out
        if (!dryRun) {
            if (!nodeDeclaredInCurrentScope) {
                this.log.error('No identifier %s declared while unused vars elimination: it\'s probably a bug in transpiler', [traceSourceIdent], this.log.shortCtx(this.sourceFile));
                return null;
            }
            if (node_1.isPending(nodeDeclaredInCurrentScope)) {
                this.log.error('Node %s was not bound while unused vars elimination: it\'s probably a bug in transpiler', [traceSourceIdent], this.log.shortCtx(this.sourceFile));
                return null;
            }
            return nodeDeclaredInCurrentScope;
        }
        this._logAction('Add declaration', traceSourceIdent, dryRun, traceTargetIdents, terminateLocally, terminateGlobally);
        if (nodeDeclaredInCurrentScope && !node_1.isPending(nodeDeclaredInCurrentScope)) {
            if (traceSourceIdent === 'children') {
                // Ugly hack:
                // We may declare intrinsic 'children' property both in object binding pattern and in parameters.
                // It's ok to try it twice or more.
                // TODO: get rid of 'children' identifier hardcode here and in objectBindingPattern::renderBindingElement
                return null;
            }
            this.log.error('Identifier %s already declared @ %s', [traceSourceIdent, nodeDeclaredInCurrentScope.homeScope.tNodeLocal], this.log.shortCtx(this.sourceFile));
            return null;
        }
        // We should pass here only in dry run with pending or undefined node
        var traceTargetNodes = traceTargetIdents.filter(function (s) { return !!s; }).map(this._findOrInsertNode);
        if (pendingNodes.length > 0) {
            node = pendingNodes[0].makeBoundNode(traceTargetNodes, this);
            pendingNodes.forEach(function (n) {
                n.homeScope.declarations.delete(n.ident);
                n.replaceWith(node);
                n.homeScope.identsUsed.delete(n);
                n.homeScope.identsUsed.add(node);
            });
            this.declarations.set(traceSourceIdent, node);
            this._callListeners(Scope.EV_BIND_UNBOUND, traceSourceIdent);
        }
        else {
            node = new node_1.BoundNode(traceSourceIdent, this, this.nodeDefaultData, this.log, traceTargetNodes);
            this.declarations.set(traceSourceIdent, node);
            this._callListeners(Scope.EV_DECL, traceSourceIdent);
        }
        if (terminateGlobally) {
            this._logAction('Terminate call to global [@addDeclaration]', traceSourceIdent, dryRun, traceTargetIdents, terminateLocally, terminateGlobally);
            this.terminalNode.addEdgeTo(node);
        }
        if (terminateLocally) {
            this._logAction('Terminate call to local [@addDeclaration]', traceSourceIdent, dryRun, traceTargetIdents, terminateLocally, terminateGlobally);
            this.localTerminalNode.addEdgeTo(node);
        }
        return node;
    };
    /**
     * Add usage of identifier to current scope
     *
     * @param traceSourceIdent  Identifier: variable or function name
     * @param traceTargetIdents  What other identifiers are used to compute value.
     *                          All identifiers in expressions, all function args should be here.
     * @param terminateGlobally  Set this to true if variable or function is used in library methods
     * @param terminateLocally  Set this to true if variable or result of function call is returned as result.
     * @param dryRun  First pass of codegen?
     */
    Scope.prototype.addUsage = function (traceSourceIdent, traceTargetIdents, _a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, _c = _b.terminateGlobally, terminateGlobally = _c === void 0 ? false : _c, _d = _b.terminateLocally, terminateLocally = _d === void 0 ? false : _d, _e = _b.dryRun, dryRun = _e === void 0 ? false : _e;
        if (!dryRun) {
            // We don't add usages on non-dry run, it's pointless
            return;
        }
        var traceSourceNode = this._findOrInsertNode(traceSourceIdent);
        this.identsUsed.add(traceSourceNode);
        this._callListeners(Scope.EV_USAGE, traceSourceIdent);
        if (terminateGlobally) {
            this._logAction('Terminate call to global [@addUsage]', traceSourceIdent, dryRun, traceTargetIdents, terminateLocally, terminateGlobally);
            this.terminalNode.addEdgeTo(traceSourceNode);
        }
        if (terminateLocally) {
            this._logAction('Terminate call to local [@addUsage]', traceSourceIdent, dryRun, traceTargetIdents, terminateLocally, terminateGlobally);
            this.localTerminalNode.addEdgeTo(traceSourceNode);
        }
        traceTargetIdents
            .map(this._findOrInsertNode)
            .forEach(function (n) {
            _this._logAction('Add usage', traceSourceIdent, dryRun, [n.ident], terminateLocally, terminateGlobally);
            traceSourceNode.addEdgeTo(n);
        });
    };
    Scope.prototype.terminateCall = function (traceTargetIdent, _a) {
        var _b = _a === void 0 ? {} : _a, traceSourceIdent = _b.traceSourceIdent, _c = _b.dryRun, dryRun = _c === void 0 ? false : _c;
        if (!dryRun) {
            // We don't add usages on non-dry run, it's pointless
            return;
        }
        if (!traceSourceIdent) {
            traceSourceIdent = this.tNodeLocal;
        }
        var traceTargetNode = this._findOrInsertNode(traceTargetIdent);
        var traceSourceNode = this._findOrInsertNode(traceSourceIdent);
        this._logAction('Terminate call', traceSourceIdent, dryRun, [traceTargetIdent], false, false);
        traceSourceNode.addEdgeTo(traceTargetNode);
    };
    /**
     * Used in components to attach component's return node to parent return node
     * @param dryRun
     */
    Scope.prototype.terminateToParentTerminalNode = function (dryRun) {
        var _a, _b;
        if (dryRun === void 0) { dryRun = false; }
        if (!dryRun) {
            return;
        }
        var traceSourceNode = (_a = this.parentScope) === null || _a === void 0 ? void 0 : _a.localTerminalNode;
        if (!traceSourceNode) {
            this.log.error('Trying to terminate root node to upper scope - this is error in transpiler', [], this.log.shortCtx(this.sourceFile));
            return;
        }
        var traceTargetNode = this.localTerminalNode;
        this._logAction('Terminate scope to local', ((_b = this.parentScope) === null || _b === void 0 ? void 0 : _b.tNodeLocal) || '', dryRun, [this.tNodeLocal], false, false);
        traceSourceNode.addEdgeTo(traceTargetNode);
    };
    /**
     * Reset usage flags for all nodes in all child scopes and current scope
     */
    Scope.prototype.reset = function () {
        if (this.parentScope) {
            this.log.error('reset() is not intended to be used with non-root scope', [], this.log.shortCtx(this.sourceFile));
            return;
        }
        this.declarations.forEach(function (node) { return node.reset(); });
        this.childScopes.forEach(function (scope) { return scope.reset(); });
    };
    Object.defineProperty(Scope.prototype, "terminalNode", {
        /**
         * Get global terminal node
         * Terminal nodes are always early-bound
         */
        get: function () {
            return this.declarations.get(Scope.tNode);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scope.prototype, "localTerminalNode", {
        /**
         * Get local terminal node
         * Terminal nodes are always early-bound
         */
        get: function () {
            return this.declarations.get(this.tNodeLocal);
        },
        enumerable: false,
        configurable: true
    });
    Scope.prototype.checkUsage = function (varName) {
        var _a;
        if (Scope._forceDisableUnusedVarsElimination) {
            return true;
        }
        return !!(this.declarations.has(varName) && ((_a = this.declarations.get(varName)) === null || _a === void 0 ? void 0 : _a.used));
    };
    Scope._forceDisableUnusedVarsElimination = false;
    Scope.EV_USAGE = 'usage';
    Scope.EV_DECL = 'declaration';
    Scope.EV_UNBOUND_CREATED = 'unbound_created';
    Scope.EV_BIND_UNBOUND = 'bind_unbound';
    /**
     * Identifier for terminal node. There should be no other variables or functions with this name.
     * Global terminal node is copied to every child scope by reference.
     */
    Scope.tNode = '__#global_terminal__';
    return Scope;
}());
exports.Scope = Scope;
