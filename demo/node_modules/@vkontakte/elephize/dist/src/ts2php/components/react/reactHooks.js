"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkReactAssignment = exports.reactHooksSupport = exports.initReact = void 0;
var ts = require("typescript");
var ast_1 = require("../../utils/ast");
var renderNodes_1 = require("../codegen/renderNodes");
var hooksNames = [
    'useState',
    'useEffect',
    'useContext',
    'useReducer',
    'useCallback',
    'useMemo',
    'useRef',
    'useImperativeHandle',
    'useLayoutEffect',
    'useDebugValue',
];
// Initialize react module name in current scope
function initReact(node, context) {
    var _a;
    var bindings = (_a = node.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings;
    if ((bindings === null || bindings === void 0 ? void 0 : bindings.kind) === ts.SyntaxKind.NamespaceImport) {
        context.moduleDescriptor.registerSpecialVar('react', bindings.name.getText());
        return true;
    }
    return false;
}
exports.initReact = initReact;
var dropRender = function (node, context) {
    ast_1.flagParentOfType(node, [
        ts.SyntaxKind.VariableDeclaration,
        ts.SyntaxKind.BinaryExpression, // assignment with no declaration
    ], { drop: true }, context.nodeFlagsStore);
    return null;
};
var hookRenderers = {
    'useState': function (node, context) {
        var val = renderNodes_1.renderNode(node.arguments[0], context); // recognize only 1st argument of call
        return "[" + val + "]";
    },
    'useContext': function (node, context, nodeIdent) {
        context.log.error('React contexts are not supported in isomorphic components', [], context.log.ctx(node));
        return dropRender(node, context, nodeIdent);
    },
    'useReducer': function (node, context) {
        var val = renderNodes_1.renderNode(node.arguments[1], context); // recognize only 2nd argument of call, it's initial state
        if (!val) {
            context.log.error('You must provide initial state to useReducer call', [], context.log.ctx(node));
        }
        return "[" + val + "]";
    },
    'useMemo': function (node, context) {
        return "(" + renderNodes_1.renderNode(node.arguments[0], context) + ")()";
    },
    'useRef': function (node, context) {
        var val = renderNodes_1.renderNode(node.arguments[0], context); // recognize only 1st argument of call
        return "[\"current\" => " + val + "]";
    },
    'useCallback': dropRender,
    'useEffect': function () { return '!null'; },
    'useImperativeHandle': function () { return '!null'; },
    'useLayoutEffect': function () { return '!null'; },
    'useDebugValue': function () { return '!null'; },
};
function reactHooksSupport(context, node) {
    if (node.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {
        var ex = node.expression;
        var isReactMember = context.moduleDescriptor.checkSpecialVarIdentifier(ex.expression, 'react');
        if (!isReactMember) {
            return false;
        }
        if (hooksNames.includes(ex.name.getText())) {
            return hookRenderers[ex.name.getText()](node, context, ex.name.getText()) || false;
        }
        return false;
    }
    return hooksNames.reduce(function (acc, hook) {
        if (acc !== false) {
            return acc;
        }
        if (context.moduleDescriptor.checkSpecialVarIdentifier(node.expression, hook)) {
            return hookRenderers[hook](node, context, node.expression.getText()) || false;
        }
        return false;
    }, false) || false;
}
exports.reactHooksSupport = reactHooksSupport;
function registerHookInContext(name, expr, context, node) {
    hooksNames.some(function (hook) {
        if (name === hook) {
            context.moduleDescriptor.registerSpecialVar(hook, expr, node);
            return true;
        }
    });
}
function checkReactAssignment(node, context) {
    var e_1, _a;
    var _b;
    // Check dereferenced assignment
    if (context.moduleDescriptor.checkSpecialVarIdentifier(node.initializer, 'react')) {
        if (node.name.kind === ts.SyntaxKind.ObjectBindingPattern) {
            try {
                for (var _c = __values(node.name.elements), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var n = _d.value;
                    registerHookInContext((n.propertyName || n.name).getText(), n.name.getText(), context, node);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return true;
    }
    // Check property assignment
    if (((_b = node.initializer) === null || _b === void 0 ? void 0 : _b.kind) === ts.SyntaxKind.PropertyAccessExpression && node.name.kind === ts.SyntaxKind.Identifier) {
        var _e = node.initializer, name_1 = _e.name, expression = _e.expression;
        if (context.moduleDescriptor.checkSpecialVarIdentifier(expression, 'react')) {
            registerHookInContext(name_1.getText(), node.name.getText(), context, node);
            return true;
        }
    }
    return false;
}
exports.checkReactAssignment = checkReactAssignment;
