"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveModules = void 0;
var ts = require("typescript");
var path = require("path");
var pathsAndNames_1 = require("../../utils/pathsAndNames");
var glob = require("glob");
/*
  TODO:
 - Сейчас пока что сделано так, что нужно проверять соответствия типов и сигнатур вручную. Как можно автоматизировать и обеспечить fail-early?
   - При вызове функций заменяемого модуля можно проверять соответствие по выведенным типам аргументов и по количеству аргументов, а также
     по типу возвращаемого значения и выводить ошибку в случае несоответствия.
   - Нужно где-то иметь список возможных php/kphp типов и соответствия их типам ts (по крайней мере примитивам).

 */
function fileExists(fileName) {
    return ts.sys.fileExists(fileName);
}
function readFile(fileName) {
    return ts.sys.readFile(fileName);
}
function resolveModulePath(name, containingFile, baseDir, tsPaths, log) {
    var localPath = pathsAndNames_1.resolveAliasesAndPaths(log, name, path.dirname(containingFile), baseDir, tsPaths, {}, true);
    if (localPath) { // relative or aliased path found
        return localPath;
    }
    // we get here if we have node module import, just output as is
    return name;
}
var resolvedReplaceRules = {};
var resolvedIgnoreRules = {};
var lastIgnoredRulesRef;
var lastReplacedRulesRef;
function getRules(ignoredImportRules, replacedImportRules, baseDir) {
    if (lastReplacedRulesRef !== replacedImportRules) {
        Object.keys(replacedImportRules).forEach(function (key) {
            var p = path.resolve(baseDir, key);
            resolvedReplaceRules[fileExists(p) ? p : key] = __assign(__assign({}, replacedImportRules[key]), { ignore: false });
        });
        lastReplacedRulesRef = replacedImportRules;
    }
    if (lastIgnoredRulesRef !== ignoredImportRules) {
        ignoredImportRules.forEach(function (key) {
            glob.sync(baseDir + '/' + key)
                .forEach(function (fn) { return resolvedIgnoreRules[fn] = { ignore: true }; });
        });
        lastIgnoredRulesRef = ignoredImportRules;
    }
    return { resolvedIgnoreRules: resolvedIgnoreRules, resolvedReplaceRules: resolvedReplaceRules };
}
function findImportRule(ignoredImportRules, replacedImportRules, baseDir, log, filepath) {
    if (!filepath) {
        return undefined;
    }
    log.info('Checking import override rules for %s', [filepath]);
    var _a = getRules(ignoredImportRules, replacedImportRules, baseDir), resolvedIgnoreRules = _a.resolvedIgnoreRules, resolvedReplaceRules = _a.resolvedReplaceRules;
    return resolvedIgnoreRules[filepath] || resolvedReplaceRules[filepath] || undefined;
}
var emptyModule = { resolvedFileName: path.resolve(__dirname, '__empty.ts') };
var resolveModules = function (options, ignoredImports, replacedImports, baseDir, tsPaths, log) { return function (moduleNames, containingFile) {
    var e_1, _a;
    log.info('Trying to resolve module names [%s] found in %s', [moduleNames.join(', '), containingFile]);
    var resolvedModules = [];
    var replacements = [];
    try {
        for (var moduleNames_1 = __values(moduleNames), moduleNames_1_1 = moduleNames_1.next(); !moduleNames_1_1.done; moduleNames_1_1 = moduleNames_1.next()) {
            var moduleName = moduleNames_1_1.value;
            var mPath = resolveModulePath(moduleName, containingFile, baseDir, tsPaths, log);
            var rule = findImportRule(ignoredImports, replacedImports, baseDir, log, mPath);
            if (rule && rule.ignore) {
                resolvedModules.push(emptyModule);
                log.info('Module %s was ignored according to library settings', [moduleName]);
            }
            else {
                if (rule) {
                    log.info('Module %s was replaced with implementation %s according to library settings', [moduleName, rule.implementationClass]);
                    replacements.push(__assign({ modulePath: mPath }, rule));
                }
                // try to use standard resolution
                var result = ts.resolveModuleName(moduleName, containingFile, options, {
                    fileExists: fileExists,
                    readFile: readFile,
                });
                if (result.resolvedModule) {
                    resolvedModules.push(result.resolvedModule);
                }
                else {
                    if (!containingFile.endsWith('.d.ts')) {
                        // there may be false-positive errors in .d.ts files belonging to node typings
                        log.error('Module %s was not found while parsing imports of %s', [moduleName, containingFile]);
                    }
                    resolvedModules.push(emptyModule);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (moduleNames_1_1 && !moduleNames_1_1.done && (_a = moduleNames_1.return)) _a.call(moduleNames_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return [resolvedModules, replacements];
}; };
exports.resolveModules = resolveModules;
