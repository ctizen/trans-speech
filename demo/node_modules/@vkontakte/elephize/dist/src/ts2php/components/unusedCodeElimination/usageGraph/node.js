"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BindPendingNode = exports.BoundNode = exports.ScopeNode = exports.isPending = exports.isBound = void 0;
var scope_1 = require("./scope");
var log_1 = require("../../../utils/log");
var isBound = function (node) { return node._type === 'early_bound'; };
exports.isBound = isBound;
var isPending = function (node) { return node._type === 'late_bound'; };
exports.isPending = isPending;
var ScopeNode = /** @class */ (function () {
    function ScopeNode(
    /**
     * Variable or func name, unique in its scope.
     */
    ident, 
    /**
     * Functional scope this var belongs to.
     */
    homeScope, data, log) {
        this.ident = ident;
        this.homeScope = homeScope;
        this.log = log;
        this._type = 'abstract';
        /**
         * Edges list: contains nodes connected to current node. Directed.
         */
        this._edges = new Set();
        /**
         * Traverse mark: common flag, used in DFS
         */
        this._traverseMark = false;
        /**
         * Target nodes where current unbound node is to be replaced with bound node.
         * This should be filled in BindPendingNode, and is intended to be READONLY in BoundNode it's replaced with.
         * @protected
         */
        this._tmpTraceTargetNodes = new Map();
        /**
         * Flag for usage mark
         * True if current identifier is used by some other identifier or by terminal node
         */
        this._usageMark = false;
        this.data = __assign({}, data);
    }
    ScopeNode.prototype.spawnScope = function (sourceFile, dryRun) {
        throw new Error((dryRun ? '[dry]' : '') + 'Can\'t spawn new scope on unbound node!');
    };
    /**
     *
     * @param node
     * @private
     */
    ScopeNode.prototype._genCharString = function (node) {
        return node.ident + "[" + (node._type === 'early_bound' ? 'B' : 'b') + (node.used ? 'U' : 'u') + "]";
    };
    /**
     * Small letters indicate false boolean flag, capitals indicate true
     * B: bound
     * U: used
     */
    ScopeNode.prototype.toString = function () {
        var _this = this;
        return this._genCharString(this) +
            ("\n\t-> [ " + Array.from(this._edges).map(function (n) { return _this._genCharString(n); }).join(', ') + " ]");
    };
    /**
     * Add dependency: current node depends on given node (uses it somehow).
     * @param node
     */
    ScopeNode.prototype.addEdgeTo = function (node) {
        if (exports.isBound(node) && node._ownedScope) {
            this._edges.add(node._ownedScope.localTerminalNode); // for proper handling of return instructions
        }
        if (exports.isPending(node)) {
            node.revdep(this);
        }
        this._edges.add(node);
    };
    /**
     * Remove dependency of this node on some another node
     * @param node
     */
    ScopeNode.prototype.removeEdgeTo = function (node) {
        if (exports.isBound(node) && node._ownedScope) {
            this._edges.delete(node._ownedScope.localTerminalNode); // for proper handling of return instructions
        }
        this._edges.delete(node);
    };
    /**
     * Simple DFS with marks
     * @param cb
     * @param traversedNodeList
     * @param bailOnUnbound
     * @private
     */
    ScopeNode.prototype._traverse = function (cb, traversedNodeList, bailOnUnbound) {
        var _this = this;
        this._edges.forEach(function (node) {
            if (bailOnUnbound && !exports.isBound(node)) {
                _this.log.error('Identifier "%s" was used but was never declared. This is compile error', [node.ident], _this.log.shortCtx(_this.homeScope.sourceFile));
                return;
            }
            if (node._traverseMark) {
                return;
            }
            node._traverseMark = true;
            traversedNodeList.add(node);
            if (cb(node)) {
                node._traverse(cb, traversedNodeList, bailOnUnbound);
            }
        });
    };
    /**
     * Traverse usage graph with DFS and then reset traverse
     * marks to ensure proper work of following traversals.
     * @param cb
     * @param bail
     */
    ScopeNode.prototype.traverse = function (cb, bail) {
        if (bail === void 0) { bail = true; }
        var nodeList = new Set();
        this._traverse(cb, nodeList, bail);
        nodeList.forEach(function (node) { return node._traverseMark = false; }); // reset traverse marks
    };
    ScopeNode.prototype._dump = function (printer) {
        if (printer === void 0) { printer = console.log; }
        printer(this.toString());
        return this.traverse(function (node) {
            printer(node.toString());
            return true;
        }, false);
    };
    Object.defineProperty(ScopeNode.prototype, "used", {
        get: function () {
            return this._usageMark;
        },
        enumerable: false,
        configurable: true
    });
    ScopeNode.prototype._markUsed = function () {
        if (this.log.verbosity & log_1.LogVerbosity.WITH_USAGE_GRAPH_DUMP) {
            this.log.info('Marking node as used: %s', [this.ident]);
        }
        this._usageMark = true;
    };
    ScopeNode.prototype.reset = function () {
        if (this.log.verbosity & log_1.LogVerbosity.WITH_USAGE_GRAPH_DUMP) {
            this.log.info('Resetting node usage: %s', [this.ident]);
        }
        this._usageMark = false;
    };
    /**
     * Call this method on terminal node to travers and mark all used identifiers in all scopes.
     * Use homeScope.reset() to uncheck usage marks
     */
    ScopeNode.prototype.markUsage = function () {
        var _this = this;
        if (this.ident !== scope_1.Scope.tNode) {
            this.log.error('Mark usage method is not expected to be applied to non-terminal nodes', [], this.log.shortCtx(this.homeScope.sourceFile));
            return;
        }
        if (exports.isBound(this)) {
            this._markUsed();
        }
        else {
            this.log.error('Undeclared or dropped identifier encountered: %s', [this.ident], this.log.shortCtx(this.homeScope.sourceFile));
        }
        this.traverse(function (node) {
            if (exports.isBound(node)) {
                node._markUsed();
            }
            else {
                _this.log.error('Undeclared or dropped identifier encountered: %s', [node.ident], _this.log.shortCtx(_this.homeScope.sourceFile));
            }
            return true;
        }, false);
    };
    return ScopeNode;
}());
exports.ScopeNode = ScopeNode;
var BoundNode = /** @class */ (function (_super) {
    __extends(BoundNode, _super);
    function BoundNode(ident, homeScope, data, log, traceTargetNodes, tmpSourceTargets) {
        if (traceTargetNodes === void 0) { traceTargetNodes = []; }
        var _this = _super.call(this, ident, homeScope, data, log) || this;
        _this._type = 'early_bound';
        _this._tmpTraceTargetNodes = tmpSourceTargets || new Map();
        traceTargetNodes.forEach(function (node) { return _this.addEdgeTo(node); });
        return _this;
    }
    Object.defineProperty(BoundNode.prototype, "ownedScope", {
        /**
         * Get scope created by this identifier
         */
        get: function () {
            return this._ownedScope;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Create scope for this identifier.
     * Equivalent to adding new stack frame to the call stack.
     */
    BoundNode.prototype.spawnScope = function (sourceFile, dryRun) {
        var _this = this;
        if (dryRun) {
            this._ownedScope = this.homeScope._addChildScope(sourceFile, this);
        } // else: owned scope is expected to already exist
        if (!this._ownedScope) {
            throw new Error('Failed to get owned scope!');
        }
        // If this node was unbound once, it should have temporary trace targets,
        // we should append our local terminals there in order to make our unused
        // vars collector work well with function hoisting.
        this._tmpTraceTargetNodes.forEach(function (node) {
            var _a;
            var localTerm = (_a = _this._ownedScope) === null || _a === void 0 ? void 0 : _a.localTerminalNode;
            if (localTerm) {
                node.addEdgeTo(localTerm);
            }
        });
        return this._ownedScope;
    };
    return BoundNode;
}(ScopeNode));
exports.BoundNode = BoundNode;
// Late-bound graph node
var BindPendingNode = /** @class */ (function (_super) {
    __extends(BindPendingNode, _super);
    function BindPendingNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._type = 'late_bound';
        return _this;
    }
    BindPendingNode.prototype.revdep = function (node) {
        // TODO: this may fail in case of shadowing functions
        this._tmpTraceTargetNodes.set(node.ident, node);
    };
    BindPendingNode.prototype.makeBoundNode = function (traceTargetNodes, withHomeScope) {
        return new BoundNode(this.ident, withHomeScope, this.data, this.log, Array.from(this._edges).concat(traceTargetNodes), this._tmpTraceTargetNodes);
    };
    BindPendingNode.prototype.replaceWith = function (node) {
        var _this = this;
        this._tmpTraceTargetNodes.forEach(function (n) {
            n.removeEdgeTo(_this);
            n.addEdgeTo(node);
        });
    };
    return BindPendingNode;
}(ScopeNode));
exports.BindPendingNode = BindPendingNode;
