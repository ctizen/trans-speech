"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleRegistry = void 0;
var commonjsModule_1 = require("./commonjsModule");
var reactModule_1 = require("./reactModule");
var pathsAndNames_1 = require("../../utils/pathsAndNames");
var commonjsExternalModule_1 = require("./commonjsExternalModule");
var enumModule_1 = require("./enumModule");
var path = require("path");
var classModule_1 = require("./classModule");
var ModuleRegistry = /** @class */ (function () {
    function ModuleRegistry(_baseDir, _aliases, _tsPaths, _namespaces, _serverFilesRoot, _builtinsPath, _replacements, log) {
        var _this = this;
        this._baseDir = _baseDir;
        this._aliases = _aliases;
        this._tsPaths = _tsPaths;
        this._namespaces = _namespaces;
        this._serverFilesRoot = _serverFilesRoot;
        this._builtinsPath = _builtinsPath;
        this._replacements = _replacements;
        this.log = log;
        /**
         * Set for making unique class names for derived components
         */
        this._registeredModuleClasses = new Set();
        /**
         * Mapping of source file name to all original and derived modules
         */
        this._sourceFilenameToModule = new Map();
        /**
         * Mapping of target file name to module instance
         */
        this._targetFilenameToModule = new Map();
        this._derivedComponentsPathMap = new Map();
        this._plainClasses = new Map();
        /**
         * Set for determining if a variable in module is a derived component or not;
         * We place here entries like FilePath__varName which identify the component function.
         */
        this._registeredComponents = new Set();
        this._replacements.forEach(function (rule) { return _this._registerExternalClass(rule); });
    }
    ModuleRegistry.prototype.clearClasses = function () {
        this._registeredModuleClasses = new Set();
    };
    ModuleRegistry.prototype.forEachModule = function (cb) {
        this._targetFilenameToModule.forEach(cb);
    };
    ModuleRegistry.prototype.getExportedIdentifier = function (forModule, targetFilename, identifier, rewriteCase) {
        if (rewriteCase === void 0) { rewriteCase = false; }
        if (!targetFilename) {
            // Dropped or ignored import
            this.log.error('Attempt to reach dropped or ignored module: %s \n\t@ %s', [identifier, forModule.sourceFileName]);
            return 'null';
        }
        var instance = this._getInstance(targetFilename, identifier);
        if (!instance) {
            return 'null';
        }
        var mod = this._targetFilenameToModule.get(targetFilename);
        forModule.registerRequiredFile(targetFilename, forModule.targetFileName, mod);
        return instance + "->" + (rewriteCase ? pathsAndNames_1.snakify(identifier) : identifier);
    };
    ModuleRegistry.prototype.callExportedCallable = function (forModule, targetFilename, identifier, args) {
        if (!targetFilename) {
            // Dropped or ignored import
            this.log.error('Attempt to reach dropped or ignored module: %s \n\t@ %s', [identifier, forModule.sourceFileName]);
            return 'null';
        }
        var instance = this._getInstance(targetFilename, identifier);
        if (!instance) {
            return 'null';
        }
        var mod = this._targetFilenameToModule.get(targetFilename);
        if (mod === null || mod === void 0 ? void 0 : mod.isExternal) {
            mod.addMethod(identifier, '', '', undefined);
        }
        forModule.registerRequiredFile(targetFilename, forModule.targetFileName, mod);
        return instance + "->" + identifier + "(" + args.join(', ') + ")";
    };
    ModuleRegistry.prototype.getExportedComponent = function (forModule, targetFilename, identifier) {
        if (!targetFilename) {
            // Dropped or ignored import
            this.log.error('Attempt to reach dropped or ignored module: %s \n\t@ %s', [identifier, forModule.sourceFileName]);
            return 'null';
        }
        // component should be in another file, use derived table to determine it
        var derived = this._derivedComponentsPathMap.get(targetFilename);
        var module;
        if (derived) {
            module = this._targetFilenameToModule.get(derived);
        }
        else {
            // if targetFilename contains php module path
            module = this._targetFilenameToModule.get(targetFilename);
        }
        if (!module) {
            this.log.warn('No exported component found for filename %s', [targetFilename]);
        }
        else {
            if (module.isExternal) {
                this.log.error('Derived components in external module are not supported: %s', [targetFilename]);
            }
            if (!derived) { // if targetFilename contains php module path
                derived = targetFilename;
            }
            forModule.registerRequiredFile(derived, forModule.targetFileName, module);
        }
        return this._getInstance(derived || targetFilename, identifier);
    };
    ModuleRegistry.prototype.getLocalComponent = function (forModule, identifier) {
        var _a;
        // Find local module
        var module = (_a = this._sourceFilenameToModule.get(forModule.sourceFileName)) === null || _a === void 0 ? void 0 : _a.find(function (mod) { return mod.originalIdentName === identifier; });
        if (!module) {
            this.log.error('No exported component %s found for filename %s', [identifier, forModule.sourceFileName]);
            return '';
        }
        else {
            forModule.registerRequiredFile(module.targetFileName, forModule.targetFileName, module);
        }
        return this._getInstance(module.targetFileName, identifier);
    };
    ModuleRegistry.prototype.getEnumConst = function (declModuleFilename, enumName, enumMember) {
        var enumModule = (this._sourceFilenameToModule.get(declModuleFilename) || [])
            .find(function (el) { return el.originalIdentName === enumName; });
        if (!enumModule) {
            this.log.error('Enum %s access attempt failed in file %s', [enumName, declModuleFilename]);
            return 'null';
        }
        var fullyQualifiedNamespace = ModuleRegistry.pathToNamespace(enumModule.targetFileName);
        return "\\" + fullyQualifiedNamespace + "\\" + enumModule.className + "::" + enumMember;
    };
    ModuleRegistry.prototype.getSourceModules = function (sourceName) {
        return this._sourceFilenameToModule.get(sourceName) || [];
    };
    ModuleRegistry.prototype.getModuleMethodSource = function (module, name) {
        var _this = this;
        if (!module || !name) {
            return module;
        }
        if (module.hasMethod(name) || module.hasProperty(name)) {
            return module;
        }
        if (module.isDerived && module.originalIdentName === name) {
            return module;
        }
        var resultModule;
        module.imports.forEach(function (importedKeys, importedModuleSourceName) {
            if (importedKeys.includes(name)) {
                var sourceModules = _this.getSourceModules(importedModuleSourceName);
                var findSourceModule = function (module) {
                    if (!module) {
                        return;
                    }
                    var exportSourceName = module.findExportSource(name);
                    if (exportSourceName) {
                        var exportSourceModules = _this.getSourceModules(exportSourceName);
                        return exportSourceModules.find(function (module) { return _this.getModuleMethodSource(module, name); });
                    }
                    return _this.getModuleMethodSource(module, name);
                };
                resultModule = sourceModules.find(findSourceModule);
            }
        });
        return this.getModuleMethodSource(resultModule, name);
    };
    ModuleRegistry.prototype._registerCommonModule = function (className, fullyQualifiedSourceFilename, newFilename, external, implPath) {
        if (external === void 0) { external = false; }
        var moduleDescriptor;
        if (external) {
            moduleDescriptor = new commonjsExternalModule_1.CommonjsExternalModule(className, fullyQualifiedSourceFilename, newFilename, this._namespaces, this._serverFilesRoot, this._builtinsPath, this.log);
            if (!implPath) {
                this.log.error('No implementation path declared for substitution module %s', [className]);
                throw new Error();
            }
            moduleDescriptor.useImplementationFromPath(implPath);
        }
        else {
            moduleDescriptor = new commonjsModule_1.CommonjsModule(className, fullyQualifiedSourceFilename, newFilename, this._namespaces, this._serverFilesRoot, this._builtinsPath, this.log);
        }
        var mods = (this._sourceFilenameToModule.get(fullyQualifiedSourceFilename) || []).concat(moduleDescriptor);
        this._sourceFilenameToModule.set(fullyQualifiedSourceFilename, mods);
        this._targetFilenameToModule.set(newFilename, moduleDescriptor);
        return moduleDescriptor;
    };
    ModuleRegistry.prototype._registerExternalClass = function (rule) {
        var fullyQualifiedSourceFilename = pathsAndNames_1.resolveAliasesAndPaths(this.log, rule.modulePath, '', this._baseDir, this._tsPaths, this._aliases);
        if (!fullyQualifiedSourceFilename) {
            this.log.error('Failed to lookup file %s [#1]', [rule.modulePath]);
            return null;
        }
        var className = pathsAndNames_1.classNameFromPath(fullyQualifiedSourceFilename, true);
        className = this._makeUniqueClassName(className);
        var newFilename = this._makeNewFileName(fullyQualifiedSourceFilename, className);
        this._registeredModuleClasses.add(className);
        return this._registerCommonModule(rule.implementationClass, rule.modulePath, newFilename, true, path.resolve(this._baseDir, rule.implementationPath));
    };
    ModuleRegistry.prototype.registerClass = function (filepath) {
        var fullyQualifiedSourceFilename = pathsAndNames_1.resolveAliasesAndPaths(this.log, filepath, '', this._baseDir, this._tsPaths, this._aliases);
        if (!fullyQualifiedSourceFilename) {
            this.log.error('Failed to lookup file %s [#1]', [filepath]);
            return null;
        }
        var className = pathsAndNames_1.classNameFromPath(fullyQualifiedSourceFilename);
        className = this._makeUniqueClassName(className);
        var newFilename = this._makeNewFileName(fullyQualifiedSourceFilename, className);
        this._registeredModuleClasses.add(className);
        return this._registerCommonModule(className, fullyQualifiedSourceFilename, newFilename);
    };
    ModuleRegistry.prototype.isDerivedComponent = function (sourceFileName, varName) {
        return this._registeredComponents.has(sourceFileName + "__" + varName);
    };
    ModuleRegistry.prototype.deriveReactComponent = function (className, originalModule) {
        var originalIdent = className;
        this._registeredComponents.add(originalModule.sourceFileName + "__" + originalIdent);
        className = this._makeUniqueClassName(className);
        var newFilename = this._makeNewFileName(originalModule.sourceFileName, className, true);
        this._registeredModuleClasses.add(className);
        this._derivedComponentsPathMap.set(originalModule.sourceFileName, newFilename);
        var moduleDescriptor = new reactModule_1.ReactModule(className, originalModule.sourceFileName, newFilename, this._namespaces, this._serverFilesRoot, this._builtinsPath, this.log, originalIdent, originalModule);
        moduleDescriptor._specialVars = originalModule._specialVars;
        var mods = (this._sourceFilenameToModule.get(originalModule.sourceFileName) || []).concat(moduleDescriptor);
        this._sourceFilenameToModule.set(originalModule.sourceFileName, mods);
        this._targetFilenameToModule.set(newFilename, moduleDescriptor);
        return moduleDescriptor;
    };
    ModuleRegistry.prototype.deriveEnumComponent = function (className, originalModule) {
        var originalIdent = className;
        this._registeredComponents.add(originalModule.sourceFileName + "__" + originalIdent);
        className = this._makeUniqueClassName(className);
        var newFilename = this._makeNewFileName(originalModule.sourceFileName, className, true);
        this._registeredModuleClasses.add(className);
        this._derivedComponentsPathMap.set(originalModule.sourceFileName, newFilename);
        var moduleDescriptor = new enumModule_1.EnumModule(className, originalModule.sourceFileName, newFilename, this._namespaces, this._serverFilesRoot, this._builtinsPath, this.log, originalIdent, originalModule);
        var mods = (this._sourceFilenameToModule.get(originalModule.sourceFileName) || []).concat(moduleDescriptor);
        this._sourceFilenameToModule.set(originalModule.sourceFileName, mods);
        this._targetFilenameToModule.set(newFilename, moduleDescriptor);
        return moduleDescriptor;
    };
    ModuleRegistry.prototype.derivePlainClass = function (className, originalModule) {
        var originalIdent = className;
        this._registeredComponents.add(originalModule.sourceFileName + "__" + originalIdent);
        className = this._makeUniqueClassName(className);
        var newFilename = this._makeNewFileName(originalModule.sourceFileName, className, true);
        this._registeredModuleClasses.add(className);
        this._derivedComponentsPathMap.set(originalModule.sourceFileName, newFilename);
        var moduleDescriptor = new classModule_1.ClassModule(className, originalModule.sourceFileName, newFilename, this._namespaces, this._serverFilesRoot, this._builtinsPath, this.log, originalIdent, originalModule);
        var mods = (this._sourceFilenameToModule.get(originalModule.sourceFileName) || []).concat(moduleDescriptor);
        this._sourceFilenameToModule.set(originalModule.sourceFileName, mods);
        this._targetFilenameToModule.set(newFilename, moduleDescriptor);
        this._plainClasses.set(originalModule.sourceFileName + "__" + originalIdent, moduleDescriptor);
        return moduleDescriptor;
    };
    ModuleRegistry.prototype.isPlainClass = function (importPath, identifier) {
        return this._plainClasses.has(importPath + "__" + identifier);
    };
    ModuleRegistry.prototype.getPlainClassName = function (importPath, identifier) {
        var mod = this._plainClasses.get(importPath + "__" + identifier);
        if (!mod) {
            return '';
        }
        var fullyQualifiedNamespace = ModuleRegistry.pathToNamespace(mod.targetFileName);
        return "\\" + fullyQualifiedNamespace + "\\" + (mod.className);
    };
    ModuleRegistry.prototype._makeNewFileName = function (fullyQualifiedFilename, className, addDir) {
        if (addDir === void 0) { addDir = false; }
        var name = pathsAndNames_1.normalizeFileExt(pathsAndNames_1.normalizeBasePath(fullyQualifiedFilename, this._baseDir, this._aliases));
        var rootPath = ModuleRegistry.namespaceToPath(this._namespaces.root);
        var pieces = (rootPath + "/" + name).split('/');
        var filename = (pieces.pop() || '').replace(/\.php$/, '');
        if (addDir) {
            pieces.push(filename);
        }
        pieces = pieces
            .map(function (n) { return ModuleRegistry.replaceInvalidNamespaceSymbols(n); })
            .map(function (n) { return pathsAndNames_1.escapeKeyword(n); });
        pieces.push(className + '.php');
        return pieces.join('/');
    };
    ModuleRegistry.prototype._makeUniqueClassName = function (className) {
        className = pathsAndNames_1.capitalize(pathsAndNames_1.camelize(className));
        if (this._registeredModuleClasses.has(className)) {
            var ctr = 1;
            while (this._registeredModuleClasses.has(className + ctr.toString())) {
                ctr++;
            }
            return className + ctr.toString();
        }
        return className;
    };
    ModuleRegistry.prototype.toTargetPath = function (sourcePath, searchForComponent) {
        var mods = this._sourceFilenameToModule.get(sourcePath) || [];
        for (var i = 0; i < mods.length; i++) {
            if (!searchForComponent && !mods[i].isDerived) {
                return mods[i].targetFileName;
            }
            if (searchForComponent && mods[i].originalIdentName === searchForComponent) {
                return mods[i].targetFileName;
            }
        }
        return undefined;
    };
    ModuleRegistry.prototype._getInstance = function (filename, identifier) {
        var _a;
        if (!this._targetFilenameToModule.has(filename)) {
            this.log.error('Module not registered: %s, when trying to reach property %s', [filename, identifier]);
            return '';
        }
        var fullyQualifiedNamespace = ModuleRegistry.pathToNamespace(filename);
        var className = (_a = this._targetFilenameToModule.get(filename)) === null || _a === void 0 ? void 0 : _a.className;
        return "\\" + fullyQualifiedNamespace + "\\" + className + "::getInstance()";
    };
    ModuleRegistry.replaceInvalidNamespaceSymbols = function (name) {
        return name.replace(/[^a-z0-9_]/ig, '_');
    };
    ModuleRegistry.pathToNamespace = function (path) {
        return path.split('/')
            .reverse()
            .slice(1)
            .reverse()
            .map(function (n) { return ModuleRegistry.replaceInvalidNamespaceSymbols(n); })
            .map(function (n) { return pathsAndNames_1.escapeKeyword(n); })
            .filter(function (el) { return !!el; })
            .join('\\');
    };
    ModuleRegistry.namespaceToPath = function (namespace) {
        return namespace.split('\\')
            .join('/');
    };
    return ModuleRegistry;
}());
exports.ModuleRegistry = ModuleRegistry;
