"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transpile = void 0;
var glob = require("glob");
var translateCode_1 = require("../codegen/translateCode");
var path = require("path");
var fs = require("fs");
var iconv = require("iconv-lite");
var moduleRegistry_1 = require("../cjsModules/moduleRegistry");
var ncp = require("ncp");
var mkdirp_1 = require("mkdirp");
var typescript_1 = require("typescript");
var replace = require('stream-replace');
var joinGlobs = function (globs) { return globs.length > 1 ? "{" + globs.join(',') + "}" : globs[0]; };
function transpile(options, baseDir, outDir, log) {
    var _a;
    var namespaces = {
        root: options.rootNs,
        builtins: options.builtinsNs || (options.rootNs ? options.rootNs + '\\Builtins' : 'Builtins'),
    };
    var builtinsRelativePath = moduleRegistry_1.ModuleRegistry.namespaceToPath(namespaces.builtins);
    var builtinsPath;
    if (options.rewriteBuiltinsRoot) {
        if (!options.builtinsNs) {
            log.warn('builtinsNs option should be provided if rewriteBuiltinsRoot is used', []);
        }
        builtinsPath = path.join(options.rewriteBuiltinsRoot, builtinsRelativePath);
    }
    else {
        builtinsPath = path.resolve(__dirname, '..', '..', '..', 'builtins');
    }
    var serverFilesRoot = (_a = options.serverBaseDir) !== null && _a !== void 0 ? _a : options.baseDir;
    var hooks = {};
    if (options.hooksIncludePath) {
        try {
            var result = typescript_1.transpileModule(fs.readFileSync(options.hooksIncludePath, { encoding: 'utf-8' }), { compilerOptions: { module: typescript_1.ModuleKind.CommonJS } });
            // eslint-disable-next-line no-eval
            var data = eval(result.outputText);
            hooks = __assign({}, (data.reduce(function (acc, entry) {
                acc[entry.nodeKind] = { run: entry.hook };
                return acc;
            }, {})));
        }
        catch (e) {
            log.error('Failed to load AST hooks: %s', [e.toString()]);
            hooks = {};
        }
    }
    glob(Array.isArray(options.src) ? joinGlobs(options.src) : options.src, function (e, matches) {
        if (e) {
            log.error('%s', [e.toString()]);
            process.exit(1);
            return;
        }
        var compilerOptions = {
            baseUrl: baseDir,
            paths: options.tsPaths || {},
        };
        (options.watch ? translateCode_1.translateCodeAndWatch : translateCode_1.translateCode)(matches.map(function (p) { return path.resolve('./', p); }), options.ignoreImports, options.replaceImports, options.tsPaths, log, {
            baseDir: baseDir,
            serverFilesRoot: serverFilesRoot,
            builtinsPath: builtinsPath,
            aliases: options.aliases,
            namespaces: namespaces,
            printImportTree: options.printImportTree,
            encoding: options.encoding || 'utf-8',
            disableCodeElimination: options.noZap,
            options: compilerOptions,
            onData: function (sourceFilename, targetFilename, content) { return onData(targetFilename, content); },
            onFinish: onFinish,
            jsxPreferences: options.jsxPreferences || {},
            hooks: hooks,
        });
    });
    function onData(filename, content) {
        var outputFilename = outDir + '/' + filename;
        log.info('Emitting file: %s', [outputFilename]);
        var outputDir = path.dirname(outputFilename);
        mkdirp_1.sync(outputDir);
        fs.writeFileSync(outputFilename, iconv.encode(content, options.encoding || 'utf-8'));
    }
    function onFinish() {
        if ((log.errCount || 0) > 0 && options.bail === 'error') {
            process.exit(1);
        }
        if ((log.errCount || 0) + (log.warnCount || 0) > 0 && options.bail === 'warn') {
            process.exit(1);
        }
        if (options.rewriteBuiltinsRoot) {
            log.special('Skip builtins copy bacause rewriteBuiltinsRoot options is provided', []);
            return;
        }
        var bTgt = path.join(outDir, moduleRegistry_1.ModuleRegistry.namespaceToPath(namespaces.builtins));
        log.special('Copying builtins files', []);
        log.special('From: %s', [builtinsPath]);
        log.special('To: %s', [bTgt]);
        ncp(builtinsPath, bTgt, {
            transform: function (read, write) {
                read.pipe(replace(/__ROOTNS__\\Builtins/g, namespaces.builtins)).pipe(write);
            },
        }, function (err) {
            if (!err) {
                log.special('Builtins base files successfully copied', []);
            }
        });
    }
}
exports.transpile = transpile;
