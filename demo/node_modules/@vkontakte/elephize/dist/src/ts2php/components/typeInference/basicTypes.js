"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPhpPrimitiveTypeForFunc = exports.getPossibleCastingType = exports.getPhpPrimitiveType = exports.hasArrayType = exports.hasType = exports.typeCast = void 0;
var ts = require("typescript");
var customTypehints_1 = require("./customTypehints");
var basicTypesMap_1 = require("./basicTypesMap");
var customTypehintsList_1 = require("./customTypehintsList");
/**
 * Return custom forced type cast clause based on used-defined commentsconst type = getPhpPrimitiveType(el.name, context.checker, context.log);
 *
 * @param node
 */
function typeCast(node) {
    var trivia = node.getFullText().substr(0, node.getLeadingTriviaWidth());
    if (trivia.includes('@elephizeTypecast')) {
        var matches = trivia.match(/@elephizeTypecast\s+(array|int|float|string|boolean|bool)/i);
        if (matches && matches[1]) {
            return "(" + matches[1] + ")";
        }
    }
    return '';
}
exports.typeCast = typeCast;
/**
 * Check if node has proper inferred type identified by typeString
 *
 * @param node
 * @param checker
 * @param typeString
 */
function hasType(node, checker, typeString) {
    var nd = node.expression;
    var type = checker.getTypeAtLocation(nd);
    var baseType = checker.getBaseTypeOfLiteralType(type);
    return (checker.typeToString(type, nd, ts.TypeFormatFlags.None) === typeString ||
        checker.typeToString(baseType, nd, ts.TypeFormatFlags.None) === typeString);
}
exports.hasType = hasType;
/**
 * Check if node has inferred type identified as iterable
 *
 * @param node
 * @param checker
 * @param log
 */
function hasArrayType(node, checker, log) {
    var nodeIdentForLog = node.getText();
    var nd = node.expression;
    log.typehint('Checking array type of node: %s', [nodeIdentForLog]);
    var type = checker.getTypeAtLocation(nd);
    var foundType = parseArrayType(type, node, checker, log, true, nodeIdentForLog);
    return foundType
        ? (foundType.includes('[]') || foundType.includes('mixed'))
        : false;
}
exports.hasArrayType = hasArrayType;
/**
 * Get primitive type description as string for use in phpdoc
 *
 * @param node
 * @param checker
 * @param log
 */
function getPhpPrimitiveType(node, checker, log) {
    var type = checker.getTypeAtLocation(node);
    if (type.flags === ts.TypeFlags.Any) { // error? try another way
        var typeContextual = checker.getContextualType(node);
        if (typeContextual && typeContextual.flags !== ts.TypeFlags.Any) {
            type = typeContextual;
        }
    }
    return describeNodeType(node, type, checker, log);
}
exports.getPhpPrimitiveType = getPhpPrimitiveType;
/**
 * Get basic type casting clause based on inferred type
 *
 * @param node
 * @param checker
 * @param log
 */
function getPossibleCastingType(node, checker, log) {
    var type = getPhpPrimitiveType(node, checker, log);
    var typeCastFunc = basicTypesMap_1.typeCastFuncForType(type);
    if (typeCastFunc) {
        return "(" + typeCastFunc + ")";
    }
    if (type.includes('[]')) {
        return '(array)';
    }
    return '';
}
exports.getPossibleCastingType = getPossibleCastingType;
/**
 * Get primitive type description as string for use in phpdoc
 *
 * @param node
 * @param argList
 * @param checker
 * @param log
 */
function getPhpPrimitiveTypeForFunc(node, argList, checker, log) {
    var signature = checker.getSignatureFromDeclaration(node);
    if (!signature) {
        // Not functional type?
        return;
    }
    var params = {};
    for (var i = 0; i < node.parameters.length; i++) {
        var param = node.parameters[i].name;
        if (param.kind === ts.SyntaxKind.Identifier) {
            params[argList[i]] = getPhpPrimitiveType(param, checker, log);
        }
        else {
            params[argList[i]] = 'mixed'; // TODO: more specific typing? (applies for destructured objects too!)
        }
    }
    var returnType = checker.getReturnTypeOfSignature(signature);
    var rettype = describeNodeType(undefined, returnType, checker, log);
    return {
        args: params,
        return: rettype,
    };
}
exports.getPhpPrimitiveTypeForFunc = getPhpPrimitiveTypeForFunc;
function parseArrayType(node, baseNode, checker, log, excludeObjects, nodeIdentForLog) {
    var _a, _b;
    if (excludeObjects === void 0) { excludeObjects = true; }
    var typeNode = checker.typeToTypeNode(node, undefined, undefined);
    if (!typeNode) {
        log.typehint('No type node found for symbol: %s', [nodeIdentForLog || '']);
        return false;
    }
    // Support for array-like type aliases and interfaces
    // e.g. type GridChildren = Array<Array<JSX.Element | undefined>>;
    if (typeNode.kind === ts.SyntaxKind.TypeReference) {
        var sym = node.symbol || node.aliasSymbol;
        var decls = sym.getDeclarations();
        var _c = __read(decls.filter(function (d) { return d.kind === ts.SyntaxKind.InterfaceDeclaration; }), 1), ifaceDecl = _c[0];
        if (!ifaceDecl) {
            log.typehint('No interface declaration found for symbol: %s', [nodeIdentForLog || '']);
            return false;
        }
        var isObjectType = false;
        if (!excludeObjects) {
            isObjectType = ifaceDecl.members.length > 0;
        }
        if (isObjectType || ifaceDecl.name.text === 'Array') {
            log.typehint('Found array-like interface declaration for symbol: %s', [nodeIdentForLog || '']);
            return 'mixed[]';
        }
    }
    if (!excludeObjects && typeNode.kind === ts.SyntaxKind.TypeLiteral) {
        var valueType = (_a = checker.getTypeAtLocation(baseNode)) === null || _a === void 0 ? void 0 : _a.getStringIndexType();
        var literalType = checkComplexLiteralType(valueType, checker);
        if (literalType) {
            log.typehint('Found array literal declaration of type %s for symbol: %s', [literalType, nodeIdentForLog || '']);
            return literalType;
        }
        else {
            log.typehint('Failed to infer array type, using MIXED for symbol: %s', [nodeIdentForLog || '']);
            return 'mixed[]';
        }
    }
    if (typeNode.kind === ts.SyntaxKind.ArrayType || typeNode.kind === ts.SyntaxKind.TupleType) {
        if (checkArrMixedNode(typeNode)) {
            log.typehint('Found MIXED in array/tuple type declaration for symbol: %s', [nodeIdentForLog || '']);
            return 'mixed';
        }
        var valueType = (_b = checker.getTypeAtLocation(baseNode)) === null || _b === void 0 ? void 0 : _b.getNumberIndexType();
        var literalType = checkComplexLiteralType(valueType, checker);
        if (literalType) {
            log.typehint('Found array/tuple literal declaration of type %s for symbol: %s', [literalType, nodeIdentForLog || '']);
            return literalType;
        }
        else {
            log.typehint('Failed to infer array/tuple type, using MIXED for symbol: %s', [nodeIdentForLog || '']);
            return 'mixed[]';
        }
    }
    return false;
}
var checkComplexLiteralType = function (valueType, checker) {
    if (!valueType) {
        return;
    }
    if (valueType.isUnionOrIntersection()) { // union type
        var apparentTypes = valueType.types
            .map(function (tp) { return checker.getApparentType(tp); })
            .map(function (tp) { return checker.typeToString(tp); })
            .map(function (tp) {
            if (['String', 'Boolean', 'Number'].includes(tp)) { // constructor names to primitive names
                return tp.toLowerCase();
            }
            return tp;
        });
        var uniq = new Set(apparentTypes);
        if (uniq.size === 1) { // all apparent types of union are the same
            return (basicTypesMap_1.typeMap[apparentTypes[0]] || 'mixed') + "[]";
        }
        else {
            return; // have more than one different apparent type.
        }
    }
    var typeStr = checker.typeToString(valueType);
    return (basicTypesMap_1.typeMap[typeStr] || 'mixed') + "[]";
};
// Such kludge, much bugs, wow.
// Workaround for proper mixed hint recognition.
var checkArrMixedNode = function (typeNode) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if (typeNode.kind === ts.SyntaxKind.TupleType) {
        // For [mixed, any]
        var types = typeNode.elementTypes /* ts < 4 */ || typeNode.elements;
        if (types && types.some(function (t) { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = t.typeName) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.declarations[0].type) === null || _c === void 0 ? void 0 : _c.types) === null || _d === void 0 ? void 0 : _d.some(function (t) { var _a; return ((_a = t.typeName) === null || _a === void 0 ? void 0 : _a.escapedText) === customTypehintsList_1.mixedTypehintId; }); })) {
            return true;
        }
    }
    if (typeNode.kind === ts.SyntaxKind.ArrayType) {
        // for mixed[]
        if ((_f = (_e = (_d = (_c = (_b = (_a = typeNode) === null || _a === void 0 ? void 0 : _a.elementType) === null || _b === void 0 ? void 0 : _b.typeName) === null || _c === void 0 ? void 0 : _c.symbol) === null || _d === void 0 ? void 0 : _d.declarations[0].type) === null || _e === void 0 ? void 0 : _e.types) === null || _f === void 0 ? void 0 : _f.some(function (t) { var _a; return ((_a = t.typeName) === null || _a === void 0 ? void 0 : _a.escapedText) === customTypehintsList_1.mixedTypehintId; })) {
            return true;
        }
        // for Array<mixed>
        if ((_k = (_j = (_h = (_g = typeNode) === null || _g === void 0 ? void 0 : _g.elementType) === null || _h === void 0 ? void 0 : _h.type) === null || _j === void 0 ? void 0 : _j.types) === null || _k === void 0 ? void 0 : _k.some(function (t) { var _a; return ((_a = t.typeName) === null || _a === void 0 ? void 0 : _a.escapedText) === customTypehintsList_1.mixedTypehintId; })) {
            return true;
        }
    }
    return false;
};
var transformTypeName = function (type, node, checker, log, nodeIdentForLog) { return function (t) {
    var _a, _b;
    var arrType = parseArrayType(type, node, checker, log, false, nodeIdentForLog);
    if (arrType) {
        return arrType;
    }
    if (t === 'Element' && ((_b = (_a = type.symbol) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.escapedName) === 'JSX') { // Workaround; jsx elements are rendered to strings
        return 'string';
    }
    return basicTypesMap_1.typeMap[t] || 'mixed';
}; };
function describeNodeType(node, type, checker, log) {
    var nodeIdentForLog = node === null || node === void 0 ? void 0 : node.getText();
    var optionalMark = ((node === null || node === void 0 ? void 0 : node.parent.kind) === ts.SyntaxKind.Parameter && (node.parent.initializer ||
        node.parent.questionToken)) ? '?' : '';
    if (node && ts.isStringLiteral(node)) {
        log.typehint('Inferred type of literal node: %s -> %s [5]', [nodeIdentForLog || '', 'string']);
        return optionalMark + 'string';
    }
    if (node && ts.isNumericLiteral(node)) {
        log.typehint('Inferred type of literal node: %s -> %s [5]', [nodeIdentForLog || '', 'float']);
        return optionalMark + 'float';
    }
    var customTypehints = customTypehints_1.checkCustomTypehints(type, checker);
    if (customTypehints) {
        var types = customTypehints.foundTypes.map(function (t) {
            if (typeof t === 'string') {
                return optionalMark + t;
            }
            // Some of union members may be literal types
            return optionalMark + describeAsApparentType(t, node, checker, log, nodeIdentForLog);
        }).filter(function (t) { return !customTypehints.typesToDrop.includes(t); });
        var typehint_1 = Array.from(new Set([]
            .concat(types)))
            .join('|');
        log.typehint('Inferred type of node: %s -> %s [1]', [nodeIdentForLog || '', typehint_1]);
        return typehint_1;
    }
    var strTypes = checker.typeToString(type, node, ts.TypeFormatFlags.None)
        .split('|')
        .map(function (t) { return t.replace(/^\s+|\s+$/g, ''); })
        .map(transformTypeName(type, node, checker, log, nodeIdentForLog));
    if (strTypes.includes('mixed')) {
        var types = type.isUnionOrIntersection() ? type.types : [type];
        var appStrTypes = types.map(function (t) {
            return describeAsApparentType(t, node, checker, log, nodeIdentForLog);
        });
        if (appStrTypes.includes('mixed')) {
            log.typehint('Inferred type of node: %s -> mixed [2]', [nodeIdentForLog || '']);
            return 'mixed';
        }
        var typehint_2 = Array.from(new Set([]
            .concat(strTypes.filter(function (t) { return t !== 'mixed'; }))
            .concat(appStrTypes)))
            .map(function (hint) { return optionalMark + hint; })
            .join('|');
        log.typehint('Inferred type of node: %s -> %s [3]', [nodeIdentForLog || '', typehint_2]);
        return typehint_2;
    }
    var typehint = Array.from(new Set([]
        .concat(strTypes)))
        .map(function (hint) { return optionalMark + hint; })
        .join('|');
    log.typehint('Inferred type of node: %s -> %s [4]', [nodeIdentForLog || '', typehint]);
    return typehint;
}
// Check parent types: Number for 1, String for "asd" etc
function describeAsApparentType(t, node, checker, log, nodeIdentForLog) {
    log.typehint('Failed to describe node: %s, checking apparent type', [nodeIdentForLog || '']);
    var appType = t.symbol ? checker.getApparentType(t) : checker.getBaseTypeOfLiteralType(t);
    var appStrType = checker.typeToString(appType).toLowerCase()
        .replace(/^\s+|\s+$/g, '');
    return transformTypeName(t, node, checker, log, nodeIdentForLog)(appStrType);
}
