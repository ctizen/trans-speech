"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleComponent = void 0;
var ts = require("typescript");
var ast_1 = require("../../utils/ast");
var renderNodes_1 = require("../codegen/renderNodes");
var hrtime_1 = require("../../utils/hrtime");
var functionScope_1 = require("../functionScope");
/**
 * Top-level functions marked with IC prefix are expected to be functional Isomorphic Components
 *
 * @param context
 * @param node
 */
function handleComponent(context, node) {
    var _a;
    var funcNode = ast_1.getClosestParentOfAnyType(node, [
        ts.SyntaxKind.FunctionDeclaration,
        ts.SyntaxKind.ArrowFunction,
        ts.SyntaxKind.FunctionExpression,
    ], true);
    var isNestedFunc = !!ast_1.getClosestParentOfAnyType(node, [
        ts.SyntaxKind.FunctionDeclaration,
        ts.SyntaxKind.ArrowFunction,
        ts.SyntaxKind.FunctionExpression,
    ]); // note difference: not including self
    var triviaContainer = node.kind === ts.SyntaxKind.FunctionDeclaration ?
        node :
        ast_1.getClosestOrigParentOfType(node, ts.SyntaxKind.VariableStatement);
    var trivia = triviaContainer === null || triviaContainer === void 0 ? void 0 : triviaContainer.getFullText().substr(0, triviaContainer === null || triviaContainer === void 0 ? void 0 : triviaContainer.getLeadingTriviaWidth());
    var isElephizedComponent = trivia === null || trivia === void 0 ? void 0 : trivia.includes('@elephizeTarget');
    var nodeName = node.kind === ts.SyntaxKind.FunctionDeclaration ?
        node.name :
        (_a = ast_1.getClosestOrigParentOfType(node, ts.SyntaxKind.VariableDeclaration)) === null || _a === void 0 ? void 0 : _a.name;
    if (!isNestedFunc && nodeName && nodeName.kind === ts.SyntaxKind.Identifier && isElephizedComponent) {
        var name_1 = nodeName.escapedText.toString();
        var descriptor = context.registry.deriveReactComponent(name_1, context.moduleDescriptor);
        if (!descriptor) {
            throw new Error();
        }
        var tmpDescriptor = context.moduleDescriptor;
        context.moduleDescriptor = descriptor;
        context.nodeFlagsStore.upsert(node, { isComponent: true });
        var decl = context.scope.addDeclaration(nodeName.getText(), [], { terminateGlobally: true, dryRun: context.dryRun });
        var stackCtr = hrtime_1.getTimeMarker();
        context.pushScope("component__" + stackCtr, nodeName.getText());
        context.scope.ownerNode.data.isComponent = true;
        // Declare all parameters
        funcNode.parameters.map(ast_1.fetchAllBindingIdents)
            .reduce(function (acc, val) { return acc.concat(val); }, []) // flatten;
            .forEach(function (ident) { return context.scope.addDeclaration(ident.getText(), [], { dryRun: context.dryRun }); });
        var args = renderNodes_1.renderNodes(__spreadArray([], __read(funcNode.parameters)), context);
        var block = renderNodes_1.renderNode(funcNode.body, context);
        block = functionScope_1.prependDestructuredParams(block, node, context);
        block = functionScope_1.prependDefaultParams(block, node, context);
        if (decl && decl.ownedScope) {
            context.scope.terminateToParentTerminalNode(context.dryRun);
        }
        context.popScope("component__" + stackCtr, funcNode.getLastToken());
        descriptor.setArgs(args.join(', '));
        descriptor.setBlock(block);
        context.moduleDescriptor = tmpDescriptor;
        return true;
    }
    return false;
}
exports.handleComponent = handleComponent;
